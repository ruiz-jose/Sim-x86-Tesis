<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>5.8 Módulo de entrada/salida e interrupciones | Herramienta de simulación para dar soporte a la enseñanza de arquitectura de computadoras</title>
  <meta name="description" content="5.8 Módulo de entrada/salida e interrupciones | Herramienta de simulación para dar soporte a la enseñanza de arquitectura de computadoras" />
  <meta name="generator" content="bookdown 0.45 and GitBook 2.6.7" />

  <meta property="og:title" content="5.8 Módulo de entrada/salida e interrupciones | Herramienta de simulación para dar soporte a la enseñanza de arquitectura de computadoras" />
  <meta property="og:type" content="book" />
  
  
  <meta name="github-repo" content="ruiz-jose/Sim-x86-Tesis" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="5.8 Módulo de entrada/salida e interrupciones | Herramienta de simulación para dar soporte a la enseñanza de arquitectura de computadoras" />
  
  
  

<meta name="author" content="Ruiz Jose Maria" />


<meta name="date" content="2025-01-01" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="ciclo-de-la-instrucción.html"/>
<link rel="next" href="validación-pedagógica-del-simulador.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>
<script src="libs/kePrint-0.0.1/kePrint.js"></script>
<link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet" />
<link href="libs/bsTable-3.3.7/bootstrapTable.min.css" rel="stylesheet" />
<script src="libs/bsTable-3.3.7/bootstrapTable.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>
<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Sim-x86</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Resumen</a></li>
<li class="chapter" data-level="" data-path="agradecimientos.html"><a href="agradecimientos.html"><i class="fa fa-check"></i>Agradecimientos</a></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Introducción</a>
<ul>
<li class="chapter" data-level="1.1" data-path="justificación.html"><a href="justificación.html"><i class="fa fa-check"></i><b>1.1</b> Justificación</a></li>
<li class="chapter" data-level="1.2" data-path="objetivos.html"><a href="objetivos.html"><i class="fa fa-check"></i><b>1.2</b> Objetivos</a></li>
<li class="chapter" data-level="1.3" data-path="metodología-de-desarrollo.html"><a href="metodología-de-desarrollo.html"><i class="fa fa-check"></i><b>1.3</b> Metodología de desarrollo</a></li>
<li class="chapter" data-level="1.4" data-path="organización-del-documento.html"><a href="organización-del-documento.html"><i class="fa fa-check"></i><b>1.4</b> Organización del documento</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="arquitectura.html"><a href="arquitectura.html"><i class="fa fa-check"></i><b>2</b> Arquitectura de computadoras</a>
<ul>
<li class="chapter" data-level="2.1" data-path="introducción-a-la-arquitectura-de-computadoras.html"><a href="introducción-a-la-arquitectura-de-computadoras.html"><i class="fa fa-check"></i><b>2.1</b> Introducción a la arquitectura de computadoras</a></li>
<li class="chapter" data-level="2.2" data-path="arquitecturas-von-neumann-y-harvard.html"><a href="arquitecturas-von-neumann-y-harvard.html"><i class="fa fa-check"></i><b>2.2</b> Arquitecturas Von Neumann y Harvard</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="arquitecturas-von-neumann-y-harvard.html"><a href="arquitecturas-von-neumann-y-harvard.html#arquitectura-von-neumann"><i class="fa fa-check"></i><b>2.2.1</b> Arquitectura Von Neumann</a></li>
<li class="chapter" data-level="2.2.2" data-path="arquitecturas-von-neumann-y-harvard.html"><a href="arquitecturas-von-neumann-y-harvard.html#arquitectura-harvard"><i class="fa fa-check"></i><b>2.2.2</b> Arquitectura Harvard</a></li>
<li class="chapter" data-level="2.2.3" data-path="arquitecturas-von-neumann-y-harvard.html"><a href="arquitecturas-von-neumann-y-harvard.html#comparativa-entre-von-neumann-y-harvard"><i class="fa fa-check"></i><b>2.2.3</b> Comparativa entre Von Neumann y Harvard</a></li>
<li class="chapter" data-level="2.2.4" data-path="arquitecturas-von-neumann-y-harvard.html"><a href="arquitecturas-von-neumann-y-harvard.html#arquitecturas-híbridas"><i class="fa fa-check"></i><b>2.2.4</b> Arquitecturas híbridas</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="tipos-de-arquitecturas.html"><a href="tipos-de-arquitecturas.html"><i class="fa fa-check"></i><b>2.3</b> Tipos de arquitecturas</a>
<ul>
<li class="chapter" data-level="2.3.1" data-path="tipos-de-arquitecturas.html"><a href="tipos-de-arquitecturas.html#arquitectura-x86"><i class="fa fa-check"></i><b>2.3.1</b> Arquitectura x86</a></li>
<li class="chapter" data-level="2.3.2" data-path="tipos-de-arquitecturas.html"><a href="tipos-de-arquitecturas.html#arquitectura-arm"><i class="fa fa-check"></i><b>2.3.2</b> Arquitectura ARM</a></li>
<li class="chapter" data-level="2.3.3" data-path="tipos-de-arquitecturas.html"><a href="tipos-de-arquitecturas.html#arquitectura-risc-v"><i class="fa fa-check"></i><b>2.3.3</b> Arquitectura RISC-V</a></li>
<li class="chapter" data-level="2.3.4" data-path="tipos-de-arquitecturas.html"><a href="tipos-de-arquitecturas.html#comparativa-entre-arquitecturas"><i class="fa fa-check"></i><b>2.3.4</b> Comparativa entre arquitecturas</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="repertorio-de-instrucciones.html"><a href="repertorio-de-instrucciones.html"><i class="fa fa-check"></i><b>2.4</b> Repertorio de instrucciones</a>
<ul>
<li class="chapter" data-level="2.4.1" data-path="repertorio-de-instrucciones.html"><a href="repertorio-de-instrucciones.html#características-clave-del-isa"><i class="fa fa-check"></i><b>2.4.1</b> Características clave del ISA</a></li>
<li class="chapter" data-level="2.4.2" data-path="repertorio-de-instrucciones.html"><a href="repertorio-de-instrucciones.html#modos-de-direccionamiento"><i class="fa fa-check"></i><b>2.4.2</b> Modos de direccionamiento</a></li>
<li class="chapter" data-level="2.4.3" data-path="repertorio-de-instrucciones.html"><a href="repertorio-de-instrucciones.html#formato-de-las-instrucciones"><i class="fa fa-check"></i><b>2.4.3</b> Formato de las instrucciones</a></li>
<li class="chapter" data-level="2.4.4" data-path="repertorio-de-instrucciones.html"><a href="repertorio-de-instrucciones.html#comparativa-de-repertorios-de-instrucciones"><i class="fa fa-check"></i><b>2.4.4</b> Comparativa de repertorios de instrucciones</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="filosofías-cisc-y-risc.html"><a href="filosofías-cisc-y-risc.html"><i class="fa fa-check"></i><b>2.5</b> Filosofías CISC y RISC</a>
<ul>
<li class="chapter" data-level="2.5.1" data-path="filosofías-cisc-y-risc.html"><a href="filosofías-cisc-y-risc.html#cisc"><i class="fa fa-check"></i><b>2.5.1</b> CISC</a></li>
<li class="chapter" data-level="2.5.2" data-path="filosofías-cisc-y-risc.html"><a href="filosofías-cisc-y-risc.html#RISC"><i class="fa fa-check"></i><b>2.5.2</b> RISC</a></li>
<li class="chapter" data-level="2.5.3" data-path="filosofías-cisc-y-risc.html"><a href="filosofías-cisc-y-risc.html#comparativa-entre-cisc-y-risc"><i class="fa fa-check"></i><b>2.5.3</b> Comparativa entre CISC y RISC</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="arquitectura-x86-1.html"><a href="arquitectura-x86-1.html"><i class="fa fa-check"></i><b>2.6</b> Arquitectura x86</a>
<ul>
<li class="chapter" data-level="2.6.1" data-path="arquitectura-x86-1.html"><a href="arquitectura-x86-1.html#evolución-de-la-arquitectura-x86"><i class="fa fa-check"></i><b>2.6.1</b> Evolución de la arquitectura x86</a></li>
<li class="chapter" data-level="2.6.2" data-path="arquitectura-x86-1.html"><a href="arquitectura-x86-1.html#repertorio-de-instrucciones-x86"><i class="fa fa-check"></i><b>2.6.2</b> Repertorio de instrucciones x86</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="lenguaje-máquina-y-lenguaje-ensamblador.html"><a href="lenguaje-máquina-y-lenguaje-ensamblador.html"><i class="fa fa-check"></i><b>2.7</b> Lenguaje máquina y lenguaje ensamblador</a>
<ul>
<li class="chapter" data-level="2.7.1" data-path="lenguaje-máquina-y-lenguaje-ensamblador.html"><a href="lenguaje-máquina-y-lenguaje-ensamblador.html#ensamblador"><i class="fa fa-check"></i><b>2.7.1</b> Ensamblador</a></li>
<li class="chapter" data-level="2.7.2" data-path="lenguaje-máquina-y-lenguaje-ensamblador.html"><a href="lenguaje-máquina-y-lenguaje-ensamblador.html#ensambladores-x86"><i class="fa fa-check"></i><b>2.7.2</b> Ensambladores x86</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="simulacion.html"><a href="simulacion.html"><i class="fa fa-check"></i><b>3</b> Simulación</a>
<ul>
<li class="chapter" data-level="3.1" data-path="introducción-a-la-simulación.html"><a href="introducción-a-la-simulación.html"><i class="fa fa-check"></i><b>3.1</b> Introducción a la simulación</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="introducción-a-la-simulación.html"><a href="introducción-a-la-simulación.html#aplicaciones-de-la-simulación-en-la-industria"><i class="fa fa-check"></i><b>3.1.1</b> Aplicaciones de la simulación en la industria</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="simulación-en-la-educación.html"><a href="simulación-en-la-educación.html"><i class="fa fa-check"></i><b>3.2</b> Simulación en la educación</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="simulación-en-la-educación.html"><a href="simulación-en-la-educación.html#el-rol-de-la-simulación-en-la-enseñanza-de-arquitectura-de-computadoras"><i class="fa fa-check"></i><b>3.2.1</b> El rol de la simulación en la enseñanza de Arquitectura de Computadoras</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="el-formalismo-devs-discrete-event-system-specification.html"><a href="el-formalismo-devs-discrete-event-system-specification.html"><i class="fa fa-check"></i><b>3.3</b> El Formalismo DEVS (Discrete Event System Specification)</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="el-formalismo-devs-discrete-event-system-specification.html"><a href="el-formalismo-devs-discrete-event-system-specification.html#estructura-del-formalismo-devs"><i class="fa fa-check"></i><b>3.3.1</b> Estructura del formalismo DEVS</a></li>
<li class="chapter" data-level="3.3.2" data-path="el-formalismo-devs-discrete-event-system-specification.html"><a href="el-formalismo-devs-discrete-event-system-specification.html#aplicaciones-del-formalismo-devs"><i class="fa fa-check"></i><b>3.3.2</b> Aplicaciones del formalismo DEVS</a></li>
<li class="chapter" data-level="3.3.3" data-path="el-formalismo-devs-discrete-event-system-specification.html"><a href="el-formalismo-devs-discrete-event-system-specification.html#devs-en-la-enseñanza-de-la-arquitectura-de-computadoras"><i class="fa fa-check"></i><b>3.3.3</b> DEVS en la enseñanza de la Arquitectura de Computadoras</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="comparativa.html"><a href="comparativa.html"><i class="fa fa-check"></i><b>4</b> Comparativa de simuladores</a>
<ul>
<li class="chapter" data-level="4.1" data-path="estudios-similares.html"><a href="estudios-similares.html"><i class="fa fa-check"></i><b>4.1</b> Estudios similares</a></li>
<li class="chapter" data-level="4.2" data-path="simuladores-bajo-análisis.html"><a href="simuladores-bajo-análisis.html"><i class="fa fa-check"></i><b>4.2</b> Simuladores bajo análisis</a></li>
<li class="chapter" data-level="4.3" data-path="criterios-de-evaluación.html"><a href="criterios-de-evaluación.html"><i class="fa fa-check"></i><b>4.3</b> Criterios de evaluación</a></li>
<li class="chapter" data-level="4.4" data-path="selección-de-simuladores.html"><a href="selección-de-simuladores.html"><i class="fa fa-check"></i><b>4.4</b> Selección de simuladores</a></li>
<li class="chapter" data-level="4.5" data-path="participantes-en-la-evaluación.html"><a href="participantes-en-la-evaluación.html"><i class="fa fa-check"></i><b>4.5</b> Participantes en la evaluación</a></li>
<li class="chapter" data-level="4.6" data-path="análisis-comparativo.html"><a href="análisis-comparativo.html"><i class="fa fa-check"></i><b>4.6</b> Análisis comparativo</a>
<ul>
<li class="chapter" data-level="4.6.1" data-path="análisis-comparativo.html"><a href="análisis-comparativo.html#simple-8-bit-assembler-simulator"><i class="fa fa-check"></i><b>4.6.1</b> Simple 8-bit Assembler Simulator</a></li>
<li class="chapter" data-level="4.6.2" data-path="análisis-comparativo.html"><a href="análisis-comparativo.html#vonsim"><i class="fa fa-check"></i><b>4.6.2</b> VonSim</a></li>
<li class="chapter" data-level="4.6.3" data-path="análisis-comparativo.html"><a href="análisis-comparativo.html#emu8086"><i class="fa fa-check"></i><b>4.6.3</b> Emu8086</a></li>
</ul></li>
<li class="chapter" data-level="4.7" data-path="resultados.html"><a href="resultados.html"><i class="fa fa-check"></i><b>4.7</b> Resultados</a>
<ul>
<li class="chapter" data-level="4.7.1" data-path="resultados.html"><a href="resultados.html#publicación"><i class="fa fa-check"></i><b>4.7.1</b> Publicación</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="desarrollo.html"><a href="desarrollo.html"><i class="fa fa-check"></i><b>5</b> Diseño y construcción del simulador</a>
<ul>
<li class="chapter" data-level="5.1" data-path="requisitos-de-la-herramienta.html"><a href="requisitos-de-la-herramienta.html"><i class="fa fa-check"></i><b>5.1</b> Requisitos de la herramienta</a></li>
<li class="chapter" data-level="5.2" data-path="justificación-pedagógica-de-la-arquitectura-simplificada.html"><a href="justificación-pedagógica-de-la-arquitectura-simplificada.html"><i class="fa fa-check"></i><b>5.2</b> Justificación pedagógica de la arquitectura simplificada</a></li>
<li class="chapter" data-level="5.3" data-path="introducción-a-vonsim.html"><a href="introducción-a-vonsim.html"><i class="fa fa-check"></i><b>5.3</b> Introducción a VonSim</a>
<ul>
<li class="chapter" data-level="5.3.1" data-path="introducción-a-vonsim.html"><a href="introducción-a-vonsim.html#stack-tecnológico"><i class="fa fa-check"></i><b>5.3.1</b> Stack tecnológico</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="estructura-y-componentes-de-vonsim8.html"><a href="estructura-y-componentes-de-vonsim8.html"><i class="fa fa-check"></i><b>5.4</b> Estructura y componentes de VonSim8</a>
<ul>
<li class="chapter" data-level="5.4.1" data-path="estructura-y-componentes-de-vonsim8.html"><a href="estructura-y-componentes-de-vonsim8.html#unidad-de-control"><i class="fa fa-check"></i><b>5.4.1</b> Unidad de Control</a></li>
<li class="chapter" data-level="5.4.2" data-path="estructura-y-componentes-de-vonsim8.html"><a href="estructura-y-componentes-de-vonsim8.html#unidad-aritmético-lógica-alu"><i class="fa fa-check"></i><b>5.4.2</b> Unidad Aritmético-Lógica (ALU)</a></li>
<li class="chapter" data-level="5.4.3" data-path="estructura-y-componentes-de-vonsim8.html"><a href="estructura-y-componentes-de-vonsim8.html#memoria-principal"><i class="fa fa-check"></i><b>5.4.3</b> Memoria principal</a></li>
<li class="chapter" data-level="5.4.4" data-path="estructura-y-componentes-de-vonsim8.html"><a href="estructura-y-componentes-de-vonsim8.html#buses-y-multiplexores"><i class="fa fa-check"></i><b>5.4.4</b> Buses y multiplexores</a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="adaptaciones-y-mejoras-en-vonsim8.html"><a href="adaptaciones-y-mejoras-en-vonsim8.html"><i class="fa fa-check"></i><b>5.5</b> Adaptaciones y mejoras en VonSim8</a></li>
<li class="chapter" data-level="5.6" data-path="repertorio-de-instrucciones-1.html"><a href="repertorio-de-instrucciones-1.html"><i class="fa fa-check"></i><b>5.6</b> Repertorio de instrucciones</a>
<ul>
<li class="chapter" data-level="5.6.1" data-path="repertorio-de-instrucciones-1.html"><a href="repertorio-de-instrucciones-1.html#modos-de-direccionamiento-1"><i class="fa fa-check"></i><b>5.6.1</b> Modos de direccionamiento</a></li>
<li class="chapter" data-level="5.6.2" data-path="repertorio-de-instrucciones-1.html"><a href="repertorio-de-instrucciones-1.html#formato-de-instrucciones"><i class="fa fa-check"></i><b>5.6.2</b> Formato de instrucciones</a></li>
</ul></li>
<li class="chapter" data-level="5.7" data-path="ciclo-de-la-instrucción.html"><a href="ciclo-de-la-instrucción.html"><i class="fa fa-check"></i><b>5.7</b> Ciclo de la instrucción</a>
<ul>
<li class="chapter" data-level="5.7.1" data-path="ciclo-de-la-instrucción.html"><a href="ciclo-de-la-instrucción.html#etapa-1-captación"><i class="fa fa-check"></i><b>5.7.1</b> Etapa 1: Captación</a></li>
<li class="chapter" data-level="5.7.2" data-path="ciclo-de-la-instrucción.html"><a href="ciclo-de-la-instrucción.html#etapa-2-ejecución"><i class="fa fa-check"></i><b>5.7.2</b> Etapa 2: Ejecución</a></li>
</ul></li>
<li class="chapter" data-level="5.8" data-path="módulo-de-entradasalida-e-interrupciones.html"><a href="módulo-de-entradasalida-e-interrupciones.html"><i class="fa fa-check"></i><b>5.8</b> Módulo de entrada/salida e interrupciones</a>
<ul>
<li class="chapter" data-level="5.8.1" data-path="módulo-de-entradasalida-e-interrupciones.html"><a href="módulo-de-entradasalida-e-interrupciones.html#etapa-de-ejecución-de-instrucciones"><i class="fa fa-check"></i><b>5.8.1</b> Etapa de ejecución de instrucciones</a></li>
<li class="chapter" data-level="5.8.2" data-path="módulo-de-entradasalida-e-interrupciones.html"><a href="módulo-de-entradasalida-e-interrupciones.html#pila-y-subrutinas"><i class="fa fa-check"></i><b>5.8.2</b> Pila y subrutinas</a></li>
<li class="chapter" data-level="5.8.3" data-path="módulo-de-entradasalida-e-interrupciones.html"><a href="módulo-de-entradasalida-e-interrupciones.html#interrupciones-y-llamadas-al-sistema"><i class="fa fa-check"></i><b>5.8.3</b> Interrupciones y llamadas al sistema</a></li>
<li class="chapter" data-level="5.8.4" data-path="módulo-de-entradasalida-e-interrupciones.html"><a href="módulo-de-entradasalida-e-interrupciones.html#llamadas-al-sistema"><i class="fa fa-check"></i><b>5.8.4</b> Llamadas al sistema</a></li>
<li class="chapter" data-level="5.8.5" data-path="módulo-de-entradasalida-e-interrupciones.html"><a href="módulo-de-entradasalida-e-interrupciones.html#pantalla"><i class="fa fa-check"></i><b>5.8.5</b> Pantalla</a></li>
<li class="chapter" data-level="5.8.6" data-path="módulo-de-entradasalida-e-interrupciones.html"><a href="módulo-de-entradasalida-e-interrupciones.html#teclado"><i class="fa fa-check"></i><b>5.8.6</b> Teclado</a></li>
<li class="chapter" data-level="5.8.7" data-path="módulo-de-entradasalida-e-interrupciones.html"><a href="módulo-de-entradasalida-e-interrupciones.html#puertos-de-es"><i class="fa fa-check"></i><b>5.8.7</b> Puertos de E/S</a></li>
<li class="chapter" data-level="5.8.8" data-path="módulo-de-entradasalida-e-interrupciones.html"><a href="módulo-de-entradasalida-e-interrupciones.html#instrucciones-in-y-out"><i class="fa fa-check"></i><b>5.8.8</b> Instrucciones IN y OUT</a></li>
<li class="chapter" data-level="5.8.9" data-path="módulo-de-entradasalida-e-interrupciones.html"><a href="módulo-de-entradasalida-e-interrupciones.html#módulo-pio-leds-e-interruptores"><i class="fa fa-check"></i><b>5.8.9</b> Módulo PIO (Leds e Interruptores)</a></li>
<li class="chapter" data-level="5.8.10" data-path="módulo-de-entradasalida-e-interrupciones.html"><a href="módulo-de-entradasalida-e-interrupciones.html#módulo-handshake-impresora"><i class="fa fa-check"></i><b>5.8.10</b> Módulo handshake (Impresora)</a></li>
<li class="chapter" data-level="5.8.11" data-path="módulo-de-entradasalida-e-interrupciones.html"><a href="módulo-de-entradasalida-e-interrupciones.html#módulo-pic-controlador-de-interrupciones"><i class="fa fa-check"></i><b>5.8.11</b> Módulo PIC (Controlador de Interrupciones)</a></li>
<li class="chapter" data-level="5.8.12" data-path="módulo-de-entradasalida-e-interrupciones.html"><a href="módulo-de-entradasalida-e-interrupciones.html#módulo-timer"><i class="fa fa-check"></i><b>5.8.12</b> Módulo timer</a></li>
</ul></li>
<li class="chapter" data-level="5.9" data-path="validación-pedagógica-del-simulador.html"><a href="validación-pedagógica-del-simulador.html"><i class="fa fa-check"></i><b>5.9</b> Validación pedagógica del simulador</a>
<ul>
<li class="chapter" data-level="5.9.1" data-path="validación-pedagógica-del-simulador.html"><a href="validación-pedagógica-del-simulador.html#objetivos-de-la-validación"><i class="fa fa-check"></i><b>5.9.1</b> Objetivos de la validación</a></li>
<li class="chapter" data-level="5.9.2" data-path="validación-pedagógica-del-simulador.html"><a href="validación-pedagógica-del-simulador.html#población-de-estudio"><i class="fa fa-check"></i><b>5.9.2</b> Población de estudio</a></li>
<li class="chapter" data-level="5.9.3" data-path="validación-pedagógica-del-simulador.html"><a href="validación-pedagógica-del-simulador.html#instrumentos-de-recolección-de-datos-ver-apéndice-anexo-b-refanexob"><i class="fa fa-check"></i><b>5.9.3</b> Instrumentos de recolección de datos (ver Apéndice: Anexo B @ref(anexoB))</a></li>
<li class="chapter" data-level="5.9.4" data-path="validación-pedagógica-del-simulador.html"><a href="validación-pedagógica-del-simulador.html#análisis-de-datos"><i class="fa fa-check"></i><b>5.9.4</b> Análisis de datos</a></li>
<li class="chapter" data-level="5.9.5" data-path="validación-pedagógica-del-simulador.html"><a href="validación-pedagógica-del-simulador.html#resultados-de-la-encuesta-de-retroalimentación-ver-apéndice-anexo-b-refanexoc"><i class="fa fa-check"></i><b>5.9.5</b> Resultados de la encuesta de retroalimentación (ver Apéndice: Anexo B @ref(anexoC))</a></li>
</ul></li>
<li class="chapter" data-level="5.10" data-path="aportes-y-contribuciones-del-simulador-vonsim8.html"><a href="aportes-y-contribuciones-del-simulador-vonsim8.html"><i class="fa fa-check"></i><b>5.10</b> Aportes y contribuciones del simulador VonSim8</a></li>
<li class="chapter" data-level="5.11" data-path="resumen-del-capítulo.html"><a href="resumen-del-capítulo.html"><i class="fa fa-check"></i><b>5.11</b> Resumen del capítulo</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="futuro.html"><a href="futuro.html"><i class="fa fa-check"></i><b>6</b> Trabajos Futuros</a>
<ul>
<li class="chapter" data-level="6.0.1" data-path="futuro.html"><a href="futuro.html#conclusión"><i class="fa fa-check"></i><b>6.0.1</b> Conclusión</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="apéndices.html"><a href="apéndices.html"><i class="fa fa-check"></i>Apéndices</a>
<ul>
<li class="chapter" data-level="6.1" data-path="anexoA.html"><a href="anexoA.html"><i class="fa fa-check"></i><b>6.1</b> Anexo A: Protocolo de Entrevista Semiestructurada</a>
<ul>
<li class="chapter" data-level="6.1.1" data-path="anexoA.html"><a href="anexoA.html#introducción-a-cargo-del-entrevistador"><i class="fa fa-check"></i><b>6.1.1</b> Introducción (a cargo del entrevistador)</a></li>
<li class="chapter" data-level="6.1.2" data-path="anexoA.html"><a href="anexoA.html#datos-generales-del-entrevistado"><i class="fa fa-check"></i><b>6.1.2</b> Datos generales del entrevistado</a></li>
<li class="chapter" data-level="6.1.3" data-path="anexoA.html"><a href="anexoA.html#preguntas-principales"><i class="fa fa-check"></i><b>6.1.3</b> Preguntas principales</a></li>
<li class="chapter" data-level="6.1.4" data-path="anexoA.html"><a href="anexoA.html#cierre"><i class="fa fa-check"></i><b>6.1.4</b> Cierre</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="anexoB.html"><a href="anexoB.html"><i class="fa fa-check"></i><b>6.2</b> Anexo B: Instrumentos de recolección de datos</a>
<ul>
<li class="chapter" data-level="6.2.1" data-path="anexoB.html"><a href="anexoB.html#encuesta-de-retroalimentación-unidad-ciclo-de-instrucción-y-simulador-vonsim8-estudiantes"><i class="fa fa-check"></i><b>6.2.1</b> 1) Encuesta de retroalimentación – Unidad Ciclo de Instrucción y simulador VonSim8 estudiantes</a></li>
<li class="chapter" data-level="6.2.2" data-path="anexoB.html"><a href="anexoB.html#encuesta-de-validación-unidad-ciclo-de-instrucción-y-simulador-vonsim8-docentes"><i class="fa fa-check"></i><b>6.2.2</b> 2) Encuesta de validación – Unidad Ciclo de Instrucción y simulador VonSim8 docentes</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="Biblio.html"><a href="Biblio.html"><i class="fa fa-check"></i><b>7</b> Bibliografía</a></li>
<li class="divider"></li>
<li><a href="https://github.com/ruiz-jose/Sim-x86-Tesis" target="blank">Publicado con bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Herramienta de simulación para dar soporte a la enseñanza de arquitectura de computadoras</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="módulo-de-entradasalida-e-interrupciones" class="section level2 hasAnchor" number="5.8">
<h2><span class="header-section-number">5.8</span> Módulo de entrada/salida e interrupciones<a href="módulo-de-entradasalida-e-interrupciones.html#módulo-de-entradasalida-e-interrupciones" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>El simulador permite configurar la conexión de diversos módulos de entrada/salida y otros dispositivos al bus principal, agrupados en las siguientes categorías:
- Teclado y pantalla.
- Un módulo PIO, que puede conectarse a LEDs e interruptores.
- Módulo Handshake, con posibilidad de conexión a una impresora, con o sin controlador PIC.
- Un controlador PIC, que interactúa con la tecla F10 para generar interrupciones, junto con un temporizador y su reloj asociado.</p>
<p>La Figura <a href="módulo-de-entradasalida-e-interrupciones.html#fig:dispositivos">5.24</a> muestra una visión general de los dispositivos que pueden conectarse al simulador.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:dispositivos"></span>
<img src="images/esquemavonsim8.png" alt="Arquitectura general del simulador" width="100%" />
<p class="caption">
Figura 5.24: Arquitectura general del simulador
</p>
</div>
<p>El componente chipSelect se encarga de activar el dispositivo correspondiente en cada momento. Para ello, recibe las señales de control del CPU junto con el bus de direcciones, y genera las señales de selección de chip (CS) necesarias para habilitar el dispositivo adecuado.</p>
<p>Para interactuar con los módulos de entrada y salida, es necesario incorporar nuevas instrucciones al repertorio del procesador. Estas instrucciones permiten la comunicación con los puertos de E/S y la gestión de interrupciones. La Tabla <a href="módulo-de-entradasalida-e-interrupciones.html#tab:tisa">5.12</a> detalla las categorías de instrucciones, sus códigos de operación y las acciones que realizan.</p>
<table class="table table-striped table-hover table-condensed table-responsive" style="width: auto !important; margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:tisa">Tabla 5.12: </span>Categoría de instrucciones y códigos de operación en VonSim8
</caption>
<thead>
<tr>
<th style="text-align:center;font-weight: bold;color: white !important;background-color: rgba(0, 115, 194, 255) !important;">
Categoría
</th>
<th style="text-align:center;font-weight: bold;color: white !important;background-color: rgba(0, 115, 194, 255) !important;">
Instrucción
</th>
<th style="text-align:center;font-weight: bold;color: white !important;background-color: rgba(0, 115, 194, 255) !important;">
Código operación
</th>
<th style="text-align:left;font-weight: bold;color: white !important;background-color: rgba(0, 115, 194, 255) !important;">
Acción
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;width: 12em; font-weight: bold;border-right:1px solid;">
Transferencia de datos
</td>
<td style="text-align:center;width: 16em; ">
MOV
</td>
<td style="text-align:center;width: 8em; ">
{0, 1, 2}
</td>
<td style="text-align:left;width: 32em; ">
Copiar entre registros, cargar a registro, almacenar en memoria
</td>
</tr>
<tr>
<td style="text-align:center;width: 12em; font-weight: bold;border-right:1px solid;">
Procesamiento de datos
</td>
<td style="text-align:center;width: 16em; ">
ADD
</td>
<td style="text-align:center;width: 8em; ">
{3, 4, 5}
</td>
<td style="text-align:left;width: 32em; ">
Operación aritmética: operando1 ← operando1 + operando2
</td>
</tr>
<tr>
<td style="text-align:center;width: 12em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 16em; ">
SUB
</td>
<td style="text-align:center;width: 8em; ">
{6, 7, 8}
</td>
<td style="text-align:left;width: 32em; ">
Operación aritmética: operando1 ← operando1 - operando2
</td>
</tr>
<tr>
<td style="text-align:center;width: 12em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 16em; ">
CMP
</td>
<td style="text-align:center;width: 8em; ">
{9, 10, 11}
</td>
<td style="text-align:left;width: 32em; ">
Comparación: operando1 - operando2 (no actualiza el destino)
</td>
</tr>
<tr>
<td style="text-align:center;width: 12em; font-weight: bold;border-right:1px solid;">
Control de flujo
</td>
<td style="text-align:center;width: 16em; ">
JMP / Jxx / CALL / INT
</td>
<td style="text-align:center;width: 8em; ">
{12}
</td>
<td style="text-align:left;width: 32em; ">
Salto incondicional JMP, salto condicionales Jxx, subrutina CALL, llamar rutina de interrupción INT
</td>
</tr>
<tr>
<td style="text-align:center;width: 12em; font-weight: bold;border-right:1px solid;">
Gestión de flujo
</td>
<td style="text-align:center;width: 16em; ">
HLT / RET / IRET / CLI / STI
</td>
<td style="text-align:center;width: 8em; ">
{13}
</td>
<td style="text-align:left;width: 32em; ">
Detener CPU HLT, retorno subrutina RET, retornar de interrupción IRET, deshabilita interrupciones CLI, habilita interrupciones STI
</td>
</tr>
<tr>
<td style="text-align:center;width: 12em; font-weight: bold;border-right:1px solid;">
Manejo de pila y E/S
</td>
<td style="text-align:center;width: 16em; ">
OUT / IN / PUSH / POP
</td>
<td style="text-align:center;width: 8em; ">
{14}
</td>
<td style="text-align:left;width: 32em; ">
Enviar a puerto OUT, recibir desde puerto IN, poner en la pila PUSH, retirar de la pila POP
</td>
</tr>
<tr>
<td style="text-align:center;width: 12em; font-weight: bold;border-right:1px solid;">
Miscelánea
</td>
<td style="text-align:center;width: 16em; ">
AND / OR / XOR / NOT / NEG / INC / DEC
</td>
<td style="text-align:center;width: 8em; ">
{15}
</td>
<td style="text-align:left;width: 32em; ">
Operaciones lógicas y aritméticas
</td>
</tr>
</tbody>
</table>
<p>El simulador utiliza un código de operación de 4 bits para las instrucciones, lo que simplifica la arquitectura del sistema pero limita el número máximo de instrucciones implementables a 16 opciones diferentes. Con el objetivo de ampliar el repertorio de instrucciones sin incrementar el tamaño de la codificación, se adoptó una estrategia de agrupación para el código de operación 15.</p>
<p>Bajo esta implementación, las instrucciones lógicas (AND, OR y XOR) comparten el código de operación 15 con las instrucciones aritméticas de un operando (INC, DEC, NEG y NOT). Esta decisión de diseño permite mantener la compatibilidad con los modos de direccionamiento establecidos para las instrucciones aritméticas de dos operandos (ADD, SUB y CMP), garantizando consistencia en la interfaz del simulador mientras se maximiza la funcionalidad dentro de las limitaciones impuestas por el esquema de codificación de 4 bits.</p>
<p>Esta solución representa un compromiso eficaz entre la simplicidad arquitectural y la capacidad funcional del simulador, permitiendo una mayor diversidad de operaciones sin comprometer la claridad pedagógica del diseño.</p>
<div id="etapa-de-ejecución-de-instrucciones" class="section level3 hasAnchor" number="5.8.1">
<h3><span class="header-section-number">5.8.1</span> Etapa de ejecución de instrucciones<a href="módulo-de-entradasalida-e-interrupciones.html#etapa-de-ejecución-de-instrucciones" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Finalmente, se detallan los pasos correspondientes a las instrucciones restantes del repertorio de instrucciones:</p>
<ul>
<li><strong>Subrutinas</strong>
<ul>
<li><strong>CALL <code>Dirección</code></strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>IP</code></strong> – Obtener dirección destino.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(Memoria[MAR])</code> | <code>IP</code> <span class="math inline">\(\leftarrow\)</span> <code>IP</code> + 1</strong> – Leer la dirección e incrementar IP.</li>
<li><strong><code>ri</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code> | <code>SP</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code> - 1</strong> - Guardar la dirección en ri y decrementar SP.</li>
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code> | <code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>IP</code></strong> - Preparar para apilar.</li>
<li><strong><code>write(Memoria[MAR])</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code> | <code>IP</code> <span class="math inline">\(\leftarrow\)</span> <code>ri</code></strong> - Guardar IP en la pila y saltar a la subrutina.</li>
</ol></li>
<li><strong>RET</strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code></strong> – Obtener dirección de retorno desde la pila.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(Memoria[MAR])</code></strong> – Leer la dirección de retorno.</li>
<li><strong><code>IP</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code>| <code>SP</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code> + 1</strong> – Restaurar IP y actualizar SP.</li>
</ol></li>
</ul></li>
<li><strong>Interrupciones</strong>
<ul>
<li><strong>INT <code>Dirección</code></strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>IP</code></strong> – Obtener dirección destino.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(Memoria[MAR])</code> | <code>IP</code> <span class="math inline">\(\leftarrow\)</span> <code>IP</code> + 1</strong> – Leer la dirección e incrementar IP.</li>
<li><strong><code>ri</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code> | <code>SP</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code> - 1</strong> – Guardar la dirección en ri y decrementar SP.</li>
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code> | <code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>Flags</code></strong> – Preparar para apilar los registros de estado.</li>
<li><strong><code>write(Memoria[MAR])</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code> | update(Flags I=0)</strong> – Guardar los registros de estado y desactivar interrupciones.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>IP</code> | <code>SP</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code> - 1</strong> – Guardar IP en la pila.</li>
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code></strong> – Preparar para apilar.</li>
<li><strong><code>write(Memoria[MAR])</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code></strong> - Guardar en la pila.</li>
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>ri</code></strong> - Obtener dirección rutina.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(Memoria[MAR])</code></strong> – Leer la dirección.</li>
<li><strong><code>IP</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code></strong> – Asigno dirección de la rutina de interrupción.</li>
</ol></li>
<li><strong>IRET</strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code></strong> – Obtener dirección de retorno desde la pila</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(Memoria[MAR])</code></strong> – Leer la dirección de retorno.</li>
<li><strong><code>IP</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code> | <code>SP</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code> + 1</strong> – Restaurar IP y actualizar SP.</li>
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code></strong> – Preparar para leer los registros de estado.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(Memoria[MAR])</code></strong> – Leer los registros de estado</li>
<li><strong><code>Flags</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code> | <code>SP</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code> + 1</strong> – Restaurar los registros de estado y actualizar SP.</li>
</ol></li>
<li><strong>CLI</strong>
<ol start="4" style="list-style-type: decimal">
<li><strong>update(Flags I=0)</strong> – Desactivar interrupciones.</li>
</ol></li>
<li><strong>STI</strong>
<ol start="4" style="list-style-type: decimal">
<li><strong>update(Flags I=1)</strong> – Activar interrupciones.</li>
</ol></li>
</ul></li>
<li><strong>E/S</strong>
<ul>
<li><strong>OUT</strong>
<ul>
<li>Direccion destino en registro <strong>OUT DL, AL</strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>DL</code></strong> – Obtener dirección destino.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>AL</code></strong> – Preparar el contenido a escribir.</li>
<li><strong><code>write(E-S[MAR])</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code></strong> – Escribir el contenido en el puerto de E/S.</li>
</ol></li>
<li>Direccion destino inmediato <strong>OUT inmediato, AL</strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>IP</code></strong> – Obtener dirección del dato inmediato.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(Memoria[MAR])</code> | <code>IP</code> <span class="math inline">\(\leftarrow\)</span> <code>IP</code> + 1</strong> – Leer el dato e incrementar IP.</li>
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code></strong> – Preparar la dirección destino.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>AL</code></strong> – Preparar el contenido a escribir.</li>
<li><strong><code>write(E-S[MAR])</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code></strong> – Escribir el contenido en el puerto de E/S.</li>
</ol></li>
</ul></li>
<li><strong>IN</strong>
<ul>
<li>Direccion destino en registro <strong>IN AL, DL</strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>DL</code></strong> – Obtener dirección del puerto de entrada.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(E-S[MAR])</code></strong> – Leer el contenido del puerto.</li>
<li><strong><code>AL</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code></strong> – Almacenar el contenido en AL.</li>
</ol></li>
<li>Direccion destino inmediato <strong>IN AL, inmediato</strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>IP</code></strong> – Obtener dirección del dato inmediato.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(Memoria[MAR])</code> | <code>IP</code> <span class="math inline">\(\leftarrow\)</span> <code>IP</code> + 1</strong> – Leer el dato e incrementar IP.</li>
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code></strong> – Preparar la dirección del puerto de entrada..</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(E-S[MAR])</code></strong> – Leer el contenido del puerto.</li>
<li><strong><code>AL</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code></strong> – Almacenar el contenido en AL.</li>
</ol></li>
</ul></li>
</ul></li>
<li><strong>Pila</strong>
<ul>
<li><strong>POP Rx</strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code></strong> – Obtener dirección de la pila.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(Memoria[MAR])</code></strong> – Leer el contenido de la pila.</li>
<li><strong><code>Rx</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code></strong> | <code>SP</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code> + 1 – Almacenar el contenido en Rx y actualizar SP.</li>
</ol></li>
<li><strong>PUSH Ry</strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code></strong> – Preparar la dirección de la pila.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>Ry</code></strong> | <code>SP</code> <span class="math inline">\(\leftarrow\)</span> <code>SP</code> - 1 – Preparar el contenido a escribir y actualizar SP.</li>
<li><strong><code>write(Memoria[MAR])</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code></strong> – Escribir el contenido en la pila.</li>
</ol></li>
</ul></li>
<li><strong>Operaciones Lógicas y Aritméticas</strong>
<ul>
<li><p><strong>Operaciones con dos operandos (AND, OR, XOR)</strong></p></li>
<li><p>Siguen los mismos pasos de ejecución que las operaciones aritméticas ADD y SUB, con la diferencia en la operación realizada por la ALU.</p></li>
<li><p><strong>Operaciones con un operando (NOT, NEG, INC, DEC)</strong></p>
<ul>
<li><strong>Destino en registro (<code>Rx</code>)</strong>
<ul>
<li><strong>INC <code>Rx</code></strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>Rx</code> <span class="math inline">\(\leftarrow\)</span> <code>Rx</code> + 1 | update(Flags)</strong> - Incrementar el valor del registro y actualizar los flags.</li>
</ol></li>
<li><strong>DEC <code>Rx</code></strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>Rx</code> <span class="math inline">\(\leftarrow\)</span> <code>Rx</code> - 1 | update(Flags)</strong> - Decrementar el valor del registro y actualizar los flags.</li>
</ol></li>
<li><strong>NOT <code>Rx</code></strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>Rx</code> <span class="math inline">\(\leftarrow\)</span> NOT <code>Rx</code> | update(Flags)</strong> - Realizar la operación lógica NOT y actualizar los flags.</li>
</ol></li>
<li><strong>NEG <code>Rx</code></strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>Rx</code> <span class="math inline">\(\leftarrow\)</span> CA2 <code>Rx</code> | update(Flags)</strong> - Realizar la operación de complemento a dos y actualizar los flags.</li>
</ol></li>
</ul></li>
<li><strong>Destino en memoria (<code>[Dirección]</code> o <code>[BL]</code>)</strong>
<ul>
<li><strong>Modo Directo (<code>[Dirección]</code>)</strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>IP</code></strong> – Obtener dirección destino.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(Memoria[MAR])</code> | <code>IP</code> <span class="math inline">\(\leftarrow\)</span> <code>IP</code> + 1</strong> – Leer la dirección e incrementar IP.</li>
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code></strong> – Transferir dirección a MAR.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(Memoria[MAR])</code></strong> – Leer el dato.</li>
<li>Ejecutar la operación:
- INC: <strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code> + 1 | update(Flags)</strong>
- DEC: <strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code> - 1 | update(Flags)</strong>
- NOT: <strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> NOT <code>MBR</code> | update(Flags)</strong>
- NEG: <strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> CA2 <code>MBR</code> | update(Flags)</strong></li>
<li><strong><code>write(Memoria[MAR])</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code></strong> – Escribir en memoria.</li>
</ol></li>
<li><strong>Modo Indirecto (<code>[BL]</code>)</strong>
<ol start="4" style="list-style-type: decimal">
<li><strong><code>MAR</code> <span class="math inline">\(\leftarrow\)</span> <code>BL</code></strong> – Transferir dirección de destino (en BL) a MAR.</li>
<li><strong><code>MBR</code> <span class="math inline">\(\leftarrow\)</span> <code>read(Memoria[MAR])</code></strong> – Leer el dato.</li>
<li>Ejecutar la operación (igual que en el caso anterior).</li>
<li><strong><code>write(Memoria[MAR])</code> <span class="math inline">\(\leftarrow\)</span> <code>MBR</code></strong> – Escribir en memoria.</li>
</ol></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="pila-y-subrutinas" class="section level3 hasAnchor" number="5.8.2">
<h3><span class="header-section-number">5.8.2</span> Pila y subrutinas<a href="módulo-de-entradasalida-e-interrupciones.html#pila-y-subrutinas" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>El procesador implementa una pila como método de almacenamiento, accesible tanto por el usuario como por la CPU para su funcionamiento interno. La pila opera bajo el esquema <em>Last In, First Out</em> (LIFO), es decir, el último elemento en ingresar es el primero en salir. Está ubicada en la memoria principal, comenzando en la dirección más alta (<code>FFh</code>) y creciendo hacia direcciones más bajas (<code>FEh</code>, <code>FCh</code>, etc.). El tope de la pila se gestiona mediante el registro <code>SP</code>, y cada elemento almacenado ocupa 8 bits.</p>
<p>Además, el procesador permite el uso de subrutinas, que son fragmentos de código reutilizables y pueden ser invocados desde cualquier parte del programa. Para llamar a una subrutina se utiliza la instrucción [<code>CALL</code>], que apila el valor actual de <code>IP</code> y salta a la dirección de la subrutina, modificando el <code>IP</code> para apuntar a la primera instrucción de la misma. El retorno se realiza mediante la instrucción [<code>RET</code>], que desapila la dirección previamente guardada y restaura el <code>IP</code>, permitiendo continuar la ejecución justo después de la llamada.</p>
<p>Ejemplo de subrutina:</p>
<pre class="assembly"><code>    mov al, 1
    mov bl, 2
    mov cl, 3
    call sum3
    ; ax = 6
    hlt

    ; suma al, bl y cl
    sum3: add al, bl
          add al, cl
          ret</code></pre>
</div>
<div id="interrupciones-y-llamadas-al-sistema" class="section level3 hasAnchor" number="5.8.3">
<h3><span class="header-section-number">5.8.3</span> Interrupciones y llamadas al sistema<a href="módulo-de-entradasalida-e-interrupciones.html#interrupciones-y-llamadas-al-sistema" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>El simulador VonSim8 incorpora un teclado y una pantalla como dispositivos de entrada y salida, permitiendo la interacción básica entre el usuario y el sistema para la entrada de datos y la visualización de resultados.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:tecladopantalla"></span>
<img src="images/tecladopantalla.png" alt="Teclado y pantalla" width="100%" />
<p class="caption">
Figura 5.25: Teclado y pantalla
</p>
</div>
<p>El vector de interrupciones está predefinido en posiciones reservadas de la memoria principal, donde se almacenan las direcciones de las rutinas del sistema para interactuar con el teclado y la pantalla. En el caso de las interrupciones por software, el número de interrupción se indica como operando en la instrucción <code>INT</code>. Al producirse una interrupción, el procesador ejecuta la rutina asociada al número de interrupción, cuya dirección de inicio se obtiene del vector de interrupciones. Este vector ocupa las celdas de memoria desde <code>00h</code> hasta <code>07h</code>, y cada elemento tiene 1 byte de longitud, correspondiendo cada uno a la dirección de inicio de la rutina respectiva.</p>
<p>El procesador admite interrupciones tanto por hardware como por software, generadas por el PIC o por la instrucción <code>INT</code>, respectivamente. Para que las interrupciones por hardware sean atendidas, el procesador debe tener habilitada la bandera de interrupciones (I=1). En ambos casos, se debe proporcionar un número de interrupción entre <code>0</code> y <code>7</code>.</p>
<p>El procedimiento que sigue el procesador ante una interrupción es el siguiente:</p>
<ol style="list-style-type: decimal">
<li>obtiene el número de la interrupción (0-7),</li>
<li>apila el registro <code>Flags</code>,</li>
<li>inhabilita las interrupciones <code>I=0</code>,</li>
<li>apila el registro <code>IP</code>,</li>
<li>obtiene la dirección de la rutina de interrupción desde el vector de interrupciones,</li>
<li>carga en el <code>IP</code> la dirección de la rutina de interrupción.</li>
</ol>
<p>La rutina de interrupción se ejecuta como una subrutina, pero finaliza con la instrucción <code>IRET</code> en lugar de <code>RET</code>.</p>
</div>
<div id="llamadas-al-sistema" class="section level3 hasAnchor" number="5.8.4">
<h3><span class="header-section-number">5.8.4</span> Llamadas al sistema<a href="módulo-de-entradasalida-e-interrupciones.html#llamadas-al-sistema" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>El simulador permite realizar llamadas al sistema (syscalls) mediante interrupciones, utilizando el número de interrupción correspondiente. Los números de interrupción reservados para llamadas al sistema son:</p>
<ul>
<li><code>INT 0</code>: termina la ejecución del programa (equivalente a <code>HLT</code>);</li>
<li><code>INT 6</code>: lee un carácter del teclado;</li>
<li><code>INT 7</code>: escribe una cadena de caracteres en pantalla.</li>
</ul>
<p>Las direcciones del vector de interrupciones asociadas a estas llamadas están protegidas por el sistema y no pueden ser modificadas por el usuario. El contenido de las rutinas correspondientes se encuentra almacenado en el monitor del sistema en las direcciones <code>A0h</code>, <code>B0h</code> y <code>C0h</code>, respectivamente.</p>
</div>
<div id="pantalla" class="section level3 hasAnchor" number="5.8.5">
<h3><span class="header-section-number">5.8.5</span> Pantalla<a href="módulo-de-entradasalida-e-interrupciones.html#pantalla" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>La pantalla es un dispositivo de salida que permite mostrar caracteres. La forma de comunicarse con la pantalla es mediante una llamada al sistema. Esto es así por simplicidad, ya que una pantalla real es mucho más compleja.</p>
<p>Con la llamada INT 7 se escribe una cadena de caracteres en la pantalla. Recibe dos parámetros:</p>
<p>AL: longitud de la cadena a imprimir
BL: dirección de memoria donde empieza la cadena</p>
<p>Ejemplo de hola mundo en lenguaje ensamblador para el simulador VonSim8:</p>
<pre class="assembly"><code>cadena DB `Hola!`
MOV BL, offset cadena
MOV AL, 5
INT 7
; Se imprime Hola! (sin las comillas) en la pantalla.
HLT</code></pre>
<p>Hay tres caracteres especiales:</p>
<ul>
<li>el carácter de retroceso (<code>BS</code>, 8 en decimal) borra el carácter previo;</li>
<li>el carácter de salto de línea (<code>LF</code>, 10 en decimal) imprime, en efecto, un salto de línea — útil para no imprimir todo en una sola línea;</li>
<li>el carácter de <em>form feed</em> (<code>FF</code>, 12 en decimal) limpia la pantalla.</li>
</ul>
</div>
<div id="teclado" class="section level3 hasAnchor" number="5.8.6">
<h3><span class="header-section-number">5.8.6</span> Teclado<a href="módulo-de-entradasalida-e-interrupciones.html#teclado" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>El teclado se modela como un vector de 16 posiciones, cada una capaz de almacenar un carácter ASCII. La pantalla, por su parte, se representa como una matriz de 16×16 que permite visualizar caracteres, facilitando así la comprensión del manejo de entrada y salida de datos en una arquitectura computacional simplificada.</p>
<p>El teclado es un dispositivo de entrada que permite al usuario ingresar caracteres al sistema. La forma de comunicarse con el teclado es mediante una llamada al sistema. Esto es así por simplicidad, ya que un teclado real es mucho más complejo.</p>
<p>Con la llamada INT 6 se detiene la ejecución del código hasta que se presione una tecla en el teclado. El carácter que correspona será guardado en la dirección de memoria almacenada en BL según su representación en ASCII.</p>
<pre class="assembly"><code>car db 0
mov bl, offset car
int 6
hlt

; El carácter escrito se almacenó en &#39;car&#39;.
; Por ejemplo, si el usuario presionó la tecla &#39;a&#39;, entonces
; se almacena el valor 61h en &#39;car&#39;.</code></pre>
</div>
<div id="puertos-de-es" class="section level3 hasAnchor" number="5.8.7">
<h3><span class="header-section-number">5.8.7</span> Puertos de E/S<a href="módulo-de-entradasalida-e-interrupciones.html#puertos-de-es" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>La memoria de entrada/salida está completamente separada de la memoria principal. Para interactuar con ella, se emplean exclusivamente las instrucciones [IN] y [OUT]. Cuando se requiere acceder a un módulo de entrada/salida, la [CPU] activa la señal IO/M, lo que provoca que un selector de chips (chip select) interprete la dirección presente en el bus de direcciones y envíe la señal de activación al módulo correspondiente.</p>
<p>El rango de direcciones asignado a la memoria de entrada/salida abarca desde <code>00h</code> hasta <code>FFh</code>, lo que permite un total de 256 direcciones. A continuación, se presentan las direcciones de entrada/salida disponibles en el simulador, todas de 8 bits:</p>
<table class="table table-striped table-hover table-condensed table-responsive" style="width: auto !important; margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:tpuertos">Tabla 5.13: </span>Módulos, direcciones y nombres del simulador
</caption>
<thead>
<tr>
<th style="text-align:center;font-weight: bold;color: white !important;background-color: rgba(0, 115, 194, 255) !important;">
Módulo
</th>
<th style="text-align:center;font-weight: bold;color: white !important;background-color: rgba(0, 115, 194, 255) !important;">
Dirección
</th>
<th style="text-align:center;font-weight: bold;color: white !important;background-color: rgba(0, 115, 194, 255) !important;">
Nombre
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;background-color: rgba(240, 240, 240, 255) !important;">
Timer
</td>
<td style="text-align:center;width: 12em; background-color: rgba(240, 240, 240, 255) !important;">
10h
</td>
<td style="text-align:center;width: 16em; background-color: rgba(240, 240, 240, 255) !important;">
CONT
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 12em; ">
11h
</td>
<td style="text-align:center;width: 16em; ">
COMP
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;background-color: rgba(240, 240, 240, 255) !important;">
PIC
</td>
<td style="text-align:center;width: 12em; background-color: rgba(240, 240, 240, 255) !important;">
20h
</td>
<td style="text-align:center;width: 16em; background-color: rgba(240, 240, 240, 255) !important;">
EOI
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 12em; ">
21h
</td>
<td style="text-align:center;width: 16em; ">
IMR
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 12em; ">
22h
</td>
<td style="text-align:center;width: 16em; ">
IRR
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 12em; ">
23h
</td>
<td style="text-align:center;width: 16em; ">
ISR
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 12em; ">
24h
</td>
<td style="text-align:center;width: 16em; ">
INT0
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 12em; ">
25h
</td>
<td style="text-align:center;width: 16em; ">
INT1
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 12em; ">
26h
</td>
<td style="text-align:center;width: 16em; ">
INT2
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 12em; ">
27h
</td>
<td style="text-align:center;width: 16em; ">
INT3
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;background-color: rgba(240, 240, 240, 255) !important;">
PIO
</td>
<td style="text-align:center;width: 12em; background-color: rgba(240, 240, 240, 255) !important;">
28h
</td>
<td style="text-align:center;width: 16em; background-color: rgba(240, 240, 240, 255) !important;">
PA
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 12em; ">
29h
</td>
<td style="text-align:center;width: 16em; ">
PB
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 12em; ">
2Ah
</td>
<td style="text-align:center;width: 16em; ">
CA
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 12em; ">
2Bh
</td>
<td style="text-align:center;width: 16em; ">
CB
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;background-color: rgba(240, 240, 240, 255) !important;">
Handshake
</td>
<td style="text-align:center;width: 12em; background-color: rgba(240, 240, 240, 255) !important;">
40h
</td>
<td style="text-align:center;width: 16em; background-color: rgba(240, 240, 240, 255) !important;">
DATA
</td>
</tr>
<tr>
<td style="text-align:center;width: 16em; font-weight: bold;border-right:1px solid;">
</td>
<td style="text-align:center;width: 12em; ">
41h
</td>
<td style="text-align:center;width: 16em; ">
STATE
</td>
</tr>
</tbody>
</table>
</div>
<div id="instrucciones-in-y-out" class="section level3 hasAnchor" number="5.8.8">
<h3><span class="header-section-number">5.8.8</span> Instrucciones IN y OUT<a href="módulo-de-entradasalida-e-interrupciones.html#instrucciones-in-y-out" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>La comunicación con los módulos de entrada/salida se realiza a través de puertos, que son direcciones específicas dentro del espacio de direcciones del procesador. En este simulador, se implementan dos instrucciones fundamentales para gestionar esta comunicación:</p>
<ul>
<li><code>OUT puerto, AL</code>: envía el contenido del registro <code>AL</code> al puerto especificado. El puerto es una dirección de 8 bits, lo que permite un total de 256 puertos diferentes (de <code>00h</code> a <code>FFh</code>). Esta instrucción se utiliza para transmitir datos a dispositivos externos, como impresoras o pantallas.</li>
<li><code>IN AL, puerto</code>: recibe un byte desde el puerto especificado y lo almacena en el registro <code>AL</code>. Al igual que la instrucción <code>OUT</code>, el puerto es una dirección de 8 bits.</li>
</ul>
</div>
<div id="módulo-pio-leds-e-interruptores" class="section level3 hasAnchor" number="5.8.9">
<h3><span class="header-section-number">5.8.9</span> Módulo PIO (Leds e Interruptores)<a href="módulo-de-entradasalida-e-interrupciones.html#módulo-pio-leds-e-interruptores" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>El módulo de entrada/salida programada (Programmed Input-Output, PIO) actúa como interfaz entre la CPU y los dispositivos periféricos genéricos. Su diseño está basado en el controlador PPI 8255 de Intel, específicamente en su modo <code>0</code>, pero incorpora modificaciones orientadas a simplificar su funcionamiento para fines educativos <span class="citation">(<a href="#ref-intel8086manual">Intel Corporation 1979</a>)</span>.</p>
<p>El módulo cuenta con dos puertos bidireccionales de 8 bits (A y B) que pueden ser configurados de manera independiente. Su arquitectura incluye cuatro registros accesibles:</p>
<ul>
<li>PA (dirección 30h en el espacio de memoria E/S): registro de datos del puerto A</li>
<li>PB (dirección 31h en el espacio de memoria E/S): registro de datos del puerto B</li>
<li>CA (dirección 32h en el espacio de memoria E/S): registro de configuración del puerto A</li>
<li>CB (dirección 33h en el espacio de memoria E/S): registro de configuración del puerto B</li>
</ul>
<p>La configuración de cada puerto se define a través de sus respectivos registros de control (CA y CB). Cada bit del registro de configuración determina la dirección del bit correspondiente en el puerto de datos: un valor <code>0</code> configura el bit como salida, mientras que un valor <code>1</code> lo configura como entrada. Por ejemplo, si CA = 00001111b, los cuatro bits más significativos del puerto A funcionarán como salidas, y los cuatro bits menos significativos como entradas. El puerto B opera de manera idéntica mediante su registro CB.</p>
<p>Este módulo PIO puede conectarse a diferentes tipos de dispositivos periféricos, como LEDs y interruptores, o a dispositivos más complejos como una impresora, proporcionando así una interfaz versátil para la comunicación con el mundo exterior.</p>
<div id="leds" class="section level4 hasAnchor" number="5.8.9.1">
<h4><span class="header-section-number">5.8.9.1</span> Leds<a href="módulo-de-entradasalida-e-interrupciones.html#leds" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Los diodos emisores de luz (LEDs) funcionan como dispositivos de salida y están conectados al puerto B del módulo PIO. Su control se realiza mediante la manipulación del registro de datos PB (dirección 31h) en conjunto con el registro de configuración CB (dirección 33h).</p>
<p>Para que los LEDs respondan correctamente, es necesario configurar previamente el puerto B como salida escribiendo el valor apropiado en el registro CB. Una vez configurado correctamente el PIO, cualquier modificación en el valor del registro PB se reflejará inmediatamente en el estado de los LEDs correspondientes. En caso de que la configuración del puerto sea incorrecta o se omita este paso, los LEDs permanecerán apagados independientemente de los valores escritos en PB.</p>
<p>Esta configuración permite controlar individualmente cada LED mediante los bits del puerto, ofreciendo flexibilidad para crear patrones luminosos o indicadores visuales en aplicaciones educativas y de demostración.</p>
<p>Las luces o LEDs están conectadas al puerto PB/CB del PIO y funcionan como dispositivos de salida. Su estado solo puede modificarse alterando el valor del puerto PB. Estos cambios se reflejarán en las luces si el PIO está configurado correctamente; de lo contrario, las luces permanecerán apagadas.</p>
<pre class="assembly"><code>; Enciende las luces (una sí, una no): 1010 1010b
; 31h = PB --&gt; puerto de datos para las luces (LEDs)
; 33h = CB --&gt; puerto de control para las luces

; Configura todos los bits de PB como salida para controlar las luces
mov al, 0                ; 0000 0000b: todos los bits de PB en modo salida
out 33h, al              ; Escribe en CB para configurar PB como salida

; Enciende las luces alternadas: 1010 1010b (170 decimal)
mov al, 170              ; 1010 1010b: enciende LEDs pares, apaga impares
out 31h, al              ; Escribe el valor en PB para actualizar las luces

hlt                      ; Detiene la ejecución del programa</code></pre>
</div>
<div id="interruptores" class="section level4 hasAnchor" number="5.8.9.2">
<h4><span class="header-section-number">5.8.9.2</span> interruptores<a href="módulo-de-entradasalida-e-interrupciones.html#interruptores" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Los interruptores (también denominados llaves) funcionan como dispositivos de entrada conectados al puerto A del módulo PIO. Su operación se gestiona mediante el registro de datos PA (dirección 30h) y el registro de configuración CA (dirección 32h).</p>
<p>Para que los interruptores operen correctamente, es fundamental configurar previamente el puerto A como entrada mediante el registro CA. Una vez establecida la configuración apropiada, cualquier cambio en el estado físico de los interruptores se reflejará automáticamente en los bits correspondientes del registro PA, permitiendo al programa leer su estado actual.</p>
<p>Es importante destacar que la comunicación es unidireccional desde los dispositivos hacia el procesador: aunque es posible escribir valores directamente en el registro PA mediante software, estos cambios no alterarán el estado físico de los interruptores. Los dispositivos de entrada mantienen su estado independientemente de las modificaciones realizadas por programa en sus registros asociados, garantizando así la integridad de la información proveniente del mundo exterior.</p>
<pre class="assembly"><code>; Leer el valor de las llaves como una contraseña hasta que el usuario la adivine

clave db 15               ; Contraseña esperada: 00001111 (en decimal 15)
mensaje_ok db &#39;Bienvenido!&#39; ; Mensaje a mostrar si la contraseña es correcta

; Configurar PA (Puerto A) como entrada
mov al, 15                ; 00001111b: configura los primeros 4 bits de PA como entrada
out 32h, al               ; Escribe en CA para configurar PA

bucle:
  in al, 30h            ; Lee el valor actual de las llaves desde PA
  cmp al, clave         ; Compara el valor leído con la contraseña
  jz Mostrar_Mensaje    ; Si coincide, salta a Mostrar_Mensaje
  jmp bucle             ; Si no coincide, vuelve a intentar

Mostrar_Mensaje:
  mov bl, offset mensaje_ok ; BL apunta al mensaje de éxito
  mov al, 11                ; Longitud del mensaje tiene 11 caracteres
  int 7
  hlt                       ; Detiene la ejecución del programa</code></pre>
</div>
</div>
<div id="módulo-handshake-impresora" class="section level3 hasAnchor" number="5.8.10">
<h3><span class="header-section-number">5.8.10</span> Módulo handshake (Impresora)<a href="módulo-de-entradasalida-e-interrupciones.html#módulo-handshake-impresora" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>El módulo Handshake es un controlador especializado diseñado para facilitar la comunicación con impresoras que utilizan el protocolo Centronics. Su diseño se inspira en el controlador PPI 8255 de Intel, operando en modo “1”, pero incluye modificaciones específicas para simplificar su uso y comprensión en entornos educativos.</p>
<p>El módulo cuenta con una arquitectura simplificada basada en dos registros de 8 bits:</p>
<ul>
<li><strong>Registro de datos</strong>: ubicado en la dirección 40h del espacio de memoria de E/S.</li>
<li><strong>Registro de estado</strong>: ubicado en la dirección 41h del espacio de memoria de E/S.</li>
</ul>
<p>La estructura de estos registros se organiza de la siguiente manera:</p>
<pre><code>Datos  = DDDD DDDD
Estado = I___ __SB</code></pre>
<div id="funcionamiento-del-registro-de-datos" class="section level4 hasAnchor" number="5.8.10.1">
<h4><span class="header-section-number">5.8.10.1</span> Funcionamiento del registro de datos<a href="módulo-de-entradasalida-e-interrupciones.html#funcionamiento-del-registro-de-datos" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>El registro de datos almacena el carácter que se desea imprimir, codificado en formato ASCII. Una característica destacada del módulo Handshake es su capacidad de automatización: cada vez que la CPU escribe un valor en este registro, el controlador genera automáticamente un flanco ascendente en la señal strobe, iniciando el proceso de impresión sin necesidad de intervención adicional por parte del software.</p>
</div>
<div id="funcionamiento-del-registro-de-estado" class="section level4 hasAnchor" number="5.8.10.2">
<h4><span class="header-section-number">5.8.10.2</span> Funcionamiento del registro de estado<a href="módulo-de-entradasalida-e-interrupciones.html#funcionamiento-del-registro-de-estado" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>El registro de estado gestiona las señales de control y supervisión del protocolo de comunicación. Sus principales componentes son:</p>
<ul>
<li><strong>Bits S y B (strobe y busy)</strong>: los dos bits menos significativos controlan las señales de comunicación, con diferencias clave respecto a la implementación en el PIO:
<ul>
<li>El bit busy es de solo lectura y refleja automáticamente el estado de la impresora</li>
<li>El bit strobe permanece normalmente en 0 y es gestionado automáticamente por el módulo. Cuando la CPU escribe un 1 en el bit strobe, se genera un flanco ascendente que transmite los datos almacenados en el registro de datos, retornando automáticamente a 0.</li>
</ul></li>
<li><strong>Bit I (interrupción)</strong>: El bit más significativo controla el sistema de interrupciones del módulo. Cuando este bit está habilitado (I=1) y la impresora se encuentra disponible (B=0), el módulo Handshake genera una interrupción por hardware a través de la línea INT2 del controlador PIC, notificando al sistema que la impresora está lista para recibir nuevos datos.</li>
</ul>
<p>Esta implementación ofrece una interfaz intuitiva para el control de impresoras, automatizando aspectos críticos del protocolo de comunicación y manteniendo la flexibilidad necesaria para comprender los fundamentos de la interacción con dispositivos periféricos.</p>
</div>
<div id="ejemplo-de-uso-del-módulo-handshake-con-sondeo" class="section level4 hasAnchor" number="5.8.10.3">
<h4><span class="header-section-number">5.8.10.3</span> Ejemplo de uso del módulo Handshake con sondeo<a href="módulo-de-entradasalida-e-interrupciones.html#ejemplo-de-uso-del-módulo-handshake-con-sondeo" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Para imprimir utilizando el módulo Handshake, se deben seguir los siguientes pasos:</p>
<ol style="list-style-type: decimal">
<li>Verificar que el buffer no esté lleno (flag busy).</li>
<li>Escribir el carácter en el registro de datos.</li>
</ol>
<p>Además de los caracteres ASCII comunes, el módulo admite caracteres especiales útiles para la impresión:
- Salto de línea (<code>LF</code>, 10 en decimal): Imprime un salto de línea, evitando que todo el texto se imprima en una sola línea.
- Form feed (<code>FF</code>, 12 en decimal): Limpia la impresora, equivalente a arrancar una hoja.</p>
<p>A continuación, se presenta un ejemplo en ensamblador para imprimir la cadena “Hola” utilizando el módulo Handshake:</p>
<pre class="assembly"><code>; Imprime el string &#39;Hola&#39; en la impresora usando sondeo

dato DB &#39;Hola&#39;, 0         ; String a imprimir, terminado en 0 (carácter nulo)

HS_DATA   EQU 40h         ; Dirección del registro de datos del Handshake
HS_STATUS EQU 41h         ; Dirección del registro de estado del Handshake

;  Deshabilita las interrupciones del Handshake (bit 7 en 0) 
IN  AL, HS_STATUS
AND AL, 01111111b         ; Fuerza el bit 7 a 0 (sin interrupciones)
OUT HS_STATUS, AL

; Inicializa el puntero al string 
MOV BL, OFFSET dato       ; BL apunta al primer carácter del string

; Bucle principal: espera espacio en el buffer e imprime 
Sondeo:
  IN  AL, HS_STATUS
  AND AL, 00000001b     ; Lee el flag busy (bit 0): 1=lleno, 0=libre
  JZ  ImprimirCadena   ; Si busy=0, hay espacio y puede imprimir
  JMP Sondeo            ; Si busy=1, espera hasta que haya espacio

ImprimirCadena:
  MOV AL, [BL]          ; Carga el siguiente carácter del string
  CMP AL, 0             ; ¿Es el final del string? (carácter nulo)
  JZ fin                ; Si sí, termina el programa

  OUT HS_DATA, AL       ; Envía el carácter al registro de datos del Handshake

  INC BL                ; Avanza al siguiente carácter del string
  JMP Sondeo            ; Repite el proceso para el próximo carácter

fin:
  HLT   ; Detiene la ejecución</code></pre>
<p>Para mejorar la lectura del programa se utilizan constantes en ensamblador “EQU” para definir las direcciones de los puertos del módulo Handshake.</p>
</div>
</div>
<div id="módulo-pic-controlador-de-interrupciones" class="section level3 hasAnchor" number="5.8.11">
<h3><span class="header-section-number">5.8.11</span> Módulo PIC (Controlador de Interrupciones)<a href="módulo-de-entradasalida-e-interrupciones.html#módulo-pic-controlador-de-interrupciones" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>El Programmable Interrupt Controller (PIC) es un módulo que actúa como intermediario entre los dispositivos que generan interrupciones y la CPU. Dado que la CPU dispone de una única línea de entrada para interrupciones, el PIC se encarga de recibir solicitudes de múltiples dispositivos y multiplexarlas en esta línea única.</p>
<p>Este módulo está basado en el PIC 8259A de Intel, aunque se han realizado modificaciones para simplificar su funcionamiento y adaptarlo a fines educativos.</p>
<div id="líneas-de-interrupción" class="section level4 hasAnchor" number="5.8.11.1">
<h4><span class="header-section-number">5.8.11.1</span> Líneas de interrupción<a href="módulo-de-entradasalida-e-interrupciones.html#líneas-de-interrupción" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>El PIC dispone de 4 líneas de interrupción, denominadas INT0 a INT3 (aunque no todas son utilizadas). Cada línea está asociada a un registro de 8 bits en la memoria de E/S. Por ejemplo, la línea INT0 corresponde a la dirección 24h, la línea INT1 a la dirección 25h, y así sucesivamente hasta la línea INT3, que utiliza la dirección 26h. En estos registros se almacena el número de interrupción asociado a cada línea.</p>
<p>Cuando un dispositivo o módulo solicita una interrupción, el PIC envía a la CPU el número de interrupción almacenado en el registro correspondiente, desacoplando así el número de línea del número de interrupción.</p>
<p>Las líneas están conectadas a los siguientes dispositivos:</p>
<table class="table table-striped table-hover table-condensed table-responsive" style="width: auto !important; margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:tPIC">Tabla 5.14: </span>Líneas de interrupción y dispositivos asociados
</caption>
<thead>
<tr>
<th style="text-align:center;font-weight: bold;color: white !important;background-color: rgba(0, 115, 194, 255) !important;">
Línea
</th>
<th style="text-align:left;font-weight: bold;color: white !important;background-color: rgba(0, 115, 194, 255) !important;">
Módulo/Disp.
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;width: 6em; font-weight: bold;border-right:1px solid;">
INT0
</td>
<td style="text-align:left;width: 22em; ">
<a href="módulo-de-entradasalida-e-interrupciones.html#tecla-f10">Tecla F10</a>
</td>
</tr>
<tr>
<td style="text-align:center;width: 6em; font-weight: bold;border-right:1px solid;">
INT1
</td>
<td style="text-align:left;width: 22em; ">
[Timer]
</td>
</tr>
<tr>
<td style="text-align:center;width: 6em; font-weight: bold;border-right:1px solid;">
INT2
</td>
<td style="text-align:left;width: 22em; ">
[Handshake]
</td>
</tr>
<tr>
<td style="text-align:center;width: 6em; font-weight: bold;border-right:1px solid;">
INT3
</td>
<td style="text-align:left;width: 22em; ">
–
</td>
</tr>
</tbody>
</table>
</div>
<div id="registros-de-control" class="section level4 hasAnchor" number="5.8.11.2">
<h4><span class="header-section-number">5.8.11.2</span> Registros de control<a href="módulo-de-entradasalida-e-interrupciones.html#registros-de-control" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>El PIC cuenta con tres registros adicionales para gestionar las interrupciones. Cada bit de estos registros corresponde a una línea de interrupción, donde el bit menos significativo representa la línea da bit corresponde con una línea de interrupción: el bit menos significativo corresponde a la línea y el más significativo la línea <code>INT3</code>.</p>
<ul>
<li><p><strong>Registro IMR (Interrupt Mask Register)</strong>: Ubicado en la dirección <code>21h</code> de la memoria de E/S, este registro permite enmascarar (inhabilitar) líneas de interrupción. Si un bit está en 1, la línea correspondiente está enmascarada y no generará interrupciones en la CPU. Si el bit está en 0, la línea está habilitada. Este registro puede ser modificado por la CPU.</p></li>
<li><p><strong>Registro IRR (Interrupt Request Register)</strong>: Ubicado en la dirección <code>22h</code>, este registro indica las interrupciones pendientes. Si un bit está en 1, la línea correspondiente tiene una interrupción pendiente. Este registro es de solo lectura para la CPU y es gestionado por el PIC.</p></li>
<li><p><strong>Registro ISR (In-Service Register)</strong>: Ubicado en la dirección <code>23h</code>, este registro muestra qué interrupción está siendo atendida en un momento dado. Si un bit está en 1, la línea correspondiente está en servicio. Este registro también es de solo lectura para la CPU y es gestionado por el PIC.</p></li>
</ul>
</div>
<div id="funcionamiento" class="section level4 hasAnchor" number="5.8.11.3">
<h4><span class="header-section-number">5.8.11.3</span> Funcionamiento<a href="módulo-de-entradasalida-e-interrupciones.html#funcionamiento" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Cuando una línea de interrupción se activa, el PIC la registra en el <code>IRR</code>. Si la línea no está enmascarada y no hay otra interrupción en servicio (es decir, si <code>ISR = 00h</code>), el PIC envía una señal de interrupción a la CPU activando la línea <code>INTR</code>.</p>
<p>El proceso de atención de la interrupción sigue estos pasos:</p>
<ol style="list-style-type: decimal">
<li>La CPU responde a la señal <code>INTR</code> enviando un pulso por la línea <code>INTA</code>.</li>
<li>Al recibir la señal, el PIC marca la línea como <em>in-service</em> en el registro <code>ISR</code> y la elimina del registro <code>IRR</code>.</li>
<li>El PIC envía a la CPU, a través del bus de datos, el número de interrupción correspondiente a la línea activa.</li>
<li>La CPU envía un segundo pulso por la línea <code>INTA</code>.</li>
<li>El PIC desactiva la línea <code>INTR</code>.</li>
</ol>
<p>Para finalizar la atención de la interrupción, la CPU escribe el byte EOI (End of Interrupt) en la dirección 20h de la memoria de E/S. Al recibir este byte, el PIC desmarca la línea como in-service en el registro ISR. Si hay interrupciones pendientes, el PIC reactiva la línea INTR y repite el proceso.</p>
<p>Este PIC no admite interrupciones anidadas. Si ocurre una nueva interrupción mientras otra está siendo atendida, la nueva solicitud se encola en el registro IRR y se procesará una vez que la interrupción en curso haya finalizado, sin importar su prioridad.</p>
</div>
<div id="prioridades" class="section level4 hasAnchor" number="5.8.11.4">
<h4><span class="header-section-number">5.8.11.4</span> Prioridades<a href="módulo-de-entradasalida-e-interrupciones.html#prioridades" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Cuando hay múltiples interrupciones pendientes, el PIC atiende primero la de mayor prioridad. La prioridad de cada línea está determinada por su número de interrupción: las líneas con números más bajos tienen mayor prioridad. Por ejemplo, la línea <code>INT0</code> tiene mayor prioridad que la línea <code>INT1</code>.</p>
</div>
<div id="ejemplo-de-uso-del-módulo-handshake-con-interrupciones" class="section level4 hasAnchor" number="5.8.11.5">
<h4><span class="header-section-number">5.8.11.5</span> Ejemplo de uso del módulo Handshake con interrupciones<a href="módulo-de-entradasalida-e-interrupciones.html#ejemplo-de-uso-del-módulo-handshake-con-interrupciones" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>A continuación, se presenta un ejemplo en ensamblador que utiliza el módulo Handshake junto con el PIC para imprimir la cadena “Hola” mediante interrupciones por hardware. En este ejemplo, se configura el PIC para que solo la línea <code>INT2</code> (asociada al módulo Handshake) esté habilitada, y se define una rutina de interrupción que se ejecuta automáticamente cuando la impresora está lista para recibir un nuevo carácter.</p>
<pre class="assembly"><code>; 
; PROGRAMA Impresión de string usando Handshake con interrupciones
; DESCRIPCIÓN Imprime el string &#39;Hola&#39; en la impresora utilizando el módulo
;              Handshake con interrupciones por hardware (INT2)
; 

; SECCIÓN DE DATOS 
mensaje     db &#39;Hola&#39;, 0    ; String a imprimir, terminado en carácter nulo
restantes   db 4           ; Contador de caracteres restantes por imprimir
puntero     db 0           ; Puntero al siguiente carácter (8 bits)

;  CONSTANTES DE HANDSHAKE 
HS_DATA     EQU 40h        ; Registro de datos del Handshake (puerto E-S)
HS_STATUS   EQU 41h        ; Registro de estado del Handshake (puerto E-S)

; CONSTANTES DE INTERRUPCIONES 
ID          EQU 2          ; ID de la interrupción para Handshake (0-7)
IMR         EQU 21h        ; Registro de máscara de interrupciones del PIC
EOI         EQU 20h        ; Puerto para enviar End Of Interrupt al PIC
INT2        EQU 26h        ; Puerto para configurar la línea INT2

; PROGRAMA PRINCIPAL



;  1) CONFIGURACIÓN INICIAL 
cli                        ; Deshabilitar interrupciones globales

;  2) CONFIGURACIÓN DEL HANDSHAKE
; Habilitar interrupciones del Handshake (bit 7 = 1)
in  al, HS_STATUS         ; Leer estado actual del Handshake
or  al, 10000000b         ; Activar bit 7 (habilitar interrupciones)
out HS_STATUS, al         ; Escribir configuración al Handshake

;  3) CONFIGURACIÓN DEL PIC (Controlador de Interrupciones)

; 3.1) Configurar máscara de interrupciones - Solo habilitar INT2
mov al, 11111011b         ; Máscara: habilita solo INT2 (bit 2=0), resto deshabilitado
out IMR, al               ; Aplicar máscara al PIC

; 3.2) Asignar ID de interrupción a la línea INT2
mov al, ID                ; Cargar ID de interrupción (2)
out INT2, al              ; Configurar línea INT2 con este ID

; 3.3) Configurar vector de interrupción en memoria
mov bl, ID                ; BL = posición en tabla de vectores (ID=2)
mov [bl], int2_handler    ; Almacenar dirección de rutina en vector[2]

;  4) INICIALIZACIÓN DE VARIABLES 
mov al, offset mensaje    ; AL = dirección del primer carácter del string
mov puntero, al           ; Guardar en variable puntero

;  5) ENVIAR PRIMER CARÁCTER PARA INICIAR EL PROCESO 
; Esperar que la impresora esté lista
esperar_listo:
  in al, HS_STATUS
  and al, 00000001b     ; Verificar bit busy
  jnz esperar_listo     ; Si busy=1, esperar

; Enviar primer carácter
mov bl, puntero           ; Cargar puntero
mov al, [bl]              ; Obtener primer carácter
cmp al, 0                 ; Es string vacío
jz fin                    ; Si está vacío, terminar

out HS_DATA, al           ; Enviar primer carácter
inc bl                    ; Avanzar puntero
mov puntero, bl           ; Guardar puntero actualizado
dec restantes             ; Decrementar contador

;  6) HABILITAR INTERRUPCIONES Y ESPERAR 
sti                       ; Habilitar interrupciones globales

;  7) BUCLE DE ESPERA
; El programa principal espera hasta que se impriman todos los caracteres
bucle_espera:
  cmp restantes, 0      ; Quedan caracteres por imprimir
  jnz bucle_espera      ; Si quedan, seguir esperando

;  8) FINALIZACIÓN 
fin:
hlt                       ; Detener ejecución del programa


; RUTINA DE INTERRUPCIÓN INT2 - HANDSHAKE
; DESCRIPCIÓN Se ejecuta automáticamente cuando la impresora está lista
;              para recibir un nuevo carácter (busy = 0)
; ENTRADA Variable puntero = dirección del siguiente carácter a imprimir
; SALIDA Carácter enviado a la impresora, puntero actualizado

org 80h
int2_handler:
  ;  PRESERVAR CONTEXTO 
  push al               ; Guardar registros que se van a modificar
  push bl

  ;  VERIFICAR SI HAY MÁS CARACTERES 
  cmp restantes, 0      ; Quedan caracteres por imprimir
  jz fin_interrupcion   ; Si no quedan, terminar

  ;  OBTENER SIGUIENTE CARÁCTER 
  mov bl, puntero       ; BL = puntero al siguiente carácter
  mov al, [bl]          ; AL = carácter apuntado por BL
  cmp al, 0             ; Es el carácter nulo (fin de string)
  jz fin_interrupcion   ; Si es 0, terminar

  ;  ENVIAR CARÁCTER A LA IMPRESORA 
  out HS_DATA, al       ; Escribir carácter al registro de datos del Handshake

  ;  ACTUALIZAR PUNTEROS Y CONTADORES 
  inc bl                ; Avanzar al siguiente carácter
  mov puntero, bl       ; Guardar puntero actualizado
  dec restantes         ; Decrementar contador de caracteres restantes

fin_interrupcion:
  ; - ENVIAR EOI AL PIC 
  mov al, 20h           ; Señal de fin de interrupción
  out EOI, al           ; Notificar al PIC

  ;  RESTAURAR CONTEXTO 
  pop bl                ; Restaurar registros preservados
  pop al

  ;  RETORNO DE INTERRUPCIÓN 
  iret                  ; Retorno de interrupción</code></pre>
</div>
<div id="tecla-f10" class="section level4 hasAnchor" number="5.8.11.6">
<h4><span class="header-section-number">5.8.11.6</span> Tecla F10<a href="módulo-de-entradasalida-e-interrupciones.html#tecla-f10" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>La tecla F10 es un dispositivo que habilita una forma rápida y práctica de ejecutar una interrupción por hardware. Está conectada a la línea <code>INT0</code> del [PIC]. Puede accionarse presionando la tecla F10 el teclado físicamente o haciendo clic en el “botón rojo de interrupción” en la interfaz gráfica.</p>
<pre class="assembly"><code>; Programa Contador de pulsaciones de la tecla F10 usando interrupciones

; 1) Definiciones y variables

cantidad db 0          ; Variable almacena la cantidad de veces que se presionó F10

ID   EQU 1             ; ID de la interrupción para F10 (puede ser 0-7)
IMR  EQU 21h           ; Dirección del registro IMR (máscara de interrupciones)
EOI  EQU 20h           ; Dirección para enviar End Of Interrupt al PIC
INT0 EQU 24h           ; Dirección para configurar la línea INT0 (F10)

; 2) Inicialización del PIC y vector de interrupción

; 2.1) Habilitar solo la interrupción de F10 (INT0)
mov al, 11111110b      ; Habilita solo INT0 (bit 0 en 0), el resto deshabilitado
out IMR, al

; 2.2) Configurar el ID de la interrupción para INT0
mov al, ID             ; Cargar el ID elegido para F10
out INT0, al

; 2.3) Asociar el vector de interrupción con la subrutina atenderf10
mov bl, ID             ; BL = ID de la interrupción
mov [bl], atenderf10   ; Vector de interrupción dirección de la rutina

; 3) Bucle principal (espera activa)

loop: jmp loop         ; Espera indefinida (el programa queda esperando interrupciones)

hlt                    ; (Opcional) Detiene la CPU si sale del bucle

; 4) Rutina de atención de la interrupción F10

org 50h                ; Dirección de la subrutina de atención

atenderf10:
  inc cantidad       ; Incrementa el contador cada vez que se presiona F10
  mov al, 20h        ; Código de End Of Interrupt (EOI)
  out EOI, al        ; Notifica al PIC que terminó la atención
  iret               ; Retorna de la interrupción</code></pre>
</div>
</div>
<div id="módulo-timer" class="section level3 hasAnchor" number="5.8.12">
<h3><span class="header-section-number">5.8.12</span> Módulo timer<a href="módulo-de-entradasalida-e-interrupciones.html#módulo-timer" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>El timer es un módulo que dispone de dos registros internos:</p>
<ul>
<li>Registro <code>CONT</code>: ubicado en la dirección <code>10h</code> de la memoria E/S.</li>
<li>Registro <code>COMP</code>: ubicado en la dirección <code>11h</code> de la memoria E/S.</li>
</ul>
<p>Este módulo está basado en el PIT 8253 de Intel, aunque se han realizado modificaciones para simplificar su funcionamiento. El registro <code>COMP</code> permite establecer el valor de comparación con <code>CONT</code>. Si se escribe un valor de <code>0</code> en <code>COMP</code>, el timer se desactiva y no genera interrupciones. Cualquier otro valor habilita el timer y permite su funcionamiento normal.</p>
<p>El reloj es un dispositivo que hace tic cada segundo. Al hacer tic, incrementa el registro <code>CONT</code> del [<em>timer</em>] en uno.</p>
<pre class="assembly"><code>; Programa Imprime &#39;Hola&#39; a los 10 segundos de iniciado y luego termina.
; Utiliza la interrupción del TIMER (ID = 5).

mensaje db &#39;Hola&#39;        ; Mensaje a imprimir
imprimio db 0            ; Flag para saber si ya imprimió

; Definición de direcciones de registros de dispositivos
CONT equ 10h             ; Registro de conteo del timer
COMP equ 11h             ; Registro de comparación del timer

EOI  equ 20h             ; End Of Interrupt (para PIC)
IMR  equ 21h             ; Interrupt Mask Register (PIC)
INT1 equ 25h             ; Registro de vector de interrupción 1

;  Habilitar interrupciones del timer 
; IMR = 1111 1101b (solo habilita interrupciones del timer y teclado)
mov al, 11111101b        ; Habilita interrupciones del timer (bit 1 en 0)
out IMR, al

; Configurar vector de interrupción del timer 
mov al, 5                ; ID de interrupción del timer
out INT1, al             ; Asigna rutina de atención a la posición 5

;  Instalar rutina de interrupción en el vector 
mov bl, 5                ; Vector de interrupción 5
mov [bl], imp_msj        ; Apunta a la rutina imp_msj

;  Configurar timer para 3 segundos 
mov al, 10                ; Valor de comparación (10 segundos)
out COMP, al

mov al, 0                ; Reinicia el contador del timer
out CONT, al

;  Esperar a que se imprima el mensaje 
loopinf: cmp imprimio, 0 ; Ya imprimió
       jz loopinf      ; Si no, sigue esperando

hlt                      ; Termina el programa

;  Rutina de interrupción del timer 
org 50h
imp_msj:
       mov bl, offset mensaje ; Dirección del mensaje
       mov al, 4             ; Servicio de impresión
       int 7                 ; Llama a la interrupción de impresión
       mov imprimio, 1       ; Marca que ya imprimió
       mov al, 20h           ; Señal de fin de interrupción
       out EOI, al           ; Notifica al PIC
       iret                  ; Retorna de la interrupción</code></pre>
</div>
</div>
<h3> Bibliografía<a href="Biblio.html#Biblio" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-intel8086manual" class="csl-entry">
Intel Corporation. 1979. <em>Intel 8086 Family User’s Manual</em>. Intel Corporation. <a href="https://bitsavers.org/components/intel/8086/9800722-03_The_8086_Family_Users_Manual_Oct79.pdf">https://bitsavers.org/components/intel/8086/9800722-03_The_8086_Family_Users_Manual_Oct79.pdf</a>.
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="ciclo-de-la-instrucción.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="validación-pedagógica-del-simulador.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
  "sharing": {
    "github": "https://github.com/ruiz-jose/Sim-x86-Tesis",
    "facebook": false,
    "twitter": false,
    "linkedin": false,
    "weibo": false,
    "instapaper": false,
    "vk": false,
    "whatsapp": false,
    "all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
  },
  "fontsettings": {
    "theme": "white",
    "family": "sans",
    "size": 2
  },
  "edit": {
    "link": "https://github.com/ruiz-jose/Sim-x86-Tesis/edit/main/05-desarrollo.Rmd",
    "text": "Edit"
  },
  "history": {
    "link": null,
    "text": null
  },
  "view": {
    "link": "https://github.com/ruiz-jose/Sim-x86-Tesis/blob/main/05-desarrollo.Rmd",
    "text": null
  },
  "download": ["tesis.pdf"],
  "search": {
    "engine": "fuse",
    "options": null
  },
  "toc": {
    "collapse": "subsection"
  }
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
