# Arquitectura de computadoras {#arquitectura}
Este capítulo aborda los conceptos fundamentales de la arquitectura de computadoras, incluyendo las filosofías de diseño CISC y RISC, la evolución de la arquitectura x86 y una introducción al lenguaje ensamblador. Estos temas constituyen la base necesaria para comprender el funcionamiento interno de los sistemas informáticos.

## Introducción a la arquitectura de computadoras
La arquitectura de computadoras es una disciplina central en el campo de la informática que estudia el diseño, la organización y la interacción entre los componentes de un sistema computacional. Esta área abarca tanto aspectos de hardware como de software que interactúan directamente con él, proporcionando principios fundamentales para construir sistemas eficientes, robustos y adaptables. Comprender su funcionamiento resulta esencial para analizar cómo se implementan, optimizan y escalan los sistemas informáticos en diversos contextos tecnológicos [@stallings_computer_2021; @tanenbaum_structured_2016; @murdocca_principles_2000; @bryant2015computer].

Uno de los conceptos clave en esta disciplina es la distinción entre **arquitectura de computadoras** y **organización de computadoras**. La arquitectura se refiere a los elementos visibles para el programador, como el conjunto de instrucciones, los registros y los modos de direccionamiento. La organización, en cambio, se enfoca en los detalles físicos de implementación, tales como el diseño de circuitos y los ciclos de reloj necesarios para cada operación [@stallings_computer_2021; @tanenbaum_structured_2016; @murdocca_principles_2000; @hennessy2017computer; @bryant2015computer].

Distinguir esta diferencia es crucial para analizar cómo los diseños arquitectónicos han evolucionado en respuesta a las crecientes demandas de rendimiento, eficiencia energética y escalabilidad. En este sentido, arquitecturas como ARM y RISC-V se han consolidado en sistemas embebidos y dispositivos móviles debido a su simplicidad estructural y bajo consumo energético [@waterman_risc-v_2014; @harris2015digital; @null_essentials_2014]. En contraste, la arquitectura x86 ha adoptado un enfoque híbrido que combina características de CISC y RISC, permitiéndole adaptarse a los exigentes requerimientos del mercado [@bryant2015computer; @stallings_computer_2021; @patterson_computer_2014].

El análisis de una arquitectura de computadoras implica examinar múltiples dimensiones técnicas que inciden en su desempeño y aplicabilidad. Entre las más relevantes se encuentran:

- **Repertorio de instrucciones**: conjunto de operaciones que el procesador puede ejecutar directamente.
- **Capacidad de procesamiento**: determinada por el número de bits con los que opera la CPU (por ejemplo, 32 o 64 bits).
- **Modos de direccionamiento de memoria**: mecanismos mediante los cuales una instrucción accede a posiciones de memoria, como el direccionamiento directo, indirecto, segmentado o lineal.
- **Jerarquía de memoria y mecanismos de entrada/salida**: estructuras que influyen en la eficiencia del acceso a datos y en la interacción con dispositivos periféricos.
- **Grado de paralelismo**: capacidad de ejecutar múltiples instrucciones o tareas simultáneamente, ya sea a nivel de instrucción (ILP) o de procesos (TLP).

Estos dimensiones técnicas adquieren especial relevancia en sistemas contemporáneos aplicados a inteligencia artificial, internet de las cosas (IoT), computación en la nube y ciberseguridad, donde el equilibrio entre rendimiento, consumo energético y escalabilidad resulta determinante [@patterson_computer_2016; @harris2015digital; @belli2020iot].

Un componente esencial en el estudio de esta disciplina es la **arquitectura del conjunto de instrucciones (ISA, por sus siglas en inglés)**, que define la interfaz entre el hardware y el software [@hennessy2017computer]. La ISA especifica las operaciones disponibles, la codificación de las instrucciones y las formas de manipular los datos. Esta interfaz es fundamental para el diseño de compiladores, sistemas operativos y herramientas de simulación, ya que permite abstraer el funcionamiento del hardware a nivel lógico y facilita la portabilidad del software.

El diseño arquitectónico implica tomar decisiones que suponen compromisos (*trade-offs*), tales como la complejidad del hardware frente al rendimiento, o la eficiencia energética frente a la flexibilidad funcional. Estas decisiones determinan la aplicabilidad de una arquitectura en distintos dominios tecnológicos. Por ejemplo:

- La arquitectura **x86** resulta adecuada para entornos que requieren alto rendimiento y compatibilidad con software legado.
- La arquitectura **ARM** se prefiere en dispositivos móviles debido a su bajo consumo energético [@patterson_computer_2016; @harris2015digital; @belli2020iot].
- **RISC-V**, por su parte, destaca por su apertura, modularidad y flexibilidad, lo que la convierte en una alternativa atractiva para investigación, docencia y aplicaciones personalizadas [@patterson_computer_2017; @waterman_risc-v_2014].

En síntesis, el estudio de la arquitectura de computadoras permite comprender el funcionamiento interno de los sistemas, optimizar el desarrollo de soluciones tecnológicas complejas y fomentar la innovación en ingeniería de sistemas. Su enseñanza resulta fundamental en la formación en ciencias de la computación y disciplinas afines.

Desde una perspectiva educativa, el uso de herramientas de simulación contribuye a una comprensión progresiva de los conceptos arquitectónicos, al permitir experimentar con distintas arquitecturas y observar de forma interactiva el comportamiento del hardware [@akram2019survey; @menchonherramientas]. Esta dimensión didáctica adquiere especial importancia en el desarrollo de la herramienta propuesta en esta tesis, centrada en la arquitectura x86. Dicha arquitectura, ampliamente difundida en contextos académicos e industriales, también presenta desafíos significativos desde el punto de vista pedagógico, debido a su complejidad estructural y diversidad funcional.

## Arquitecturas Von Neumann y Harvard
Comprender las arquitecturas modernas requiere el análisis de dos modelos conceptuales fundamentales que sentaron las bases del diseño actual de sistemas computacionales: Von Neumann y Harvard. Estos modelos arquitectónicos no solo constituyen la base teórica de muchas arquitecturas contemporáneas, sino que también permiten identificar sus fortalezas, limitaciones y áreas de aplicación.

### Arquitectura Von Neumann
La arquitectura Von Neumann, formalizada por John von Neumann en 1945 en su influyente documento "First Draft of a Report on the EDVAC" [@vonneumann1945first], establece un modelo computacional en el cual tanto los datos como las instrucciones residen en una única memoria y comparten un mismo bus de comunicación. Esta arquitectura se caracteriza por sus cuatro componentes fundamentales: la unidad central de procesamiento (CPU), la unidad de control, la memoria y los dispositivos de entrada/salida. La unificación del espacio de memoria facilita el diseño del sistema y la programación, sin embargo, esta unificación también origina una limitación conocida como el ‘cuello de botella de Von Neumann’, que se refiere a la imposibilidad de acceder simultáneamente a datos e instrucciones debido al uso compartido del mismo bus, lo cual reduce la eficiencia del procesamiento, particularmente en aplicaciones con uso intensivo de datos [@hennessy2017computer; @stallings_computer_2021].

```{r vonneumann, echo=FALSE, fig.cap="Arquitectura Von Neumann", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/vonneumann.png")
```

### Arquitectura Harvard
Mientras la arquitectura Von Neumann se convertía en el paradigma dominante, paralelamente se desarrollaba un enfoque alternativo. La arquitectura Harvard tiene su origen en el diseño del Harvard Mark I, una computadora electromecánica desarrollada entre 1939 y 1944 durante la Segunda Guerra Mundial en la Universidad de Harvard bajo la dirección de Howard Aiken y con el apoyo de IBM [@ceruzzi_history_2003; @williams1998history]. El Harvard Mark I sentó las bases para un modelo arquitectónico diferente al de Von Neumann, caracterizado por una separación física entre instrucciones y datos.En este modelo, los datos y las instrucciones residen en memorias físicamente separadas, accedidas a través de buses independientes, lo cual mejora la eficiencia del procesamiento al eliminar la competencia por el bus entre instrucciones y datos. Esta organización evita el cuello de botella característico de Von Neumann y permite un acceso paralelo que incrementa el rendimiento en escenarios críticos para la eficiencia. A continuación, se presenta una comparación sistemática entre ambos modelos, a fin de comprender mejor sus implicancias técnicas y contextos de aplicación [@tanenbaum_structured_2016]. Debido a su eficiencia, esta arquitectura se ha adoptado ampliamente en sistemas embebidos, microcontroladores y procesadores de señal digital (DSP) [@noergaard2012embedded].

```{r harvard, echo=FALSE, fig.cap="Arquitectura Harvard", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/harvard.png")
```

### Comparativa entre Von Neumann y Harvard
Como señalan Stallings [@stallings_computer_2021] y Hennessy [@hennessy2017computer], la arquitectura Von Neumann continúa siendo una alternativa predominante cuando se priorizan la simplicidad del diseño, la flexibilidad en la asignación de memoria y la compatibilidad con software de propósito general, como ocurre en muchas computadoras personales y servidores contemporáneos. En cambio, la arquitectura Harvard ha demostrado ventajas significativas en aplicaciones que demandan procesamiento en tiempo real y eficiencia energética, como dispositivos móviles, microcontroladores y entornos de control industrial. La elección entre ambas arquitecturas responde, en última instancia, a requerimientos específicos del sistema, ya sea por su complejidad, restricciones energéticas o necesidades de rendimiento paralelo.

Para una comparación más sistemática, se pueden establecer criterios como tipo de memoria, estructura de buses, capacidad de acceso paralelo, casos de uso representativos, ventajas y limitaciones.

```{r, echo=FALSE, out.width = "100%", fig.cap="Comparación entre arquitecturas Von Neumann y Harvard"}
library(knitr)
library(kableExtra)

# Crear la tabla de datos
tabla <- data.frame(
  Característica = c("Memoria", "Buses", "Acceso simultáneo", "Ejemplo típico", "Ventaja principal", "Limitación principal"),
  "Von Neumann" = c("Única para datos e instrucciones", "Bus compartido", "No", "Intel x86", "Diseño más simple", "Cuello de botella"),
  "Harvard" = c("Separada para datos e instrucciones", "Buses independientes", "Sí", "AVR, PIC", "Mayor rendimiento", "Diseño más complejo")
)

# Generar la tabla con formato LaTeX o HTML según el tipo de salida
kable(tabla, format = ifelse(knitr::is_latex_output(), "latex", "html"),
      caption = "Cuadro comparativo entre arquitecturas Von Neumann y Harvard",
      booktabs = TRUE, escape = FALSE) %>%
  kable_styling(
    latex_options = c("scale_down", "hold_position"), # Escala la tabla para ajustarla al ancho de la página
    full_width = FALSE, # Evita que la tabla ocupe todo el ancho
    position = "center" # Centra la tabla
  ) %>%
  column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>% # Ajusta el ancho de la primera columna
  column_spec(2, width = "5cm") %>% # Ajusta el ancho de la segunda columna
  column_spec(3, width = "5cm") %>% # Ajusta el ancho de la tercera columna
  row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") # Aplica estilo a la fila de encabezado
```

Ambos modelos conceptuales han tenido una influencia decisiva en el diseño de arquitecturas contemporáneas. Mientras que el modelo Von Neumann ofrece un enfoque unificado que simplifica el desarrollo de software y hardware, la arquitectura Harvard destaca por su capacidad para mejorar el rendimiento mediante el acceso paralelo a instrucciones y datos. Esta distinción resulta crucial al analizar el diseño de arquitecturas modernas como x86, que constituye el foco de esta tesis. Comprender las implicancias de estas decisiones arquitectónicas es esencial para evaluar el impacto en el rendimiento, la eficiencia energética y la escalabilidad de los sistemas actuales.

El contraste entre estos dos modelos ha dado lugar a enfoques intermedios que buscan capitalizar las ventajas de ambos. Como resultado de esta evolución, emergen las denominadas arquitecturas híbridas, las cuales integran características de ambos modelos para optimizar el rendimiento y la flexibilidad del sistema.

### Arquitecturas híbridas
Muchas arquitecturas contemporáneas implementan un enfoque híbrido, también conocido como arquitectura Harvard modificada. Este modelo emplea memorias separadas para datos e instrucciones a nivel microarquitectónico a menudo mediante la utilización de memorias caché de nivel 1 (L1) separadas para instrucciones y datos. No obstante, desde la perspectiva del programador, el modelo de memoria se mantiene unificado, facilitando el desarrollo de software sin exponer la complejidad del diseño interno. Esta dualidad permite optimizar la implementación física del procesador sin complicar el modelo de programación [@hennessy2017computer; @null_essentials_2014; @patterson_computer_2017; @stallings_computer_2021].


```{r hibrida, echo=FALSE, fig.cap="Arquitectura Híbridas", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/hibrida.png")
```

Esta aproximación híbrida se implementa en arquitecturas modernas como ARM Cortex y los procesadores Intel Core, los cuales incorporan cachés separadas para instrucciones y datos con el objetivo de optimizar el rendimiento del pipeline, lo que facilita una mayor paralelización del procesamiento y reduce los conflictos en el acceso a memoria. A pesar de que el modelo de memoria visible para el programador se presenta como unificado, a nivel interno se implementan mecanismos característicos de la arquitectura Harvard, como el uso de memorias caché separadas para instrucciones y datos [@arm2021architecture; @intel_microarchitecture_2021].

La adopción de arquitecturas híbridas, como la Harvard modificada, ha permitido a los diseñadores combinar la flexibilidad del modelo Von Neumann con la eficiencia del modelo Harvard. Esta convergencia no solo optimiza el rendimiento de los sistemas, sino que también responde a las exigencias contemporáneas en términos de consumo energético y capacidad de procesamiento paralelo. En este sentido, la distinción entre ambos modelos continúa siendo un eje conceptual clave para comprender la evolución de las arquitecturas modernas y su adaptación a diferentes escenarios tecnológicos.

En síntesis, la comprensión de las arquitecturas fundamentales —Von Neumann, Harvard e híbridas— resulta esencial para el desarrollo de herramientas de simulación efectivas en la enseñanza de arquitectura de computadoras. Los conceptos explorados en esta sección proporcionan los fundamentos conceptuales esenciales para el diseño y desarrollo de la herramienta de simulación propuesta en esta tesis.

## Tipos de arquitecturas
El análisis de diversas arquitecturas de computadoras, y particularmente de sus repertorios de instrucciones (Instruction Set Architecture, ISA), es esencial para comprender sus ventajas, limitaciones y áreas de aplicación. Esta evaluación comparativa permite a los diseñadores y educadores seleccionar la ISA más adecuada para sus necesidades, considerando factores como la eficiencia energética, la complejidad del hardware, la compatibilidad y el soporte educativo.

Aunque arquitecturas como PowerPC, SPARC o MIPS desempeñaron un papel central en la evolución de la computación, su adopción ha disminuido significativamente en contextos industriales y académicos, debido al desplazamiento por plataformas con mayor soporte comercial y vigencia tecnológica [@stallings_computer_2021]. Su menor vigencia actual responde al surgimiento de arquitecturas más eficientes y con mejor respaldo comercial, como x86, ARM y RISC-V, que han captado la atención tanto del mercado como del ámbito educativo [@hennessy2017computer; @waterman_risc-v_2014; @null_essentials_2014; @arm_evolution_2025]. Por ello, esta sección se enfoca en aquellas arquitecturas que mantienen relevancia comercial o presentan un valor pedagógico significativo en el desarrollo de simuladores educativos.

### Arquitectura x86
La arquitectura x86, desarrollada inicialmente por Intel, ha dominado el mercado de computadoras de escritorio y servidores durante décadas, gracias a su evolución constante y soporte del ecosistema de software [@hennessy2017computer]. Su conjunto de instrucciones (ISA, por sus siglas en inglés Instruction Set Architecture) incluye una amplia gama de operaciones, lo que otorga flexibilidad, aunque complica el diseño del hardware. Este equilibrio entre compatibilidad y rendimiento hace que x86 sea una opción preferida para entornos donde la capacidad de procesamiento es prioritaria, como en servidores y estaciones de trabajo [@hennessy2017computer; @intel_whitepaper_2023].

### Arquitectura ARM
Reconocida por su alta eficiencia energética, la arquitectura ARM es la columna vertebral de dispositivos móviles y sistemas embebidos. Basada en el paradigma de conjunto de instrucciones reducidas (RISC), ARM simplifica el diseño del hardware y optimiza el consumo energético, características que la posicionan como una opción preferente para aplicaciones como smartphones y tablets. Aunque su rendimiento máximo en tareas de cómputo intensivo suele ser inferior al de x86, su equilibrio entre eficiencia energética y capacidad computacional resulta decisivo en mercados donde la autonomía y la disipación térmica son factores críticos, como los dispositivos móviles y el IoT [@patterson_computer_2014; @arm_evolution_2025].

### Arquitectura RISC-V
Como arquitectura de código abierto, RISC-V ofrece una alternativa personalizable a los modelos propietarios, destacándose en entornos académicos y de desarrollo especializado. Su ISA flexible permite a los desarrolladores personalizar sistemas según necesidades específicas, haciéndola especialmente atractiva para investigación, educación y aplicaciones embebidas. Basada en principios RISC, RISC-V combina eficiencia energética con un diseño de hardware simplificado, y su creciente ecosistema la posiciona como una fuerte competidora frente a arquitecturas establecidas como ARM. No obstante, RISC-V enfrenta desafíos para su adopción masiva, en parte debido a la falta de estándares unificados, la fragmentación de su ecosistema y la limitada presencia de proveedores comerciales consolidados, lo que dificulta su despliegue en entornos productivos críticos.[@hennessy2017computer; @waterman_risc-v_2014;  @harris2015digital; @patterson2016computer].

### Comparativa entre arquitecturas
Las características distintivas de cada arquitectura condicionan su idoneidad para diversas aplicaciones. Por ejemplo, mientras x86 sobresale en entornos de alto rendimiento, ARM domina en dispositivos móviles gracias a su eficiencia energética. Por su parte, arquitecturas como RISC-V han encontrado aplicaciones relevantes en sistemas embebidos, plataformas educativas y diseños personalizados, aunque su presencia comercial difiere notablemente. La selección adecuada de una arquitectura impacta significativamente en el éxito de un proyecto, desde el diseño hasta su implementación final. Además, comprender las diferencias entre estas arquitecturas, en particular sus repertorios de instrucciones y principios de diseño, resulta fundamental en el ámbito educativo, dado que facilita el desarrollo de herramientas didácticas que simulan sus principios operativos y ayudan a los estudiantes a visualizar el funcionamiento real de los sistemas computacionales [@patterson_computer_2014; @arm_evolution_2025].

```{r comparq, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

comparq <- data.frame(
  Característica = c(
    "Eficiencia Energética",
    "Complejidad ISA",
    "Rendimiento",
    "Áreas de Aplicación"
  ), # nolint: line_length_linter.
  x86 = c("Moderada", "Alta", "Alto",
          "Escritorio, servidores"),
  ARM = c("Alta", "Baja", "Moderado", "Dispositivos móviles"),
  `RISC-V` = c("Alta", "Baja", "Moderado", "Investigación, embebidos")
)

# Crear la tabla con formato dinámico
tabla <- kable(comparq,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Comparación de Arquitecturas",
               col.names = c("Característica", "x86", "ARM", "RISC-V"), # nolint: line_length_linter.
               booktabs = TRUE,
               escape = FALSE)

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(comparq)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.

} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "20em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "15em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

En el contexto de la enseñanza de arquitectura de computadoras, estas arquitecturas permiten abordar distintos niveles de complejidad y estilos de diseño, lo que resulta clave para la construcción de simuladores educativos efectivos.

## Repertorio de instrucciones
El repertorio de instrucciones, o Instruction Set Architecture (ISA), es el conjunto de operaciones que un procesador puede ejecutar, incluyendo su representación binaria y el conjunto de reglas que definen la interacción entre el software y el hardware. El ISA define la interfaz entre el hardware y el software, abarcando instrucciones aritméticas, lógicas, de control y de manipulación de datos, así como los modos de direccionamiento y los formatos de instrucción. Por su influencia directa en el rendimiento, la eficiencia energética y la versatilidad del sistema, el ISA constituye un componente esencial en el diseño de arquitecturas de computadoras [@hennessy2017computer; @null_essentials_2014; @stallings_computer_2021].

### Características clave del ISA
Entre las características fundamentales a considerar en el diseño de un repertorio de instrucciones se encuentran las siguientes [@hennessy2017computer]:

  - **Tipos de operandos**: representan los datos que las instrucciones pueden manipular, como enteros, números en punto flotante, caracteres y direcciones de memoria. Un ISA eficiente debe soportar una amplia variedad de operandos para maximizar su versatilidad.
  - **Tipos de operaciones**: incluyen las operaciones que el procesador puede realizar, como aritméticas (suma, resta), lógicas (AND, OR), de control (saltos, llamadas a subrutinas) y de manipulación de datos (almacenamiento, carga). Diversos autores destacan que un ISA bien diseñado debe lograr un equilibrio entre funcionalidad, simplicidad y eficiencia de implementación, aspectos fundamentales en el diseño de arquitecturas modernas [@hennessy2017computer; @null_essentials_2014].
  - **Modos de direccionamiento**: determinan cómo se especifican los operandos en las instrucciones. Entre los modos más comunes se encuentran el inmediato, directo, indirecto, mediante registros, con desplazamiento y basado en pila. Cada uno ofrece distintos niveles de eficiencia, flexibilidad y complejidad, siendo fundamentales para optimizar el acceso a datos y la ejecución de instrucciones.
  - **Formato de las instrucciones**: que definen las reglas para acceder a los operandos dentro de las instrucciones, se exploran con mayor detalle en la siguiente subsección.

```{r repInstCaracteristicas, echo=FALSE, fig.cap="Características repertorio de instrucciones", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/isa.png")
```

El diseño de un repertorio de instrucciones eficiente y versátil es un desafío complejo que requiere un equilibrio entre funcionalidad, rendimiento y facilidad de uso. La selección adecuada de operandos, operaciones y modos de direccionamiento, junto con un formato de instrucción bien estructurado, son aspectos fundamentales para lograr una arquitectura de computadoras efectiva y adaptable a diversas aplicaciones. Estas características no solo definen las capacidades funcionales de un procesador, sino que también condicionan la manera en que las instrucciones interactúan con la memoria y los registros. A continuación, se profundiza en los modos de direccionamiento, uno de los elementos que más influye en la flexibilidad y eficiencia del repertorio de instrucciones.

### Modos de direccionamiento
Los modos de direccionamiento definen los mecanismos mediante los cuales una instrucción especifica la ubicación de sus operandos, permitiendo así al procesador acceder a los datos en memoria o registros en tiempo de ejecución. A continuación, se describen los modos de direccionamiento más comúnmente implementados en las arquitecturas modernas [@stallings_computer_2021; @hennessy2017computer]:

  a) **Inmediato**: el operando está directamente incluido en la instrucción, permitiendo acceso rápido a valores constantes. Es eficiente para operaciones simples, aunque limitado a operandos pequeños.
  b) **Directo**: la instrucción contiene la dirección de memoria del operando. Es fácil de usar, pero está restringido por el rango de direcciones accesibles.
  c) **Indirecto**: la instrucción apunta a una dirección que contiene la ubicación real del operando, lo que amplía el rango de direcciones a costa de un acceso adicional a memoria.
  d) **Registro**: el operando se encuentra en un registro del procesador, proporcionando acceso extremadamente rápido, pero limitado por la cantidad de registros disponibles.
  e) **Registro Indirecto**: similar al modo indirecto, pero la dirección efectiva se obtiene a partir del contenido de un registro, lo que ofrece un buen equilibrio entre velocidad de acceso y capacidad de direccionamiento.
  f) **Con Desplazamiento**: combina una dirección base con un valor de desplazamiento, ideal para estructuras como arrays y matrices.
  g) **Pila**: el operando está en la parte superior de la pila, útil para gestionar subrutinas y el paso de parámetros.

Para complementar la descripción anterior, la Figura \@ref(fig:ModDir) presenta una representación esquemática de los modos de direccionamiento, mostrando gráficamente cómo se calcula la dirección efectiva (EA) en cada caso [@stallings_computer_2021].

```{r ModDir, echo=FALSE, fig.cap="Modos de direccionamiento ", fig.align = 'center', out.width="60%"}
knitr::include_graphics(path = "images/modosdireccionamiento.png")
```

  - A = contenido de un campo de dirección en la instrucción
  - R = contenido de un campo de dirección en la instrucción que referencia a un registro
  - EA = dirección real (efectiva) de la posición que contiene el operando que se referencia

La tabla \@ref(tab:tabmoddir) detalla el cálculo de la dirección para cada modo de direccionamiento.

```{r tabmoddir, echo=FALSE, message=FALSE, warning=FALSE, table.pos='htbp'}
library(knitr)
library(kableExtra)
library(magrittr)

# Crear los datos de la tabla
tabmoddir <- data.frame(
  `Modo` = c("Inmediato", "Directo", "Indirecto", "Registro",
             "Indirecto con registro", "Con desplazamiento", "Pila"),
  `Algoritmo` = c("Operando \u2190 A", "EA \u2190 A", "EA \u2190 (A)",
                  "EA \u2190 R", "EA \u2190 (R)", "EA \u2190 A + (R)",
                  "EA \u2190 puntero de pila"),
  `Ventaja` = c("No referencia a memoria",
                "Es sencillo", "Espacio de direcciones grande",
                "No referencia a memoria",
                "Espacio de direcciones grande",
                "Flexibilidad",
                "No referencia a memoria"),
  `Desventaja` = c(
    "Operando de magnitud limitada",
    "Espacio de direcciones limitado",
    "Referencias múltiples a memoria",
    "Número limitado de registros",
    "Referencia extra a memoria",
    "Complejidad",
    "Aplicabilidad limitada"
  )
)

# Crear la tabla con formato dinámico
tabla_moddir <- kable(tabmoddir,
                      format = ifelse(knitr::is_latex_output(), "latex", "html"), # nolint
                      caption = "Modos de direccionamiento básicos",
                      col.names = c("Modo", "Algoritmo", "Ventaja", "Desventaja"), # nolint: line_length_linter.
                      booktabs = TRUE,
                      escape = FALSE)

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  tabla_moddir %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tabmoddir)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.

} else {
  tabla_moddir %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "20em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

### Formato de las instrucciones
El formato de las instrucciones especifica la disposición y codificación de los elementos que conforman una instrucción, como el código de operación (opcode), los operandos, los modos de direccionamiento y otros campos auxiliares. Esta organización impacta directamente en la facilidad de decodificación y en el rendimiento del procesador. Este formato afecta la rapidez de decodificación y la eficiencia general del procesador [@hennessy2017computer; @tanenbaum_structured_2016]:

- **Longitud de la instrucción**: puede ser fija o variable. Las instrucciones de longitud fija permiten una decodificación más rápida y simplifican la lógica de control del procesador. En cambio, las instrucciones de longitud variable permiten una codificación más eficiente del espacio de memoria, a costa de una mayor complejidad en la etapa de decodificación.
- **Cantidad de operandos**: las instrucciones pueden trabajar con diferentes números de operandos (de 0 a 3 o más). Una mayor cantidad de operandos incrementa la expresividad de las instrucciones, pero también puede derivar en una mayor complejidad de codificación y en un mayor uso de recursos del procesador.
- **Campos de instrucción**: incluyen el opcode y campos adicionales como operandos, modos de direccionamiento y flags de condición. Estos campos determinan cuántas y qué tipo de operaciones puede ejecutar el procesador en un ciclo de reloj.

La Figura \@ref(fig:forminst)  muestra un ejemplo representativo de formato de instrucción, donde se visualizan los campos que la componen y su disposición en el código binario.

```{r forminst, echo=FALSE, fig.cap="Formato de instrucciones ", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/formatoinst.png")
```

### Comparativa de repertorios de instrucciones reales

La siguiente tabla resume las características principales de los repertorios de instrucciones en tres arquitecturas ampliamente utilizadas: x86, ARM y RISC-V. Se consideran aspectos como la longitud de las instrucciones, la cantidad de operandos, su complejidad y los modos de direccionamiento que permiten.

```{r comparativaISA, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear los datos de la tabla
isa_comparativa <- data.frame(
  Arquitectura = c("x86", "ARM", "RISC-V"),
  `Longitud instrucción` = c("Variable", "Fija (32 bits)", "Fija (32 bits)"),
  `Nº operandos` = c("0–3+", "3", "3"),
  `Tipos de operandos` = c("Complejos", "Simples", "Simples"),
  `Modos de direccionamiento` = c("Muchos", "Limitados", "Extensible")
)

# Crear la tabla con formato dinámico
kable(isa_comparativa,
      format = ifelse(knitr::is_latex_output(), "latex", "html"),
      caption = "Comparativa de repertorios de instrucciones reales",
      col.names = c("Arquitectura", "Longitud instrucción", "Nº operandos", "Tipos de operandos", "Modos de direccionamiento"),
      booktabs = TRUE,
      escape = FALSE) %>%
  kable_styling(
    latex_options = c("scale_down", "hold_position"),
    full_width = FALSE,
    position = "center"
  ) %>%
  column_spec(1, bold = TRUE, border_right = TRUE) %>%
  column_spec(2:5, width = "4cm") %>%
  row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3")
```

## Filosofías CISC y RISC
El diseño del repertorio de instrucciones es una decisión estratégica clave en la arquitectura de procesadores, ya que determina no solo el rendimiento del sistema, sino también la complejidad del hardware y del software, en particular del compilador. Dos de las filosofías más influyentes en este campo son **CISC (Complex Instruction Set Computing)** y **RISC (Reduced Instruction Set Computing)**. Mientras que **CISC** prioriza la reducción del número de instrucciones necesarias para realizar tareas complejas mediante operaciones multifuncionales, **RISC** simplifica el conjunto de instrucciones con el objetivo de maximizar la velocidad y la eficiencia energética. En esta sección se analizan ambos enfoques y sus implicaciones en el diseño de procesadores [@hennessy2017computer; @patterson_computer_2014].

El debate entre las filosofías CISC y RISC se remonta a fines de la década de 1970, cuando se comenzaron a cuestionar los beneficios reales de los repertorios de instrucciones complejos. Mientras las primeras generaciones de computadoras buscaban reducir el número de instrucciones por programa, investigaciones posteriores demostraron que un conjunto reducido y eficiente de instrucciones podía mejorar significativamente el rendimiento al simplificar la ejecución y optimizar el uso del hardware.

La evolución de los procesadores ha llevado a un enfoque más equilibrado, donde las arquitecturas modernas combinan elementos de ambas filosofías. Las arquitecturas modernas tienden a incorporar elementos de ambas filosofías. Por ejemplo, x86 adopta técnicas de ejecución interna propias de RISC para aumentar su rendimiento, mientras que procesadores RISC como ARM han introducido extensiones complejas para tareas específicas, acercándose parcialmente al enfoque CISC [@hennessy2017computer; @patterson_computer_2014].

### CISC
Las arquitecturas **CISC**, como la **x86**, se caracterizan por su enfoque en reducir el número de instrucciones requeridas para completar operaciones complejas. Esto se logra mediante la inclusión de instrucciones que combinan múltiples operaciones en un solo ciclo. Como resultado, los programadores necesitan escribir menos líneas de código para alcanzar un objetivo específico.

Sin embargo, este diseño implica ciertas desventajas. La **decodificación** y **ejecución** de instrucciones CISC requiere un hardware considerablemente más complejo, y las instrucciones de longitud variable, típicas de estas arquitecturas, pueden aumentar el tiempo de decodificación. Esto genera cuellos de botella en el pipeline y limita el rendimiento.

Un ejemplo representativo es la arquitectura x86, que ha incorporado técnicas internas de ejecución similares a RISC —como la descomposición de instrucciones mediante microcódigo— con el fin de mejorar el rendimiento sin abandonar su repertorio complejo. Utiliza microcódigo para descomponer las instrucciones complejas en operaciones más simples, parecidas a las de un procesador RISC. Aunque esta estrategia mejora la eficiencia de ejecución en algunos casos, el diseño sigue siendo más costoso en términos de consumo energético y complejidad [@patterson_computer_2014].

En consecuencia, el diseño del repertorio de instrucciones —incluyendo operaciones, modos de direccionamiento y formatos— constituye la interfaz crítica entre hardware y software, afectando tanto la eficiencia de ejecución como la expresividad de los programas. Su diseño influye directamente en la eficiencia del procesamiento y en la forma en que los programas interactúan con la arquitectura subyacente, lo que refuerza su relevancia en el estudio de la arquitectura de computadoras.

### RISC {#RISC}
Las arquitecturas basadas en RISC, en contraste con CISC, se caracterizan por emplear instrucciones simples y de longitud fija. Esta simplificación facilita la decodificación y permite que muchas instrucciones se ejecuten en un solo ciclo de reloj. Además, esta filosofía favorece la implementación de técnicas avanzadas como el pipelining y la predicción de ramas, optimizando así el rendimiento.

A nivel de hardware, RISC prioriza la eficiencia energética, una característica crucial en dispositivos móviles y sistemas embebidos. Por ello, procesadores como los basados en ARM han dominado estos mercados, especialmente en dispositivos móviles, debido a su bajo consumo energético. La simplicidad y el bajo CPI (ciclos por instrucción) han sido factores determinantes en su adopción [@hennessy2017computer].

### Comparativa entre CISC y RISC
Las diferencias entre CISC y RISC son evidentes tanto a nivel de diseño como de implementación. En las arquitecturas RISC, las instrucciones tienen una longitud fija, lo que simplifica la decodificación, reduce la latencia y mejora la predictibilidad del rendimiento. Además, este formato mejora la eficiencia del uso de la memoria caché, al ocupar menos espacio y facilitar accesos más rápidos.

En cambio, las arquitecturas CISC, como x86, emplean instrucciones de longitud variable, lo que les permite ofrecer una mayor flexibilidad y un repertorio más amplio de operaciones. Sin embargo, esta flexibilidad conlleva un mayor tiempo de decodificación y una complejidad adicional en la implementación del pipeline. Esto puede causar problemas como interrupciones en el flujo debido a errores de predicción de ramas, aunque se mitiguen mediante técnicas avanzadas como la predicción dinámica de saltos y el prefetching [@tanenbaum_structured_2016].

Por ejemplo, en RISC, los modos de direccionamiento son simples y permiten un acceso más rápido a los operandos, reduciendo la latencia en el pipeline [@stallings_computer_2021]. En CISC, los modos de direccionamiento más complejos proporcionan flexibilidad a costa de una mayor latencia, lo que impacta negativamente en el rendimiento general del sistema.

#### Ejemplos de instrucciones
Para ilustrar la diferencia entre ambas filosofías, se presenta el siguiente ejemplo: cargar dos valores de memoria, sumarlos y almacenar el resultado en una dirección de memoria.

RISC:

```{r  code0, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
  ; Carga el valor inmediato 10 en el registro R0
  LOAD R1, [mem1]    # Cargar el valor de mem1 en el registro R1
  LOAD R2, [mem2]    # Cargar el valor de mem2 en el registro R2
  ADD  R3, R1, R2    # Sumar los valores en los registros R1 y R2, guardar en R3
  STORE R3, [mem1]   # Guardar el resultado en mem1
  \\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
  LOAD R1, [mem1]    # Cargar el valor de mem1 en el registro R1
  LOAD R2, [mem2]    # Cargar el valor de mem2 en el registro R2
  ADD  R3, R1, R2    # Sumar los valores en los registros R1 y R2, guardar en R3
  STORE R3, [mem1]   # Guardar el resultado en mem1
  ```")
}
```

CISC:

```{r  code1, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
  MOV EAX, [mem1]    # Cargar el valor de mem1 en el registro EAX
  ADD EAX, [mem2]    # Sumar el valor de mem2 con EAX
  MOV [mem1], EAX    # Guardar el resultado de la suma de vuelta en mem1
  \\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
  MOV EAX, [mem1]    # Cargar el valor de mem1 en el registro EAX
  ADD EAX, [mem2]    # Sumar el valor de mem2 con EAX
  MOV [mem1], EAX    # Guardar el resultado de la suma de vuelta en mem1
  ```")
}
```

La tabla \@ref(tab:ciscrisc) sintetiza las principales diferencias estructurales y operativas entre las filosofías CISC y RISC, destacando sus implicancias en el diseño del hardware y el rendimiento general del sistema.

```{r ciscrisc, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

ciscrisc <- data.frame(
  Aspecto = c("Objetivo principal",
              "Tipo de instrucciones",
              "Decodificación y ejecución",
              "Longitud de instrucciones",
              "Eficiencia energética",
              "Modos de direccionamiento"),
  CISC = c("Minimizar el número de instrucciones para operaciones complejas",
           "Instrucciones complejas, longitud variable",
           "Requiere hardware más complejo, posibles cuellos de botella en el pipeline", # nolint: line_length_linter.
           "Longitud variable, puede aumentar el tiempo de decodificación",
           "Menor eficiencia energética en comparación con RISC",
           "Flexibilidad a costa de mayor latencia"),
  RISC = c("Simplificar el conjunto de instrucciones para optimizar velocidad y eficiencia energética", # nolint: line_length_linter.
           "Instrucciones simples, longitud fija",
           "Decodificación más sencilla, facilita el uso de técnicas avanzadas como pipelining", # nolint: line_length_linter.
           "Longitud fija, simplifica la decodificación y mejora la predictibilidad del rendimiento", # nolint: line_length_linter.
           "Mayor eficiencia energética, especialmente en dispositivos móviles",
           "Acceso más rápido a los operandos, menor latencia")
)

# Crear la tabla con formato dinámico
tabla <- kable(ciscrisc,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Comparativa entre CISC y RISC",
               col.names = c("Aspecto", "CISC", "RISC"),
               booktabs = TRUE,
               escape = FALSE)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "5cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(ciscrisc)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "20em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

#### Convergencia de filosofías
A pesar de sus diferencias, las arquitecturas modernas tienden a integrar características de ambas filosofías. Por ejemplo, los procesadores x86 adoptan técnicas propias de RISC para mejorar la eficiencia energética y el rendimiento. Esta convergencia refleja cómo los avances en diseño de procesadores buscan combinar lo mejor de cada enfoque, maximizando la flexibilidad y la eficiencia para adaptarse a las necesidades actuales y futuras del mercado.

La Figura \@ref(fig:convergen) muestras la convergencia entre estas dos filosofías:

```{r convergen, echo=FALSE, fig.cap="Convergencia de filosofías", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/convergen.png")
```

En síntesis, las filosofías CISC y RISC representan enfoques contrastantes pero complementarios en el diseño de arquitecturas de procesadores. Su comprensión no solo es esencial para analizar el rendimiento y la eficiencia energética de los sistemas modernos, sino también para formar una base sólida en la enseñanza de arquitectura de computadoras, especialmente en contextos donde se emplean simuladores didácticos.

## Arquitectura x86
La arquitectura x86, reconocida por su amplia adopción en computadoras personales, estaciones de trabajo y servidores, se introdujo en 1978 con el procesador Intel 8086, basado en una arquitectura de 16 bits. Desde entonces, ha evolucionado en capacidad y complejidad, con hitos clave como la introducción del Intel 80386 (32 bits) en 1985 y la extensión a 64 bits con AMD64 en 2003. Esta evolución ha permitido mejoras significativas en el rendimiento, el direccionamiento de memoria y la compatibilidad con aplicaciones exigentes. [@stallings_computer_2021; @intel_64_2025; @amd_developer_2024; @abel_ibm_2000].

### Evolución de la arquitectura x86
Uno de los pilares del éxito de la arquitectura x86 ha sido su retrocompatibilidad, permitiendo la ejecución de aplicaciones de 16, 32 y 64 bits en un mismo sistema. Dicha propiedad no solo ha garantizado la continuidad del ecosistema x86, sino que también ha protegido las inversiones en software y sistemas operativos, una característica fundamental en entornos empresariales y académicos.

A continuación, se presenta la tabla \@ref(tab:hitosx86) que resume los hitos clave en la evolución de los procesadores x86:

```{r hitosx86, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

hitosx86 <- data.frame(
  Procesador = c("Intel 8086", "Intel 80386", "AMD64"),
  `Año de Lanzamiento` = c(1978, 1985, 2003),
  `Número de Bits` = c(16, 32, 64),
  `Nuevas Características` = c(
    "Arquitectura inicial",
    "Memoria virtual",
    "Extensiones de 64 bits"
  )
)

# Crear la tabla con formato dinámico
tabla <- kable(hitosx86,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Hitos en la evolución x86",
               col.names = c("Procesador", "Año de Lanzamiento", "Número de Bits", "Extensiones de 64 bits"), # nolint
               booktabs = TRUE,
               escape = FALSE)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(hitosx86)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "18em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

La tabla \@ref(tab:evolucionx86) muestra cómo la evolución de x86 ha estado marcada por avances tecnológicos que han impulsado la informática hacia nuevas fronteras:

```{r evolucionx86, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

evolucionx86 <- data.frame(
  Año = c(1978, 1982, 1985, 1989, 1993, 1995, 2003, 2006),
Procesador = c("Intel 8086", "Intel 80286", "Intel 80386", "Intel 80486", "Intel Pentium", "Intel Pentium Pro", "AMD64", "Intel Core"), # nolint
`Innovación_Principal`  = c("Introducción de la arquitectura x86, 16 bits",
                            "Modos de operación adicionales",
                            "Arquitectura de 32 bits, memoria virtual",
                            "Unidad de punto flotante integrada, mejor caché",
                            "Ejecución superescalar, predicción de saltos",
                            "Ejecución fuera de orden, caché L2 integrada",
                            "Extensiones a 64 bits, mayor acceso a memoria",
                            "Optimización de rendimiento y eficiencia energética") # nolint: line_length_linter.
)

# Crear la tabla con formato dinámico
tabla <- kable(evolucionx86,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Línea de Tiempo de la Evolución de la Arquitectura x86", # nolint
               col.names = c("Año", "Procesador", "Innovación"),
               booktabs = TRUE,
               escape = FALSE)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "5cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(evolucionx86)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "20em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

###  Repertorio de instrucciones x86
La arquitectura x86 destaca por su complejidad y flexibilidad, reflejada en un repertorio de instrucciones extenso y de longitud variable. Esto contrasta con arquitecturas RISC, donde predominan instrucciones de longitud fija y decodificación sencilla [@hennessy2017computer]. Aunque esta flexibilidad implica una mayor capacidad expresiva y compatibilidad hacia atrás, también introduce desafíos de diseño, tales como la necesidad de decodificadores complejos, técnicas de predicción de instrucciones y ejecución fuera de orden para lograr un rendimiento competitivo. 

#### Estructura de una instrucción x86
Una instrucción típica de x86 puede incluir los siguientes componentes [@stallings_computer_2021]:

  - **Prefijos**: modifican la operación principal de la instrucción. Por ejemplo, el prefijo `0x66` cambia el tamaño del operando.
  - **Código de operación (Opcode)**: indica la operación a realizar. Por ejemplo, `0x89` corresponde `MOV`.
  - **Modificadores de dirección (ModR/M y SIB)**: definen registros y direccionamiento. El byte **SIB** (Scale, Index, Base) es especialmente útil para operaciones complejas, como el acceso a matrices.
  - **Desplazamiento e inmediato**: Agregan flexibilidad en el manejo de datos, aunque aumentan la complejidad.

```{r FormatoInst, echo=FALSE, fig.cap="Formato de instrucciones del Pentium x86", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/formatoinstruccionx86.png")
```

Un ejemplo típico de instrucción es:

```{r  code2, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
  ; Carga el valor inmediato 10 en el registro R0
  MOV AX, [BX+SI+16]
  \\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
    MOV AX, [BX+SI+16]
  ```")
}
```

Esta instrucción utiliza varios componentes, que el procesador debe decodificar antes de ejecutarla. Aunque esta flexibilidad es una ventaja en términos de funcionalidad, requiere técnicas avanzadas, como predicción de saltos y paralelización, para mantener la eficiencia en procesadores modernos [@hennessy2017computer; @patterson_computer_2014].

## Lenguaje máquina y lenguaje ensamblador
El lenguaje máquina es el conjunto de instrucciones que un procesador puede entender y ejecutar directamente. Cada procesador tiene su propio conjunto de instrucciones, que se representan en forma de números binarios. Estas instrucciones son específicas para cada arquitectura y están diseñadas para realizar operaciones básicas como sumar, restar, mover datos entre registros y acceder a la memoria. El lenguaje máquina es el nivel más bajo de programación y está compuesto por secuencias de bits que representan operaciones y operandos específicos del procesador
[@irvine2011assembly; @hennessy2017computer].

El procesador ejecuta directamente las instrucciones codificadas en lenguaje máquina, sin requerir traducción desde niveles superiores de abstracción. Sin embargo, la escritura manual de código en lenguaje máquina es un proceso extremadamente laborioso, propenso a errores y difícil de mantener. Cada instrucción debe representarse como una cadena precisa de ceros y unos. Esta codificación depende de las reglas específicas del procesador, que incluyen los modos de direccionamiento, los formatos de instrucción y la organización de la memoria [@irvine2011assembly; @stallings_computer_2021; @tanenbaum_structured_2016; @null_essentials_2014].

Por ejemplo, si un estudiante o desarrollador deseara sumar dos números en lenguaje máquina, tendría que especificar manualmente cada secuencia binaria correspondiente a la operación de suma, así como las direcciones de memoria donde se encuentran los operandos. Este enfoque no solo es tedioso, sino que también aumenta la probabilidad de errores, especialmente cuando se requiere modificar o depurar el código.

Ante las limitaciones del lenguaje máquina en términos de legibilidad y mantenibilidad, se desarrolló un lenguaje de bajo nivel con mayor legibilidad que el lenguaje máquina que permitiera al programador escribir instrucciones de forma más comprensible: el lenguaje ensamblador. Este lenguaje permite a los programadores escribir instrucciones más comprensibles mediante mnemónicos simbólicos, que actúan como representaciones legibles de las instrucciones en lenguaje máquina. Cada arquitectura de procesador define su propio conjunto de instrucciones (ISA, Instruction Set Architecture), lo que implica que el lenguaje ensamblador asociado debe ajustarse a la codificación binaria, modos de direccionamiento y sintaxis específicos de dicha ISA [@stallings_computer_2021].

En el ámbito educativo, el lenguaje ensamblador se destaca como una herramienta fundamental para comprender cómo se comunican el software y el hardware [@null_essentials_2014; @tanenbaum_structured_2016]. Permite a los estudiantes visualizar la ejecución de instrucciones individuales, analizar el uso de registros y explorar la estructura de la memoria, convirtiéndose en un recurso valioso para este propósito.

Un programa en lenguaje ensamblador suele estar compuesto por instrucciones que especifican un mnemónico, uno o más operandos, y eventualmente el modo de direccionamiento. Por ejemplo:

```{r  code3, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
  ; Carga el valor inmediato 10 en el registro R0
  MOV AX, 5
  ADD AX, BX
  \\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
    MOV AX, 5
    ADD AX, BX
  ```")
}
```

Estas líneas indican que el valor 5 se mueve al registro AX y luego se suma el contenido de BX. A través de este tipo de instrucciones, el estudiante puede visualizar de forma explícita cómo opera el procesador sobre sus registros y memoria.

### Ensamblador
El ensamblador es un programa que traduce las instrucciones simbólicas escritas en lenguaje ensamblador a lenguaje máquina, es decir, las convierte en las secuencias binarias que el procesador puede interpretar y ejecutar. Este proceso de traducción es prácticamente directo, ya que existe una correspondencia uno a uno entre las instrucciones en ensamblador y las instrucciones en lenguaje máquina [@stallings_computer_2021; @tanenbaum_structured_2016]. En contraste, los lenguajes de programación de alto nivel, como C o Python, suelen generar múltiples instrucciones máquina por cada línea de código fuente, lo que los distancia más de la arquitectura subyacente [@hennessy2017computer].

La Figura \@ref(fig:ensambla) muestra el proceso de traducción de un programa en lenguaje ensamblador a lenguaje máquina. En este proceso, el ensamblador toma cada línea de código en ensamblador y la convierte en su representación binaria correspondiente, generando así un archivo ejecutable que puede ser cargado y ejecutado por el procesador.

```{r ensambla, echo=FALSE, fig.cap="Proceso de ensamblado", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/ensamblador.png")
```

### Ensambladores x86
En el caso de la arquitectura x86, los programadores pueden elegir entre diversos ensambladores, como TASM (Turbo Assembler) [@tasm], MASM (Microsoft Macro Assembler) [@masm] y NASM (Netwide Assembler) [@nasm]. Aunque cada ensamblador tiene características y sintaxis particulares, todos comparten el objetivo fundamental de convertir las instrucciones ensamblador en código binario ejecutable por los procesadores x86 [@hyde2010art].

A continuación, se presenta una tabla comparativa \@ref(tab:ensambladores) que resume las principales características de tres ensambladores ampliamente utilizados en la arquitectura x86. La información compilada permite visualizar diferencias relevantes en términos de sintaxis, compatibilidad, funcionalidades adicionales y contexto de uso, lo que resulta particularmente útil al momento de seleccionar herramientas adecuadas para entornos educativos o de desarrollo de bajo nivel.

```{r ensambladores, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear un data frame con la información de los ensambladores
ensambladores <- data.frame(
  Característica = c("Desarrollador", "Año de lanzamiento", "Sistema operativo",
                     "Sintaxis", "Soporte de macros", "Compatibilidad",
                     "Capacidades adicionales", "Licencia", "Uso actual"),
  TASM = c("Borland", "1985", "MS-DOS, Windows",
           "Sintaxis similar a Intel con extensiones",
           "Macros y directivas avanzadas",
           "Compatibilidad con x86 antiguo",
           "Integración con herramientas Borland",
           "Comercial",
           "Menos común, usado en entornos heredados"),
  MASM = c("Microsoft", "1981", "MS-DOS, Windows",
           "Sintaxis de Intel con soporte avanzado",
           "Macros y directivas extensivas",
           "Compatibilidad con x86 antiguo",
           "Integración con Visual Studio",
           "Comercial",
           "Ampliamente usado en desarrollo Windows"),
  NASM = c("Simon Tatham et al.", "1996", "Multiplataforma (Windows, Linux, macOS)", # nolint: line_length_linter.
           "Sintaxis de Intel, modular y extensible",
           "Macros avanzadas y preprocesamiento",
           "Compatibilidad con x86, x86-64 y otros",
           "Soporte para múltiples formatos (binario, ELF, etc.)",
           "Código abierto",
           "Popular en sistemas y software libre"),
  stringsAsFactors = FALSE
)


# Crear la tabla con formato dinámico
tabla <- kable(ensambladores,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Comparación de ensambladores arquitectura x86",
               col.names = c("Característica", "TASM", "MASM", "NASM"), # nolint
               booktabs = TRUE,
               escape = FALSE)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(ensambladores)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "18em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```
