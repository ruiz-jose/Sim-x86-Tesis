# Diseño y Construcción del Simulador {#desarrollo}
En este capítulo se describe el diseño y desarrollo de una herramienta de simulación específica para la arquitectura x86, orientada a facilitar la enseñanza de los principios de arquitectura de computadoras. Se detalla la justificación del diseño, los pasos seguidos para su construcción y los métodos utilizados para validar su funcionalidad.

En el capítulo anterior se analizaron y evaluaron las herramientas de simulación existentes para la arquitectura x86. Esta revisión exhaustiva permitió identificar las limitaciones de las soluciones actuales y fundamentar la necesidad de desarrollar una herramienta específica, cuyos resultados fueron publicados posteriormente.

Para cumplir con este objetivo, el diseño de la herramienta sigue una serie de requisitos establecidos que guían su desarrollo, validación y alineación con los objetivos pedagógicos. 

## Requisitos de la herramienta
La herramienta de simulación está diseñada para cumplir los siguientes requisitos:
1. **Representación global de la estructura y funcionamiento de la computadora:**
   - Mostrar de manera visual la estructura completa de la computadora (CPU, bus, memoria y E/S) durante la ejecución de programas, resaltando relevantes.

2. **Soporte para la generación y ejecución de programas en ensamblador:**
   - Facilitar la ejecución de programas en ensamblador paso a paso como completa, promoviendo la comprensión detallada de cada instrucción.

3. **Repertorio de instrucciones reducido y habilitación progresiva:**
   - Seleccionar un subconjunto esencial de instrucciones x86, que se habiliten progresivamente según avance la asignatura, adaptándose al ritmo de aprendizaje de los estudiantes.

4. **Simulación visual e interactiva de micropasos de instrucciones:**
    - Representar el flujo de datos con el lenguaje de transferencia entre registros (RTL), destacando visualmente cada componente involucrado en la ejecución de un programa.
    
5. **Gestión básica de interrupciones y periféricos:**
    - Incorporar un vector de interrupción predefinido para interactuar con dispositivos como teclado y monitor. También incluir instrucciones IN y OUT, junto con un módulo simplificado de entrada/salida.

6. **Métricas de rendimiento:**
    - Proporcionar indicadores clave como tiempo de ciclo, tiempo de CPU y ciclos por instrucción (CPI) para analizar la ejecución de programas.

## Arquitectura propuesta
La arquitectura propuesta es una versión simplificada de **8 bits** de la arquitectura **x86**, diseñada con un repertorio de instrucciones reducido y un conjunto de componentes esenciales. Este diseño simplificado facilita que los estudiantes comprendan conceptos fundamentales como el formato de instrucciones, modos de direccionamiento y el ciclo de búsqueda y ejecución.

### Justificación de la simplificación
La arquitectura x86 se caracteriza por su complejidad, con un extenso repertorio de instrucciones y características avanzadas que pueden resultar desafiantes para estudiantes principiantes. Por ello, el simulador se desarrolla con un enfoque pedagógico centrado en:

- **Reducir la carga cognitiva**: Al limitar la complejidad del repertorio de instrucciones y los componentes del simulador, los estudiantes pueden concentrarse en entender los principios fundamentales sin distracciones innecesarias.
- **Fomentar un aprendizaje progresivo**: Se adopta una aproximación escalonada, donde los estudiantes comienzan trabajando con un simulador simplificado antes de avanzar a herramientas que representen de forma completa la arquitectura x86. Este enfoque les permite construir conocimientos de manera incremental, fortaleciendo su comprensión a medida que enfrentan conceptos más avanzados.
- **Priorizar la claridad pedagógica**: Un conjunto reducido de instrucciones y una arquitectura simplificada permiten realizar prácticas manejables en tiempo y esfuerzo, lo cual es crucial para evitar frustraciones y reforzar el aprendizaje práctico.

### Beneficios de la simplificación
El diseño del simulador con una arquitectura simplificada permite a los estudiantes:

- **Entender los fundamentos**: Se enfocan en aspectos esenciales como el ciclo de instrucción, la interacción entre componentes de la CPU y el flujo básico de datos en el sistema.
- **Comparar y reflexionar**: Analizan las diferencias entre el modelo simplificado y la arquitectura x86 real, fomentando el pensamiento crítico y el entendimiento profundo de las características más complejas de la arquitectura real.
- **Aprender de manera práctica**: Realizan experimentos y resuelven ejercicios que les permiten explorar, equivocarse y aprender, en un entorno controlado y accesible.

### Alineación con los objetivos pedagógicos
La herramienta no busca sacrificar precisión, sino adoptar una estrategia educativa que optimice la comprensión de los estudiantes. Este enfoque permite:

- Conectar teoría y práctica, facilitando la transición desde conceptos abstractos hacia aplicaciones concretas.
- Proveer una base sólida para abordar simuladores más avanzados que representen con fidelidad la complejidad de la arquitectura x86.
- Enriquecer la experiencia de aprendizaje al integrar componentes interactivos y visuales que complementan los materiales teóricos.

## Componentes del simulador
### Procesador o CPU
El procesador diseñado para este simulador cuenta con las siguientes características principales:

```{r arq, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear el data frame con los datos del cuadro
arq <- data.frame(
  `Arquitectura` = c("Arquitectura", 
                         "Registros", 
                         "", 
                         "", 
                         "", 
                         "Memoria", 
                         "Buses", 
                         "Instrucciones", 
                         ""),
  `Características` = c("- von Neumann, con memoria compartida para datos e instrucciones.",
                        "- 4 registros de propósito general (`AL`, `BL`, `DL` y `DL`) de 8 bits cada uno.",
                        "- 3 registros de propósito específico: `IP` (Instruction Pointer), `IR`(Instruction Register) y `SP`(Stack Pointer).",
                        "- 1 registro de estado (`RS`) para las banderas.",
                        "- 2 registros intermedios (`MAR`: buffer de direcciones y `MBR`: buffer de datos) para comunicación entre CPU y memoria.",
                        "- Memoria de 256 posiciones, con una capacidad de un byte por posición.",
                        "- Bus de datos y direcciones de 8 bits.",
                        "- Longitud variable (1, 2 y 3 bytes).",
                        "-  Soporta un conjunto de 16 instrucciones."),
  stringsAsFactors = FALSE
)

# Convertir a HTML
kable(arq, format = "markdown", align = "l", col.names = c("Arquitectura", "Características"), 
      caption = "Arquitectura x86 propuesta", escape = FALSE)
```

### Repertorio de instrucciones
El repertorio propuesto para el simulador es una simplificación de la arquitectura x86, diseñada para facilitar la enseñanza y el aprendizaje. Este conjunto ficticio opera con instrucciones de 8 bits para una mejor comprensión.

## Primera etapa
En la primera fase, se introducen únicamente las instrucciones esenciales para abordar los contenidos iniciales de la asignatura:

```{r setreducido, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear los datos
setreducido <- data.frame(
  Instrucciones = c(
    "Transferencia de datos", 
    "", 
    "", 
    "Pocesamiento de datos",
    "", 
    "", 
    "Control de flujo",
    "",
    ""  
  ),
  `Código operación` = c(
    "{0, 1, 2}",
    "", 
    "", 
    "{3, 4, 5}",
    "{6, 7, 8}",
    "{9, 10, 11}",
    "{12}",
    "",
    "" 
  ),
  `Nemónico` = c(
    "MOV ",
    "",
    "",
    "ADD",
    "SUB",
    "CMP", 
    "JMP", 
    "JZ ",
    "JC "
  ),
  Acción = c( "0- Copiar entre registros",
    "1- Cargar a registro",
    "2- Almacenar en memoria",
    "3-4-5 Sumar",
    "6-7-8 Restar",
    "9-10-11 Comparar",
    "12-a Salto incondicional ",
    "12-b Salto condicional si Z=1",
    "12-c Salto condicional si C=1"
  )
)

# Convertir a HTML
kable(setreducido, format = "markdown", align = "l", col.names = c("Instrucciones", "Código operación", "nemónico", "Acción"), 
      caption = "Tabla de Instrucciones y Códigos de Operación de la Arquitectura x86")
```

### Formato de instrucciones
El formato de las instrucciones contempla los siguientes casos:

```{r codtreducido, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear un dataframe con los datos
codtreducido <- data.frame(
  Tipo = c("Transferencia y procesamiento", "", "", "Control"),
  Caso = c("A: entre registros", "B: Cargar a registro", "C: Almacenar en memoria", "D: control de flujo"),
  Codificación = c("---- XXYY", "---- XX00 DDDDDDDD", "---- 00YY DDDDDDDD", "---- ffff DDDDDDDD"),
  Parámetros = c(
    "XX = Registro destino, YY = Registro fuente",
    "XX = Registro destino, M = Dirección de memoria",
    "YY = Registro fuente, M = Dirección de memoria",
    "ffff = funcionalidad, M = Dirección de memoria"
  )
)
kable(codtreducido, format = "markdown", align = "l", col.names = c("Tipo","Casos", "Codificación", "Parámetros"), 
      caption = "Tabla de codififación de instrucciones")
```

Considerando:

  - `A`: operaciones entre registros del procesador.

  - `B`: operaciones que cargan en registros del procesado.

  - `C`: operaciones que almacenan en memoria.

  - `D`: operaciones de control de flujo del programa.

  - `----`: Código de operación de la instrucción.

  - `XX` o `YY`: Índices de registros, número entre `0` y `3`.

  - `M`: Dirección de memoria, número de 8 bits.

  - `ffff`: representan el comportamiento de la instrucción.

  - Las instruciones de transferencia y de procesamiento soportan los formatos `A`, `B` y `C`.

  - Las instruciones de control de flujo soportan el formato `D`. 

### Banco de registros
```{r tabla_registros, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear un dataframe con los datos
tabla_registros <- data.frame(
  Registro = c("AL", "BL", "CL", "DL"),
  Binario = c("00", "01", "10", "11"),
  Decimal = c(0, 1, 2, 3)
)

# Imprimir la tabla en formato markdown
kable(tabla_registros, format = "markdown", col.names = c("Número de registros (R)", "Binario", "Decimal"))
```
### Modos de direccionamiento

Los modos de direccionamiento definidos en esta etapa son:

| Operando | tipo | 
| --- | --- |
| `Rx`,`Ry`| Registro a registro: operandos son registros del procesador. |
| `[M]`|	Directo: operando es el contenido de una dirección de memoria. |

En esta primera etapa se implementan las siguientes instrucciones con estos modos de direccionamiento y formato de instrucciones:

```{r tabla_instrucciones, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear un dataframe con los datos
tabla_instrucciones <- data.frame(
  `#` = c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "A", "B", "C", "C", "C"),
  Instrucción = c("MOV Rx, Ry", "MOV Rx, [M]", "MOV [M], Ry", "ADD Rx, Ry", "ADD Rx, [M]", "ADD [M], Ry", "SUB Rx, Ry", "SUB Rx, [M]", "SUB [M], Ry", "CMP Rx, Ry", "CMP Rx, [M]", "CMP [M], Ry", "JMP M", "JC M", "JZ M"),
  Acción = c(
    "Rx ← Ry",
    "Rx ← Mem[Dirección]",
    "Mem[Dirección] ← Rx",
    "Rx ← Rx + Ry",
    "Rx ← Rx + Mem[Dirección]",
    "Mem[Dirección] ← Mem[Dirección] + Ry",
    "Rx ← Rx - Ry",
    "Rx ← Rx - Mem[Dirección]",
    "Mem[Dirección] ← Mem[Dirección] - Ry",
    "Modifica flags de Rx - Ry",
    "Modifica flags de Rx - Mem[Dirección]",
    "Modifica flags de Mem[Dirección] - Ry",
    "IP ← Dirección",
    "Si flag C=1 entonces IP ← Dirección",
    "Si flag Z=1 entonces IP ← Dirección"
  ),
  Codificación = c(
    "0000 XXYY",
    "0001 00YY MMMMMMMM",
    "0010 XX00 MMMMMMMM",
    "0011 XXYY",
    "0100 00YY MMMMMMMM",
    "0101 XX00 MMMMMMMM",
    "0110 XXYY",
    "0111 00YY MMMMMMMM",
    "1000 XX00 MMMMMMMM",
    "1001 XXYY",
    "1010 00YY MMMMMMMM",
    "1011 XX00 MMMMMMMM",
    "1100 0000 MMMMMMMM",
    "1100 0001 MMMMMMMM",
    "1100 0011 MMMMMMMM"
  )
)

# Imprimir la tabla en formato markdown
kable(tabla_instrucciones, format = "markdown", col.names = c("#", "Instrucción", "Acción", "Codificación"))
```

## Segunda etapa
En esta etapa, se amplían los modos de direccionamiento e instrucciones:

### Modos de Direccionamiento Adicionales
Se incoporan los siguientes modos de direccionamiento:

| Operando | tipo | 
| --- | --- |
| `[BL]`| Registro a registro: operandos son registros del procesador. |
| `m`  |	Inmediato: operando es un valor contenido en la instrucción. |
| `[BL + m]`|	Directo: operando es el contenido de una dirección de memoria. |

### Formato Ampliado
Las instrucciones ahora se codifican con 1, 2 o 3 bytes dependiendo del modo:

| Caso | Codificación | Parámetros |
| --- | --- | --- |
| A: entre registros | `---- XXYY` | `XX` = Registro destino, `YY` = Registro fuente |
| B: Cargar a registro  | `---- XXff MMMMMMMM` | `ff` = funcionalidad, `XX` = Registro destino, `M` = Dirección de memoria o Dato Inmediato |
| C: Almacenar en memoria | `---- ffff MMMMMMMM dddddddd` | `ffff` = funcionalidad, `M` = Dirección de memoria,  `d` = Dato Inmediato |
| D: control de flujo  | `---- ffff MMMMMMMM` | `ffff` = funcionalidad `M` = Dirección de memoria |

 `d` = Dato Inmediato, no puede ser destino de la instrucción.

| Modo direccionamiento B: Cargar a registro  |  |  |
| :---: | :---: | :---: |
| **`ff`= funcionalidad** | **`Byte`= tamaño** | **Interpretación** |
| 00 |  2 |directo `M` = Dirección de memoria |
| 01 |  1 |indirecto utiliza como operando implicito el registro `BL` y no requiere operando `M` |
| 10 |  2 |Inmediato `d` = Dato Inmediato |
| 11 |  2 |Indirecto la dirección se calcula operando implicito `BL` + Dato Inmediato|

| Modo direccionamientos C: Almacenar en memoria  |  |  |
| :---: | :---: | :---: |
| **`ffff`= funcionalidad** | **`Byte`= tamaño** | **Interpretación** |
| 00YY |  2 |directo `D` = Dirección de memoria, `YY` = Registro fuente |
| 01YY |  1 |indirecto `BL`, `YY` = Registro fuente|
| 01YY |  2 |Indirecto la dirección se calcula operando implicito `BL` + Dato Inmediato |
| 1100 |  3 |Inmediato a memoria|
| 1101 |  2 |Inmediato a memoria mediante indirecto `BL`|
| 1110 |  3 |Inmediato a memoria mediante indirecto `BL`+ Dato Inmediato |


| # | Instrucción        | Acción                                                             | Codificación                  |
| - | ---                | ---                                                                | ---                           |
| 0 | `MOV Rx, Ry`       | `Rx` $\leftarrow$ `Ry`                                             | `0000 XXYY`                   |
| 1 | `MOV Rx, [M]`      | `Rx` $\leftarrow$ `Mem[Dirección]`                                 | `0001 XX00 MMMMMMMM`          |
| 1 | `MOV Rx, [BL]`     | `Rx` $\leftarrow$ `Mem[BL]`                                        | `0001 XX01`                   |
| 1 | `MOV Rx, D`        | `Rx` $\leftarrow$ `Dato`                                           | `0001 XX10 MMMMMMMM`          |
| 1 | `MOV Rx, [BL + D]` | `Rx` $\leftarrow$ `Mem[BL + Dato]`                                 | `0001 XX11 MMMMMMMM`          |
| 2 | `MOV [M], Ry`      | `Mem[Dirección]` $\leftarrow$ `Rx`                                 | `0010 00YY MMMMMMMM`          |
| 2 | `MOV [BL], Ry`     | `Mem[BL]` $\leftarrow$ `Rx`                                        | `0010 01YY`                   |
| 2 | `MOV [BL + D], Ry` | `Mem[BL + Dato]` $\leftarrow$ `Rx`                                 | `0010 10YY MMMMMMMM`          |
| 2 | `MOV [M], D`       | `Mem[Dirección]` $\leftarrow$ `Dato`                               | `0010 1100 MMMMMMMM dddddddd` |
| 2 | `MOV [BL], D`      | `Mem[BL]` $\leftarrow$ `Dato`                                      | `0010 1101 MMMMMMMM`          |
| 2 | `MOV [BL + D], D`  | `Mem[BL + Dato]` $\leftarrow$ `Dato`                               | `0010 1110 MMMMMMMM`          |
| 3 | `ADD Rx, Ry`       | `Rx` $\leftarrow$ `Rx + Ry`                                        | `0011 XXYY`                   |
| 4 | `ADD --, --`       | Mismo direccionamientos que MOV                                    | `0100 ---- --------`          |
| 5 | `ADD --, --`       | Mismo direccionamientos que MOV                                    | `0101 ---- -------- --------` |
| 6 | `SUB Rx, Ry`       | `Rx` $\leftarrow$ `Rx - Ry`                                        | `0110 XXYY`                   |
| 7 | `SUB --, --`       | Mismo direccionamientos que MOV                                    | `0111 ---- --------`          |
| 8 | `SUB --, --`       | Mismo direccionamientos que MOV                                    | `1000 ---- -------- --------` |
| 9 | `CMP Rx, Ry`       | Modifica *flags* de `Rx - Ry`                                      | `1001 XXYY`                   |
| A | `CMP --, --`       | Mismo direccionamientos que MOV                                    | `1010 ---- --------`          |
| B | `CMP --, --`       | Mismo direccionamientos que MOV                                    | `1011 ---- -------- --------` |
| C | `JMP M`            | `IP` $\leftarrow$ `Dirección`                                      | `1100 0000 MMMMMMMM`          |
| C | `JC M`             | Si `flag C=1` entonces `IP` $\leftarrow$ `Dirección`               | `1100 0001 MMMMMMMM`          |
| C | `JZ M`             | Si `flag Z=1` entonces `IP` $\leftarrow$ `Dirección`               | `1100 0011 MMMMMMMM`          |
| C | `Jxx M`            | Se pueden implemementar más flags y CALL                           | `1100 ffff --------`          |

## Tercera etapa
En esta etapa se incorporaron las instrucciones de manejo de pila y de interrupciones, ampliando la funcionalidad del simulador para cubrir un conjunto más completo de operaciones propias de la arquitectura x86.
A continuación, se detalla el conjunto completo de instrucciones, incluyendo su clasificación, nemónicos y las acciones que representan.

```{r isacompleta, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear los datos
isacompleta <- data.frame(
    `Código operación` = c(
    "{0, 1, 2}", 
    "{3, 4, 5} {6, 7, 8} {9, 10, 11}", 
    "{12}",
    "{13}",
    "{14}",
    "{15}"
  ),
  Instrucciones = c(
    "Transferencia de datos", 
    "Procesamiento de datos", 
    "Control de flujo", 
    "Manejo de pila y E/S", 
    "Manejo de interrupción", 
    "Control del CPU"
  ),
  `Nemónico` = c(
    "MOV ", 
    "ADD, SUB,  CMP", 
    "JMP, Jxx,CALL, RET",
    "PUSH, POP, OUT, IN",
    "INT , IRET",
    "NOP , HLT"
  ),
  Acción = c(
    "1- Copiar entre registros 2- Cargar a registro 3- Almacenar en memoria",
    "1- Sumar  2- Restar 3- Comparar",
    "Salto incondicional JMP. Saltos condicionales Jxx.Llamadas a rutinas CALL y retorno RET ",
    "Poner en la pila PUSH Retirar de la pila POP Enviar un byte al puerto del dispositivo de E/S Recibir un byte del dispositivo de E/S",
    "Llamar a una rutina de tratamiento de interrupción INT Retornar de una rutina de tratamiento de interrupción IRET",
    "No opera NOP Detiene el CPU HLT"
  )
)

# Convertir a HTML
kable(isacompleta, format = "markdown", align = "l", col.names = c("Código operación", "Instrucciones", "nemónico", "Acción"), 
      caption = "Tabla de Instrucciones y Códigos de Operación de la Arquitectura x86")
```

## Ciclo de la instrucción: Etapas de captación y ejecución
Este apartado describe en detalle el proceso llevado a cabo por la Unidad de Control (UC) para ejecutar cada instrucción, destacando los siguientes aspectos:

- Secuencia de pasos.
- Registros involucrados en cada etapa del proceso.
- Uso de los buses de datos, direcciones y control.
- Señales de control generadas.

El ciclo de la instrucción se define como la secuencia de microoperaciones que tienen lugar durante la ejecución de una instrucción en el sistema. Estas operaciones se describen utilizando un lenguaje de transferencia entre registros, de la forma:

`destino` $\leftarrow$ `origen` 

#### Etapa de Captación: 
En esta etapa, común a todas las instrucciones, se realiza la lectura de la instrucción desde la memoria.

  1. **`MAR` $\leftarrow$ `IP`**:
  El contenido del registro puntero de instrucciones `IP` se transfiere al registro de direcciones de memoria `MAR`. La UC genera la señal necesaria para seleccionar el valor del `IP` y copiarlo en el `MAR`.
  2. **`MDR` $\leftarrow$ `read(Memoria[MAR])` ; `IP` $\leftarrow$ `IP` + 1**:
  La UC activa la señal de lectura (read) hacia la memoria, utilizando el valor del `MAR` como dirección. El dato leído se transfiere al Registro de Datos de Memoria `MBR` a través del bus de datos. Simultáneamente, el `IP` se incrementa en 1 para apuntar al siguiente byte.
  3. **`IR` $\leftarrow$ `MBR`**:
  El contenido del `MBR` se transfiere al Registro de Instrucciones `IR`, completando la etapa de captación. 

#### Etapa de Ejecución:
En esta etapa, las operaciones específicas dependen del tipo de instrucción. A continuación, se describen algunos casos representativos:

* MOV `Rx`, `Ry` (Copiar entre registros)
  1. **`Rx` $\leftarrow$ `Ry`**:
  El contenido del registro `Ry` se copia en el registro `Rx`.

* MOV `Rx`, `[Dirección]` (Cargar a registro)
  1. **`MAR` $\leftarrow$ `IP`**:
  El valor del `IP` se transfiere a `MAR`.
  2. **`MBR` $\leftarrow$ `read(Memoria[MAR])`; `IP` $\leftarrow$ `IP` + 1**:
  Se lee (read) de memoria el contenido de la dirección indicada por `MAR` y se almacena en `MBR`.Simultáneamente, el `IP` se incrementa.
  3. **`MAR` $\leftarrow$ `MBR`**:
  El contenido de `MBR` se transfiere a `MAR`.
  4. **`MBR` $\leftarrow$ `read(Memoria[MAR])`**:
  Se lee de memoria el contenido de la dirección indicada por `MAR` y se almacena en `MBR`.
  5. **`Rx`  $\leftarrow$ `MBR`**:
  El contenido del `MBR` se copia al registro `Rx`.

* MOV `[Dirección]`, `Ry` (Almacenar en memoria)     
  1, 2, 3. Igual que MOV `Rx`, `[Dirección]`.
  4. **`MBR` $\leftarrow$ `Ry`**:
  El contenido de `Ry` se transfiere a `MBR`.
  5. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**:
  El contenido de `MBR` se escribe (write) en memoria en la dirección apuntada por el `MAR`.

* ADD  `Rx`, `[Dirección]` (Sumar a registro)
  1, 2, 3, 4. Igual que MOV `Rx`, `[Dirección]`.
  5. **`Rx`  $\leftarrow$ `Rx` + `MBR`**:
  La Unidad Aritmético-Lógica (ALU) realiza la suma entre `Rx` y `MBR`, almacenando el resultado en `Rx`. El Registro de Estado `RS` se actualiza con los indicadores correspondientes.

* SUB `[Dirección]`, `Ry` (Restar a memoria)
  1, 2, 3, 4. Igual que MOV `Rx`, `[Dirección]`.
  5. **`MBR` $\leftarrow$ `Ry` - `MBR`**: 
  La ALU resta el contenido de `MBR` al de `Ry`, almacenando el resultado en `MBR`. El `RS` se actualiza.
  6. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**:
  El contenido de `MBR` se escribe en memoria en la dirección apuntada por el `MAR`.

* CMP `Rx`,  `[Dirección]` (Comparar a registro)
  1, 2, 3, 4. Igual que MOV `Rx`, `[Dirección]`.
  5. **`Rx` - `MBR`**: 
  La ALU realiza la resta entre el contenido de `Rx` y `MBR`. Aunque el resultado no se almacena, el `RS` se actualiza con los indicadores de comparación.

* JMP  `Dirección` (Salto incondicional)
  1, 2. Igual que MOV `Rx`, `[Dirección]`.
  3. **`IP` $\leftarrow$ `MBR`**:
  El contenido del `MBR` se transfiere al registro `IP`, estableciendo la nueva dirección de ejecución.

## Pruebas
Una vez diseñada la herramienta, es fundamental construirla y someterla a pruebas exhaustivas para garantizar que cumpla con los requisitos definidos y sea fácil de usar. Durante esta fase, se identifican y corrigen los posibles problemas antes de su implementación definitiva.

Se llevarán a cabo pruebas rigurosas que abarcarán los siguientes aspectos:

- Validación de funcionalidad: Verificar que todas las características y funcionalidades de la herramienta operen correctamente según los requisitos establecidos.
- Evaluación de usabilidad: Obtener retroalimentación de estudiantes y profesores para garantizar que la herramienta sea intuitiva y fácil de utilizar en el contexto educativo.
- Corrección de problemas: Identificar y resolver cualquier error o inconsistencia antes del lanzamiento oficial de la herramienta.

## Portabilidad
Con el objetivo de garantizar la portabilidad, el simulador se implementará como una aplicación web. Esta decisión permite su ejecución en cualquier navegador y asegura su compatibilidad multiplataforma, independientemente del sistema operativo utilizado por los usuarios.

## Mantenibilidad
El diseño del código se enfocará en la modularidad y la documentación detallada. Este enfoque facilita futuras actualizaciones, la corrección de errores y el mantenimiento general de la herramienta. Asimismo, se aplicarán prácticas de desarrollo sostenible para garantizar su viabilidad a largo plazo.

## Escalabilidad
En la asignatura, se promueve el uso de simuladores como apoyo en los procesos de enseñanza y aprendizaje. Además, se fomenta que los contenidos desarrollados puedan implementarse en máquinas reales. En este sentido, el enfoque propuesto por herramientas como emu8086 es relevante, ya que permite implementar programas en sistemas reales.

Sin embargo, emu8086 presenta ciertas limitaciones: genera ejecutables dependientes del sistema operativo MS-DOS, lo cual resulta problemático dado que la mayoría de los sistemas operativos actuales no admiten la ejecución nativa de dichos programas. Esto obliga al uso de emuladores de MS-DOS, añadiendo complejidad a los procesos educativos.

Para superar estas limitaciones, se propone utilizar el ensamblador NASM (Netwide Assembler), que ofrece compatibilidad tanto con Linux como con Windows a través de herramientas libres como GCC (GNU Compiler Collection). Esto permite generar programas para la arquitectura x86 en sus variantes de 16, 32 y 64 bits, asegurando mayor flexibilidad y escalabilidad en los entornos educativos actuales.
