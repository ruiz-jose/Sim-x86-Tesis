# Diseño y construcción del simulador {#desarrollo}
En este capítulo se describe el diseño y desarrollo de una herramienta de simulación específica para la arquitectura x86, orientada a facilitar la enseñanza de los principios de arquitectura de computadoras. Se detalla la justificación del diseño, los pasos seguidos para su construcción y los métodos utilizados para validar su funcionalidad.

En el capítulo anterior se analizaron y evaluaron las herramientas de simulación existentes para la arquitectura x86. Esta revisión exhaustiva permitió identificar las limitaciones de las soluciones actuales y fundamentar la necesidad de desarrollar una herramienta específica (véase el capítulo \@ref(comparativa)).

A partir de esta necesidad, se establecieron un conjunto de requisitos funcionales y pedagógicos que guiaron de manera integral el diseño, la implementación y la validación del simulador. Estos requisitos no solo responden a las limitaciones observadas en herramientas existentes, sino que se alinean con los objetivos educativos previamente definidos.

## Requisitos de la herramienta
Esta sección expone los requisitos que orientaron el diseño del simulador, clasificados en dos dimensiones complementarias: pedagógica y funcional. La primera se vincula con los objetivos formativos definidos en el capítulo introductorio (\@ref(intro)), mientras que la segunda refiere a las características técnicas necesarias para garantizar su implementación eficaz. La definición de los requisitos se apoyó en principios pedagógicos y técnicos, complementados con una validación empírica realizada mediante entrevistas semiestructuradas a docentes expertos (ver Apéndice: Anexo A \@ref(anexoA)). Estas entrevistas revelaron, entre otros aspectos, la necesidad de incorporar visualizaciones gráficas del ciclo de instrucción, soporte para interrupciones y periféricos, y un repertorio reducido de instrucciones con activación progresiva, para evitar la sobrecarga cognitiva en los estudiantes. Asimismo, se identificaron limitaciones en herramientas existentes, como el Emu8086, cuya interfaz y funcionalidades no satisfacen completamente las necesidades pedagógicas. Este proceso permitió identificar necesidades auténticas del aula y carencias específicas en las herramientas existentes, aportando una base empírica rigurosa para la formulación pedagógica y técnica de los requisitos [@huberman2019qualitative].

1. **Visualización de la estructura general de la computadora:**
Representar gráficamente la CPU, los buses, la memoria y los dispositivos de entrada/salida. Esta visualización debe destacar los componentes activos en cada etapa del ciclo de ejecución, facilitando una comprensión sistémica e integrada del funcionamiento de la computadora [@w3c_accessibility_2021]. El uso de representaciones gráficas como recurso didáctico está respaldado por estudios que demuestran su efectividad para facilitar la comprensión de conceptos abstractos en disciplinas técnicas [@sorva2013visualizations]. La Figura \@ref(fig:diagramasimulador) ilustra la estructura general del simulador, esta representación gráfica facilita la comprensión de cómo los componentes del simulador trabajan en conjunto durante la ejecución de un programa.

```{r diagramasimulador, echo=FALSE, fig.cap="Estructura general del simulador VonSim8", fig.align = 'right', out.width = "93%"}
knitr::include_graphics("images/estructurasimulador.png")
```

2. **Soporte para la generación y ejecución de programas en ensamblador:**
Incorporar la posibilidad de ejecutar programas escritos en lenguaje ensamblador tanto de forma paso a paso como en ejecución continua. Esta funcionalidad posibilita el análisis detallado de cada instrucción, fortaleciendo competencias en trazado y depuración de código ensamblador, fundamentales para comprender la relación entre software y hardware.
Para apoyar este proceso, se propone la inclusión de un editor de ensamblador que incorpore funciones como resaltado de sintaxis y autocompletado. Estas características mejoran la experiencia del usuario y facilitan la escritura y comprensión del código, en consonancia con principios de diseño de interfaces que priorizan la usabilidad y la accesibilidad [@w3c_accessibility_2021]. El editor debe permitir al usuario escribir, editar, guardar y ejecutar programas en ensamblador dentro del simulador, además de ofrecer ejemplos predefinidos como apoyo didáctico. La incorporación de entornos de desarrollo integrados (IDEs) en contextos educativos ha demostrado ser eficaz para la enseñanza de lenguajes de programación, según diversos estudios [@mccracken2001does].

```{r editor, echo=FALSE, fig.cap="Editor ensamblador", fig.align = 'center', out.width = "100%"}
knitr::include_graphics("images/editor.png")
```

3. **Repertorio reducido de instrucciones con activación progresiva:**
Se selecciona un subconjunto esencial del conjunto de instrucciones x86, el cual se habilita de manera secuencial a lo largo del proceso de enseñanza, en estrecha correspondencia con el avance de los contenidos curriculares. Esta decisión responde a principios de la psicología cognitiva, que sostienen que la introducción gradual de contenidos técnicos favorece la retención y disminuye la sobrecarga cognitiva [@nationalacademies2018how]. Diversos autores, como Hasan [@hasan_survey_2012], Null y Lobur [@null_essentials_2023], y Stallings [@stallings_computer_2021], respaldan este enfoque, recomendando la incorporación escalonada de conceptos en la enseñanza de arquitecturas complejas.
La activación progresiva del repertorio de instrucciones promueve el desarrollo paulatino de competencias, evitando que los estudiantes se enfrenten prematuramente a la totalidad del conjunto instruccional. Este método se fundamenta en teorías de aprendizaje que destacan los beneficios de la exposición gradual a nuevos conceptos para mejorar la comprensión y la retención [@sweller2010cognitive]. En la siguiente tabla \@ref(tab:activacionprogresiva) se resume la activación progresiva de instrucciones y sus objetivos didácticos asociados.

```{r activacionprogresiva, echo=FALSE, message=FALSE, warning=FALSE}
    library(knitr)
    library(kableExtra)

    # Crear los datos de la tabla de activación progresiva
    activacionprogresiva <- data.frame(
      Fase = c("Inicial", "Intermedia", "Avanzada"),
      `Instrucciones activadas` = c(
        "MOV, ADD, SUB, HLT",
        "CMP, JMP, Jxx",
        "CALL, RET, INT, IRET, CLI, STI, IN, OUT, POP, PUSH"
      ),
      `Objetivo didáctico` = c(
        "Comprensión del ciclo de instrucción básico",
        "Introducción a control de flujo",
        "Manejo de periféricos e interrupciones"
      )
    )

    tabla_activacion <- kable(activacionprogresiva,
                  format = ifelse(knitr::is_latex_output(), "latex", "html"),
                  caption = "Activación progresiva del repertorio de instrucciones",
                  col.names = c("Fase", "Instrucciones activadas", "Objetivo didáctico"),
                  booktabs = TRUE,
                  escape = FALSE,
                  align = c("c", "c", "c"))

    if (knitr::is_latex_output()) {
      tabla_activacion %>%
        kable_styling(
          latex_options = c("scale_down", "hold_position"),
          font_size = 10,
          position = "right"
        ) %>%
        column_spec(1, width = "2cm", bold = TRUE, border_right = TRUE) %>%
        column_spec(2, width = "4cm") %>%
        column_spec(3, width = "6cm") %>%
        row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
        row_spec(seq_len(nrow(activacionprogresiva)),
                 extra_latex_after = "\\addlinespace[10pt]")
    } else {
      tabla_activacion %>%
        kable_styling(
          bootstrap_options = c("striped", "hover", "condensed", "responsive"),
          full_width = FALSE,
          position = "center"
        ) %>%
        column_spec(1, width = "12em", bold = TRUE, border_right = TRUE) %>%
        column_spec(2:3, width = "28em") %>%
        row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
  }
```

4. **Simulación visual e interactiva de micropasos de instrucciones:**
Se implementa una visualización interactiva del flujo de datos basada en el modelo de Nivel de Transferencia entre Registros (Register Transfer Level, RTL). Este enfoque permite representar con precisión el desplazamiento de datos entre registros, buses y unidades funcionales del procesador, así como las señales de control involucradas en cada fase del ciclo de instrucción [@ASMVisualizer2025; @harris2015digital]. Stallings [@stallings_computer_2021] propone utilizar el modelo RTL para representar el ciclo de instrucción, desde la captura (fetch) hasta la ejecución (execute), facilitando la visualización del recorrido de datos y señales de control en cada etapa del proceso.
Como complemento a la descripción anterior, la Figura \@ref(fig:cicloinstruccion) muestra un ciclo de instrucción típico utilizando la operación `MOV AL, BL`. En la etapa de captación (*fetch*), la dirección de la instrucción se carga desde el registro `IP` al `MAR`, y el contenido de la memoria se transfiere al `MBR` y luego al `IR` . En la etapa de ejecución (*execute*), los datos se mueven desde el registro `BL` al registro `AL`.

```{r cicloinstruccion, echo=FALSE, fig.cap="Ciclo de instrucción: captación y ejecución", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/cicloinstruccion.png")
```

5. **Gestión básica de interrupciones y periféricos:**
Incluir un vector de interrupciones predefinido que simule eventos externos, como la entrada de datos mediante teclado o la salida de información a través de un monitor. El vector de interrupciones predefinido permite simular eventos externos, como la entrada de datos mediante teclado. Por ejemplo, al recibir una interrupción de teclado, el simulador activa la señal `INTR`, detiene la ejecución actual y transfiere el control a la rutina de tratamiento de interrupciones correspondiente. Desde el punto de vista pedagógico, esta funcionalidad ofrece al estudiante la posibilidad de explorar de manera interactiva conceptos clave como la asincronía, el manejo de eventos y la interrupción del flujo secuencial, todos ellos característicos del diseño de arquitecturas modernas y fundamentales para el entendimiento de sistemas reales. Su inclusión se alinea con las recomendaciones de autores como Null y Lobur [@null_essentials_2023], quienes destacan el valor de abordar estos conceptos en etapas tempranas de la formación. Además, se incorpora un módulo genérico de entrada/salida programada (Programmed Input/Output, PIO), que actúa como interfaz entre la CPU y los dispositivos periféricos. Este módulo permite simular operaciones mediante instrucciones como IN y OUT, facilitando la interacción del estudiante con dispositivos representados gráficamente, como interruptores y teclas. De esta forma, se promueve una comprensión más tangible de los mecanismos subyacentes al intercambio de información entre el procesador y los dispositivos externos.

```{r perifericos, echo=FALSE, fig.cap="Módulo genérico de entrada/salida programada", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/perifericos.png")
```

6. **Métricas de rendimiento:**
Incluir indicadores clave como tiempo de ciclo, tiempo de CPU y ciclos por instrucción (CPI), generados automáticamente a partir de la ejecución de los programas. Asimismo, se permite configurar la frecuencia del CPU dentro de un rango de valores (1–10 Hz). Estos indicadores permiten al estudiante analizar cuantitativamente la eficiencia en la ejecución de un programa, facilitando comparaciones entre diferentes implementaciones. Su inclusión apunta a fortalecer la comprensión de aspectos clave del rendimiento del procesador, promoviendo una formación integral que contemple tanto aspectos funcionales como métricos del comportamiento del sistema [@hennessy2017computer].

```{r metricas, echo=FALSE, fig.cap="Métricas de rendimiento", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/metricas.png")
```

7. **Documentación y recursos de apoyo:**
Proporcionar documentación clara y accesible que explique el funcionamiento del simulador, sus componentes y las instrucciones disponibles. Esta documentación debe incluir ejemplos prácticos, guías de uso y recursos adicionales para facilitar la comprensión y el aprendizaje autónomo. La inclusión de tutoriales interactivos y ejemplos prácticos es fundamental para guiar al estudiante en el uso efectivo del simulador, promoviendo un aprendizaje activo y reflexivo [@bonwell1991active].

```{r documentacion, echo=FALSE, fig.cap="Documentación on line", fig.align = 'center', out.width = "90%"}
knitr::include_graphics("images/documentacion.png")
```

En conjunto, estos requisitos constituyen la base del diseño del simulador, garantizando tanto su pertinencia pedagógica como su viabilidad técnica. Su formulación responde a la necesidad de contar con un recurso didáctico que facilite la enseñanza y el aprendizaje de la arquitectura x86, integrando aspectos visuales, interactivos y de análisis del rendimiento. La Tabla \@ref(tab:requisitosresumen) presenta un resumen de los principales requisitos funcionales, junto con su fundamentación pedagógica y técnica.

```{r requisitosresumen, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear los datos de la tabla de requisitos y fundamento
requisitosresumen <- data.frame(
  Requisito = c(
    "Visualización de estructura general",
    "Soporte para programas en ensamblador",
    "Repertorio reducido y activación progresiva",
    "Simulación visual de micropasos (RTL)",
    "Gestión de interrupciones y periféricos",
    "Métricas de rendimiento",
    "Documentación y recursos de apoyo"
  ),
  Fundamento = c(
    "Facilita comprensión sistémica mediante representaciones gráficas de hardware.",
    "Desarrolla competencias en trazado y depuración de lenguaje ensamblador; mejora usabilidad.",
    "Disminuye sobrecarga cognitiva al introducir instrucciones de manera escalonada.",
    "Permite comprender el flujo interno de datos y señales de control durante el ciclo de instrucción.",
    "Simula asincronía y manejo de eventos, favoreciendo la comprensión de sistemas reales.",
    "Promueve análisis cuantitativo de eficiencia (CPI, ciclos, tiempo de CPU).",
    "Fomenta aprendizaje autónomo y activo mediante guías, tutoriales y ejemplos."
  )
)

tabla_requisitos <- kable(requisitosresumen,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Resumen de requisitos funcionales y su fundamentación pedagógica",
               col.names = c("Requisito", "Fundamento pedagógico / técnico"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c"))

if (knitr::is_latex_output()) {
      tabla_requisitos %>%
        kable_styling(
          latex_options = c("scale_down", "hold_position"),
          font_size = 10
        ) %>%
        column_spec(1, width = "5cm", bold = TRUE, border_right = TRUE) %>%
        column_spec(2, width = "8cm") %>%
        row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
        row_spec(seq_len(nrow(requisitosresumen)),
                 extra_latex_after = "\\addlinespace[10pt]")
    } else {
      tabla_requisitos %>%
        kable_styling(
          bootstrap_options = c("striped", "hover", "condensed", "responsive"),
          full_width = FALSE,
          position = "center"
        ) %>%
        column_spec(1, width = "16em", bold = TRUE, border_right = TRUE) %>%
        column_spec(2, width = "32em") %>%
        row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
    }
```

La definición de los requisitos funcionales y pedagógicos permitió identificar la necesidad de simplificar la arquitectura x86 para adaptarla a los objetivos educativos. Esta simplificación asegura que los estudiantes puedan concentrarse en los conceptos fundamentales sin verse abrumados por la complejidad técnica. A continuación, se detalla la justificación de esta decisión.

## Justificación pedagógica de la arquitectura simplificada
A partir de los requisitos funcionales detallados anteriormente, se realizó un proceso colaborativo de análisis con docentes^[Docentes: Marcelo A. Colombani y Amalia G. Delduca] a cargo de la asignatura Arquitectura de Computadoras. Su experiencia permitió identificar los elementos de la arquitectura x86 que debían representarse, simplificarse o adaptarse según los objetivos pedagógicos del simulador. Como resultado, se optó por una arquitectura simplificada de 8 bits, cuya elección se justifica por su valor didáctico: reduce la complejidad del modelo sin comprometer la enseñanza de conceptos esenciales como el ciclo de instrucciones, la manipulación de registros o la gestión de interrupciones. Esta simplificación permite representar procesos clave con mayor claridad y menor carga cognitiva, favoreciendo la comprensión de los estudiantes en las etapas iniciales del aprendizaje.

La arquitectura x86 se distingue por su elevada complejidad, derivada de su extenso repertorio de instrucciones y sus múltiples características avanzadas. En respuesta, el diseño del simulador se fundamenta en tres principios pedagógicos centrales:

- **Reducir la carga cognitiva**: simplificar el repertorio y los componentes permite a los estudiantes enfocarse en los principios fundamentales.  
- **Aprendizaje progresivo**: se adopta un enfoque escalonado, comenzando con un modelo simple y avanzando hacia representaciones más completas de x86.  
- **Claridad pedagógica**: las prácticas resultan manejables en términos de tiempo y esfuerzo, favoreciendo un aprendizaje activo y centrado en la resolución progresiva de problemas.  

En este marco, el diseño del simulador contribuye a:  

- **Comprensión fundamental**: los estudiantes pueden concentrarse en el ciclo de instrucciones, la interacción de componentes y el flujo básico de datos.  
- **Análisis crítico**: comparar el modelo simplificado con la arquitectura x86 real favorece un aprendizaje más reflexivo y profundo.  
- **Experimentación práctica**: proporciona un entorno accesible para explorar conceptos y corregir errores.  

Diversos autores como Patterson & Hennessy [@hennessy2017computer], Tanenbaum [@tanenbaum_structured_2016] y Null [@null_essentials_2023] coinciden en que el uso de arquitecturas simplificadas, como las de 8 bits, permite a los estudiantes centrarse en los fundamentos de la arquitectura de computadoras sin verse abrumados por la complejidad técnica de arquitecturas reales. Este enfoque hace posible observar la transferencia de datos entre registros y la activación de señales de control en cada etapa, facilitando la comprensión del funcionamiento interno del procesador.  

El modelo propuesto se inspira en los principios de la arquitectura x86 [@intel_microarchitecture_2021], pero implementa un repertorio reducido de instrucciones en una arquitectura de 8 bits. Esta elección responde a criterios pedagógicos: simplifica el modelo sin sacrificar los principios esenciales del repertorio x86, y facilita una comprensión progresiva de sus componentes [@patt2019introduction; @majid1999design; @morlan_sap1_2021; @Guald_2015_thesis; @silber_tinycpu].  

Aunque la simplificación a 8 bits reduce la fidelidad del modelo respecto a la arquitectura x86 real, esta decisión permite a los estudiantes concentrarse en los principios fundamentales, como el ciclo de instrucciones y la interacción entre registros. Para abordar esta limitación, el simulador incluye funcionalidades avanzadas que pueden activarse progresivamente, como la gestión de interrupciones y el repertorio completo de instrucciones.

En síntesis, la definición de estos requisitos integra aspectos funcionales, pedagógicos y técnicos en una herramienta que no solo simula el comportamiento del sistema, sino que además facilita activamente los procesos de enseñanza y aprendizaje en arquitectura de computadoras. La combinación entre visualización, ejecución progresiva y análisis de rendimiento ofrece un entorno didáctico rico que responde tanto a las necesidades del aula como a los desafíos de la disciplina.

## Introducción a VonSim
VonSim^[VonSim: https://vonsim.github.io/] [@vonsim] es una herramienta diseñada específicamente para la enseñanza y el aprendizaje de la arquitectura y organización de computadoras, que sirvió de referencia por su enfoque educativo e interfaz intuitiva. A partir de esta herramienta se desarrolló VonSim8^[VonSim8: https://ruiz-jose.github.io/VonSim8/], adaptado para operar con registros y memoria de 8 bits, y diseñado para favorecer el aprendizaje progresivo.

VonSim ofrece una arquitectura detallada con un amplio repertorio de instrucciones y componentes. Aunque esta riqueza funcional es valiosa, puede resultar abrumadora para estudiantes en etapas iniciales. Por esta razón, VonSim8 implementa una simplificación estratégica para reducir la carga cognitiva en los primeros niveles de aprendizaje, promoviendo una asimilación progresiva de los conceptos fundamentales de la arquitectura de computadoras. A partir de esta base, se introdujeron diversas modificaciones en los componentes, instrucciones y funcionalidades del simulador, priorizando aquellos aspectos conceptuales que se abordan en el programa de la asignatura.

Las siguientes características posicionan a VonSim como una solución educativa integral:

1. **Entorno integrado de desarrollo y simulación:** incluye un editor de código ensamblador con resaltado de sintaxis y un simulador para la ejecución de programas, facilitando el aprendizaje práctico. [@vonsim].

2. **Fundamento en arquitectura real:** basado en el procesador Intel 8088, ofrece una referencia histórica y técnicamente relevante. [@intel8086manual].

3. **Componentes esenciales para el estudio:** incorpora cuatro registros multipropósito de 16 bits, memoria principal de 32 kB, bus de direcciones de 16 bits y bus de datos de 8 bits, entre otros. [@stallings_computer_2021].

4. **Gestión completa de interrupciones:** Implementa tanto interrupciones por software (entrada/salida de datos) como interrupciones por hardware mediante un controlador de interrupciones programable (PIC), cubriendo aspectos fundamentales de la operación del sistema [@hennessy2017computer].

5. **Simulación de periféricos:** incorpora dispositivos como reloj, llaves, luces e impresora, inspirados en los especificados por la familia iAPX 88 de Intel, permitiendo simular interacciones complejas con el sistema.

6. **Enfoque pedagógico mediante simplificaciones estratégicas:** no pretende ser un emulador fiel del 8088, sino una herramienta educativa que implementa simplificaciones deliberadas (repertorio de instrucciones reducido y codificación simplificada) para facilitar la comprensión en contextos educativos [@patt2019introduction].

7. **Desarrollo académico especializado:** fue creado por Facundo Quiroga, Manuel Bustos Berrondo y Juan Martín Seery, con la colaboración de Andoni Zubimendi y César Estrebou, específicamente para las cátedras de Organización de Computadoras y Arquitectura de Computadoras de la Facultad de Informática de la Universidad Nacional de La Plata, garantizando su alineación con objetivos curriculares específicos.

8. **Fundamento en experiencia previa:** se basa en el simulador MSX88, desarrollado en 1988 por Rubén de Diego Martínez para la Universidad Politécnica de Madrid, aprovechando décadas de experiencia acumulada en simuladores educativos.

9. **Accesibilidad y sostenibilidad:** distribuido bajo licencia GNU Affero General Public License v3.0 con código fuente disponible en GitHub, y documentación bajo licencia CC BY-SA 4.0, facilitando su estudio, modificación y mejora continua [@opensource_licensing_2024].

### Stack tecnológico
El proyecto VonSim está desarrollado íntegramente en TypeScript, lo que permite aprovechar el tipado estático, lograr mayor robustez del código y contar con mejor soporte para autocompletado y detección temprana de errores durante el desarrollo.

La organización del código sigue una arquitectura de monorepositorio, compuesto por diversos paquetes especializados que cumplen funciones específicas:

  - vonsim/assembler: ensamblador que traduce el código en lenguaje ensamblador a binario ejecutable.
  - vonsim/simulator: motor que ejecuta los programas ensamblados.
  - vonsim/app: aplicación web que proporciona la interfaz gráfica de usuario e integra el simulador.
  - vonsim/common: utilidades compartidas entre los distintos módulos.
  - eslint-config-vonsim: paquete para la configuración de reglas de estilo y buenas prácticas mediante ESLint.
  - vonsim/scripts y vonsim/tsconfig: paquetes de soporte con scripts de desarrollo y configuraciones específicas para TypeScript.
  - vonsim/docs: módulo destinado a la gestión de la documentación del proyecto.

Para el desarrollo y la ejecución del proyecto se utilizan herramientas modernas como Node.js v22 y el gestor de paquetes pnpm v10. Asimismo, el repositorio incluye una serie de scripts predefinidos para facilitar las tareas de instalación, compilación y despliegue: pnpm install, pnpm dev, pnpm docs:dev y pnpm build.

## Estructura y componentes de VonSim8
En esta sección se describe la estructura del simulador VonSim8. El diseño de los registros se concibió con un propósito pedagógico: facilitar la comprensión de los modos de direccionamiento y del ciclo de instrucción, elementos fundamentales en el estudio de la Arquitectura de Computadoras [@stallings_computer_2021]. En la tabla \@ref(tab:estructuravonsim8) se describen los componentes principales del simulador, junto con sus características y funcionalidades específicas. Esta tabla proporciona una visión general de la arquitectura del simulador, destacando los elementos clave que componen su estructura:

```{r estructuravonsim8, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Definición mejorada del data frame
estructuravonsim8 <- data.frame(
  `Componente` = c(
    "Arquitectura",
    "Registros generales",
    "Registros específicos",
    "Acceso a registros",
    "Memoria",
    "Puertos"
  ),
  `Características` = c(
    "Von Neumann: memoria compartida para datos e instrucciones.",
    "4 registros de propósito general de 8 bits (`AL`, `BL`, `CL`, `DL`).",
    if (knitr::is_latex_output()) {
      "6 registros de propósito específico:\\begin{itemize} \\item IP (Instruction Pointer) \\item IR (Instruction Register) \\item SP (Stack Pointer) \\item Flags (registro de estado) \\item MAR (Memory Address Register) \\item MBR (Memory Buffer Register)\\end{itemize}"
    } else {
      "6 registros de propósito específico:<ul>
      <li>`IP` (Instruction Pointer)</li>
      <li>`IR` (Instruction Register)</li>
      <li>`SP` (Stack Pointer)</li>
      <li>`Flags` (registro de estado)</li>
      <li>`MAR` (Memory Address Register)</li>
      <li>`MBR` (Memory Buffer Register)</li>
      </ul>"
    },
    "Los registros de propósito general pueden ser accedidos y modificados por el programador. Los específicos son gestionados por la CPU.",
    "Memoria principal de 256 bytes, direccionada por un bus de direcciones de 8 bits. Cada posición almacena un byte. La memoria se organiza en celdas de 16 bytes, con dirección inicial `0x00h` y final `0xFFh`.",
    if (knitr::is_latex_output()) {
      "Puertos de la CPU:\\begin{itemize} \\item Bus de direcciones de 8 bits (MAR) \\item Bus de datos de 8 bits (MBR) \\item Señal de lectura (rd) y escritura (wr), cada una de 1 bit \\item Señal IO/M (1 bit) para distinguir acceso a memoria o E/S \\item Señal de petición de interrupción (INTR, 1 bit) \\item Señal de reconocimiento de interrupción (INTA, 1 bit)\\end{itemize}"
    } else {
      "Puertos de la CPU:<ul>
      <li>Bus de direcciones de 8 bits, gestionado por el buffer <code>MAR</code>.</li>
      <li>Bus de datos de 8 bits, gestionado por el buffer <code>MBR</code>.</li>
      <li>Señal de lectura (<code>rd</code>) y escritura (<code>wr</code>), cada una de 1 bit.</li>
      <li>Señal <code>IO/M</code> (1 bit) para distinguir acceso a memoria o E/S.</li>
      <li>Señal de petición de interrupción (<code>INTR</code>, 1 bit).</li>
      <li>Señal de reconocimiento de interrupción (<code>INTA</code>, 1 bit).</li>
      </ul>"
    }
  ),
  stringsAsFactors = FALSE
)

tabla <- kable(
  estructuravonsim8,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Estructura VonSim8: componentes principales y características",
  col.names = c("Componente", "Características"),
  booktabs = TRUE,
  escape = FALSE
)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "12cm", latex_column_spec = "p{12cm}") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(estructuravonsim8)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "25em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "60em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Entre los registros específicos, no accesibles directamente por el programador, se incluyen los siguientes:  

- **`SP` (_Stack Pointer_)**: Responsable de la gestión de la pila, permitiendo el seguimiento de las direcciones de memoria asociadas a las operaciones de apilamiento y desapilamiento.  
- **`Flags` (_Flags Register_)**: Registro que almacena las banderas de estado, utilizadas para reflejar el resultado de operaciones aritméticas y lógicas, así como para controlar el flujo del programa.  
- **`IP` (_Instruction Pointer_)**: Contiene la dirección de memoria de la próxima instrucción a ejecutar, asegurando la secuenciación correcta del programa.  
- **`IR` (_Instruction Register_)**: Almacena el byte correspondiente a la instrucción que está siendo decodificada y ejecutada en el momento.  

Adicionalmente, se disponen de dos registros esenciales para la transferencia de datos entre la CPU y la memoria principal:  

- **`MAR` (_Memory Address Register_)**: Encargado de almacenar las direcciones de memoria que se desean acceder.  
- **`MBR` (_Memory Buffer Register_)**: Almacena temporalmente el byte de datos que se transfiere hacia o desde la memoria principal a través del bus de datos.  

Adicionalmente, se incluyen dos registros auxiliares: `ri`, destinado al almacenamiento temporal de direcciones, e `id`, orientado al almacenamiento temporal de datos. Estos registros cumplen una función de apoyo en la ejecución de instrucciones. 

### Unidad de Control
La unidad de control es responsable de coordinar todas las operaciones de la CPU. Se encarga de:

- **Decodificación de instrucciones**: Interpreta el código de operación de cada instrucción.
- **Generación de señales de control**: Activa las señales necesarias para ejecutar microoperaciones.
- **Secuenciación**: Controla el orden de ejecución de las operaciones.

#### Memoria de Control
La memoria de control almacena microinstrucciones que guían la ejecución de cada instrucción en el simulador. Una representación visual de esta memoria, organizada en filas (microinstrucciones) y columnas (microoperaciones y señales de control), facilita la comprensión del papel que desempeña en la coordinación de la unidad de control [@stallings_computer_2021].

#### Secuenciador
El secuenciador complementa la memoria de control mostrando cómo se controla la secuencia de microoperaciones y las señales de control generadas en cada fase del ciclo de instrucción.

### Unidad Aritmético-Lógica (ALU)
La ALU (_Arithmetic Logic Unit_) realiza operaciones aritméticas y lógicas, como `ADD` y `SUB`. Durante el ciclo de instrucción, la unidad de control genera señales específicas que activan las operaciones de la ALU. Por ejemplo, al ejecutar una instrucción `ADD`, la unidad de control activa las señales necesarias para transferir los operandos desde los registros hacia la ALU y almacenar el resultado en el registro de destino. Todas estas operaciones modifican el registro `Flags`.

#### Registro de Banderas (Flags)
El registro de banderas `Flags`  almacena las banderas de estado que reflejan el resultado de operaciones aritméticas y lógicas. Por ejemplo, después de una operación de suma, la bandera `Z` (Zero) se activa si el resultado es cero, lo que permite al procesador tomar decisiones condicionales basadas en este estado.

```{r tflags, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

tflags <- data.frame(
  `Bit` = c(0, 1, 2, 3, 4),
  Abreviatura = c("Z", "C", "O", "S", "I"),
  Descripción = c(
    "Flag de cero (Zero)",
    "Flag de acarreo (Carry)",
    "Flag de desbordamiento (Overflow)",
    "Flag de signo (Sign)",
    "Flag de interrupción (Interrupt)"
  )
)

tabla_kable <- kable(
  tflags,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Registro Flags: descripción de las banderas",
  col.names = c("Bit N°", "Abreviatura", "Descripción"),
  booktabs = TRUE,
  escape = FALSE,
  align = c("c", "c", "l")
)

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "2cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "3cm") %>%
    column_spec(3, width = "7cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tflags)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "6em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "10em") %>%
    column_spec(3, width = "22em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Los bits restantes del registro Flags se encuentran reservados para posibles extensiones del simulador y no están en uso en la versión actual.

### Memoria principal
La memoria principal se modela como una matriz de 16×16 expresada en formato hexadecimal, lo que permite almacenar hasta 256 bytes de datos. Esta capacidad resulta suficiente para la mayoría de los programas de ejemplo utilizados en el curso, y su diseño simplificado facilita la comprensión de los conceptos fundamentales asociados a la memoria principal en una computadora.

```{r memoria, echo=FALSE, fig.cap="Memoria principal", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/memoria.png")
```

### Buses y multiplexores
Los buses de datos, direcciones y control se modelan como un conjunto de líneas que permiten la comunicación entre los distintos componentes del sistema. Estos buses resultan esenciales para el intercambio de información entre la CPU, la memoria y los dispositivos de entrada/salida. Además, su diseño modular favorece la posibilidad de expansión en futuras versiones del simulador.

```{r buses, echo=FALSE, fig.cap="Buses", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/buses.png")
```

Dentro de los buses internos de la CPU se incluyen representaciones gráficas de multiplexores, componentes digitales esenciales que permiten seleccionar entre múltiples fuentes de datos o direcciones durante el ciclo de instrucción. Los multiplexores dirigen las señales hacia los registros y la ALU (Unidad Aritmético-Lógica), facilitando el flujo de datos dentro del procesador. Un multiplexor (MUX) funciona como un conmutador digital que conecta datos de una de n fuentes a la salida. Están dotados de entradas de control capaces de seleccionar una y solo una de las entradas de datos para permitir su transmisión desde la entrada seleccionada hacia dicha salida [@mano2017digital].

## Adaptaciones y mejoras en VonSim8 {#mejoras-vonsim8}
Si bien VonSim ofrece una base sólida para la enseñanza de arquitectura de computadoras, su complejidad funcional puede resultar abrumadora para estudiantes en etapas iniciales. Por esta razón, se implementaron modificaciones estratégicas en VonSim8, orientadas a simplificar el modelo y alinearlo con los objetivos pedagógicos de la asignatura. A continuación, se describen las principales mejoras realizadas.

Las modificaciones implementadas se alinean con los contenidos curriculares de la asignatura y están fundamentadas en los principios del aprendizaje activo [@bonwell1991active].

  1. Simplificación del repertorio instruccional para una introducción gradual;
  2. Reducción a registros y memoria de 8 bits, coherente con la escala de enseñanza;
  3. Interfaz gráfica esquemática que muestra el flujo de ejecución;
  4. Funciones interactivas para observar explícitamente el ciclo de instrucción y la interacción de componentes;
  5. Ocultamiento inicial de las banderas O (overflow) y S (signo), y visualización dinámica de la bandera I (interrupciones);
  6. Menú de controles modificado y adaptado al uso pedagógico;
  7. Registros con entrada y salida independientes; ocultamiento automático de SP, ri e id;
  8. Eliminación de los registros temporales left, right y result en la ALU;
  9. Resaltado dinámico en memoria de las posiciones apuntadas por IP y SP;
  10. Vector de interrupciones de 8 posiciones (0x00h–0x07h) y mapeo directo INT→dirección;
  11. Visor de instrucciones y datos del programa, con tamaño en bytes y etiquetas;
  12. Compatibilidad con directivas ORG y END (por defecto 0x00h o 0x08h; compatibilidad con org 0x20h);
  13. Decodificador con memoria de control y secuenciador para microoperaciones y señales de control;
  14. Tour de aprendizaje, centro de ayuda y ejemplos integrados.

A continuación se detallan los cambios más relevantes implementados en VonSim8, junto con capturas de pantalla que ilustran las modificaciones realizadas:

En el registro Flags de VonSim se ocultaron inicialmente las banderas O (overflow) y S (signo), dado que en los primeros ejercicios de ensamblador solo se emplean números enteros positivos. No obstante, estas banderas pueden habilitarse posteriormente desde el menú de configuración del simulador, conforme se abordan ejercicios de mayor complejidad.

```{r banderas, echo=FALSE, fig.cap="Registro Flags", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/flags.png")
```

El flag de interrupción I solo se muestra cuando el programa lo requiere, por ejemplo, al ejecutar una instrucción de interrupción como `INT` o `IRET`. Esto permite a los estudiantes observar cómo se activa y desactiva este flag en función de las operaciones realizadas.

```{r banderaI, echo=FALSE, fig.cap="Registro de estado I", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/flagi.png")
```

Se modificó el menú de los controles del simulador.

```{r controles, echo=FALSE, fig.cap="Controles del simulador", fig.align = 'center', out.width = "100%"}    
knitr::include_graphics(path = "images/controles.png")
```
En lugar de utilizar registros de 16 bits completos, se emplea únicamente la parte baja de cada registro, lo que simplifica tanto la representación como la manipulación de los datos. Esta decisión responde a la necesidad de reducir la complejidad del modelo, facilitando así la comprensión de los conceptos fundamentales de la arquitectura de computadoras. Además, se ha unificado el criterio de diseño de los registros: todos cuentan ahora con una entrada y una salida independientes, lo que permite visualizar de manera más clara la transferencia de datos entre los registros y la Unidad Aritmético-Lógica (ALU). Esta modificación resulta esencial para comprender el flujo de datos durante el ciclo de instrucción y la interacción entre los distintos componentes del procesador.

```{r registros, echo=FALSE, fig.cap="Registro de 8 bits", fig.align = 'center', out.width = "100%"}    
knitr::include_graphics(path = "images/registros.png")
```

La eliminación de los registros temporales `left`, `right` y `result` en la ALU responde a la necesidad de simplificar el flujo de datos y reducir la carga cognitiva de los estudiantes. En lugar de utilizar registros intermedios, el simulador muestra directamente las operaciones realizadas en los operandos, lo que facilita la comprensión del proceso aritmético y lógico.

```{r leftrigth, echo=FALSE, fig.cap="Eliminación registro temporales left, right y result", fig.align = 'center', out.width = "100%"}    
knitr::include_graphics(path = "images/leftrigth.png")
```

Los registros `SP`, `ri` e `id` se mantienen ocultos y solo se habilitan automáticamente cuando una instrucción requiere su utilización.

```{r idrisp, echo=FALSE, fig.cap="Registro SP, id y ri", fig.align = 'center', out.width = "100%"}    
knitr::include_graphics(path = "images/idrisp.png")
```

La memoria principal se modela como una matriz de 16×16 expresada en hexadecimal, lo que permite almacenar hasta 256 bytes de datos.

```{r memoriacomp, echo=FALSE, fig.cap="Memoria principal", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/memoriacomp.png")
```

Resalto de la direccion de memoria apuntada por el registro IP en memoria y también resalta la dirección de memoria apuntada por el registro SP.

```{r resaltadoip, echo=FALSE, fig.cap="Resaltado registro IP y registro SP", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/resaltadoipsp.png")
```

Se resalta en color naranja en la memoria principal el espacio destinado al vector de interrupciones en el VonSim8 es de 8 posiciones de memoria desde `0x00h` a `0x07h`:

```{r resaltadointsp, echo=FALSE, fig.cap="Resaltado vector de interrupciones", fig.align = 'center', out.width = "50%"}
knitr::include_graphics(path = "images/resaltadoint.png")
```

Para determinar la dirección de la rutina de tratamiento de interrupción en VonSim, es necesario multiplicar el número de interrupción por 4, ya que cada dirección de rutina ocupa 4 bytes. En cambio, en VonSim8 no es necesario realizar esta multiplicación, dado que cada dirección de rutina de interrupción corresponde a un solo byte. Por lo tanto, la interrupción `INT 0` se encuentra en la direccion `0x00h`, la interrupción `INT 6` en la direccion `0x06h`, y así sucesivamente.

Se incorporó un visor de instrucciones y datos del programa en memoria, que permite visualizar la instrucción, el tamaño en bytes que ocupa en memoria y la etiqueta asociada a los datos.

```{r visorprog, echo=FALSE, fig.cap="Visor de instrucciones y datos del programa en memoria", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/visorprog.png")
```

En VonSim, cuando se escribe un programa en el editor del simulador, es obligatorio que la sección de código inicie con la directiva `ORG 0x2000h` y que termine con la directiva `END`. Esto se debe a que el simulador comienza a ejecutar la primera instrucción a partir de la dirección de memoria `0x2000h`. De manera complementaria, los datos del programa suelen cargarse a partir de la dirección `0x1000h` mediante la directiva `ORG 0x1000h`.

En VonSim8, el uso de la directiva `ORG` para definir la dirección inicial es opcional. Por defecto, si el programa no incluye esta directiva, la primera instrucción se carga en la dirección `0x00h`. En caso de contener instrucciones de interrupción (INT), el simulador asigna automáticamente la dirección `0x08h` como punto de inicio, reservando espacio para el vector de interrupciones.

Por una cuestion de compatibilidad se permite cargar programas de manera similar a VonSim, pero en lugar de cargar el programa en la direccion `0x2000h` se debe cargar en la `0x20h`. En este caso, el simulador comienza a ejecutar las instrucciones a partir de la dirección `0x20h`. Para mantener compatibilidad con VonSim, se conserva esta directiva, permitiendo a los usuarios establecer direcciones personalizadas.

```{r org, echo=FALSE, fig.cap="Compatibilitad directiva ORG y END", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/org.png")
```

Además, en VonSim8 se incorporó la opción de abrir ejemplos prácticos para que el estudiante pueda experimentar directamente con el simulador. También se desarrolló un tour de aprendizaje que guía al usuario a través de las principales funcionalidades, junto con un centro de aprendizaje que ofrece explicaciones y ejemplos básicos.

```{r editorvonsim, echo=FALSE, fig.cap="Editor con ampliación de fuente y ejemplos", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/editorfuenteejemplo.png")
```

Se ha mejorado el diseño de la unidad de control incorporando, dentro del decodificador, una memoria de control y un secuenciador. Estos componentes permiten representar el ciclo de instrucción de manera detallada, mostrando las microoperaciones y las señales de control generadas en cada etapa del proceso.

```{r decodificador, echo=FALSE, fig.cap="Decodificador en VonSim8", fig.align = 'center', out.width = "50%"}
knitr::include_graphics(path = "images/decodificador.png")
```

Con el fin de facilitar el aprendizaje del simulador VonSim8 se implementó un tour de aprendizaje que guía a los usuarios a través de las características y funcionalidades del simulador. También se incluye un centro de aprendizaje con explicación de ejemplos básicos.

```{r tour, echo=FALSE, fig.cap="Tour de aprendizaje en VonSim8", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/tour.png")
```

A fin de sintetizar las diferencias más relevantes entre VonSim y VonSim8, se presenta la siguiente tabla comparativa. Esta permite visualizar de manera inmediata los cambios introducidos en el diseño y su impacto en la enseñanza de los conceptos fundamentales de arquitectura de computadoras.

```{r comparativavonsim, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

comparativa_vonsim <- data.frame(
  Característica = c(
    "Registros",
    "Registro FLAGS",
    "Controles del simulador",
    "Directiva org",
    "Memoria principal",
    "Resaltado de IP y SP",
    "Vector de interrupciones",
    "Dirección de rutina de interrupción",
    "Visor de instrucciones y datos",
    "Temporales de la ALU",
    "Unidad de control",
    "Enfoque pedagógico",
    "Editor y recursos didácticos"
  ),
  VonSim = c(
    "Registros de 16 bits (AX, BX, CX, DX)",
    "Incluye todas las banderas del 8088 (O, S, Z, C, etc.)",
    "Menú de controles estándar",
    "Obligatoria. El código comienza en `0x2000h` y los datos en `0x1000h`.",
    "32 KB, organizada en páginas del 8088.",
    "No resalta dinámicamente IP y SP en memoria.",
    "Vector de interrupciones ocupa varias posiciones, cada rutina ocupa 4 bytes.",
    "Se multiplica el número de interrupción por 4 para obtener la dirección.",
    "No incluye visor detallado de instrucciones y datos.",
    "Registros temporales `left`, `right` y `result` visibles.",
    "Decodificador básico sin memoria de control ni secuenciador.",
    "Mayor fidelidad al procesador Intel 8088, con repertorio más amplio.",
    "Editor estándar, sin ampliación de fuente ni tour de aprendizaje."
  ),
  VonSim8 = c(
    "Registros de 8 bits, con entrada y salida independientes. Registros SP, RI e ID se ocultan y habilitan automáticamente.",
    "Se ocultan inicialmente las banderas O (overflow) y S (signo). El flag I (interrupción) se muestra dinámicamente.",
    "Menú de controles modificado y adaptado.",
    "Opcional. Por defecto, el código inicia en `0x00h`. Si hay interrupciones, comienza en `0x08h`. Compatible con `org 0x20h`.",
    "Matriz de 16×16 bytes (256 bytes), expresada en hexadecimal, con resaltado dinámico de IP y SP.",
    "Resalta en memoria la posición apuntada por IP y SP.",
    "Vector de interrupciones ocupa 8 posiciones (`0x00h` a `0x07h`), cada rutina ocupa 1 byte.",
    "La dirección de la rutina de interrupción coincide con el número de interrupción (ej. INT 6 en `0x06`).",
    "Incluye visor de instrucciones y datos, mostrando tamaño y etiquetas.",
    "Eliminados, para simplificar la representación del ciclo de instrucción.",
    "Decodificador mejorado con memoria de control y secuenciador, permite visualizar microoperaciones y señales de control.",
    "Simplificación estratégica para reducir carga cognitiva y favorecer aprendizaje progresivo.",
    "Editor con ampliación de fuente, ejemplos prácticos, tour de aprendizaje y centro de ayuda."
  ),
  stringsAsFactors = FALSE
)

tabla_comparativa <- kable(
  comparativa_vonsim,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Comparativa de características entre VonSim y VonSim8",
  col.names = c("Característica", "VonSim", "VonSim8"),
  booktabs = TRUE,
  escape = FALSE,
  align = c("l", "l", "l")
)

if (knitr::is_latex_output()) {
  tabla_comparativa %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "5cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "7cm") %>%
    column_spec(3, width = "8cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(comparativa_vonsim)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_comparativa %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "16em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "28em") %>%
    column_spec(3, width = "32em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

## Repertorio de instrucciones
El simulador VonSim8 implementa un repertorio reducido de instrucciones, diseñado para facilitar la comprensión de los conceptos fundamentales de la arquitectura de computadoras. Este repertorio incluye instrucciones aritméticas, lógicas, de transferencia de datos y control de flujo, lo que facilita que los estudiantes se familiaricen con las operaciones básicas, evitando la complejidad del repertorio completo de instrucciones x86.

El repertorio de instrucciones del simulador fue concebido como una abstracción pedagógica basada en la arquitectura x86, orientada a optimizar los procesos de enseñanza y aprendizaje en el ámbito educativo. En las primeras etapas del curso, se seleccionan únicamente las instrucciones esenciales, lo que permite introducir de forma gradual y accesible los contenidos fundamentales de la asignatura Arquitectura de Computadoras. Este enfoque progresivo facilita la comprensión de los conceptos clave, evitando la complejidad innecesaria que podría dificultar el aprendizaje inicial [@hennessy2017computer; @tanenbaum_structured_2016]. La Tabla \@ref(tab:setreducido) presenta un conjunto reducido de instrucciones que abarca las operaciones más relevantes para una etapa introductoria, centradas en la transferencia y procesamiento de datos, así como en el control de flujo. Esta selección estratégica garantiza la accesibilidad de los conceptos básicos de la arquitectura x86 y se ajusta a los objetivos pedagógicos del curso.

Las instrucciones del simulador VonSim8 se dividen en dos categorías principales: las instrucciones de transferencia y procesamiento de datos, y las instrucciones de control de flujo. Las primeras permiten mover datos entre registros y memoria, realizar operaciones aritméticas y lógicas, y manipular el contenido de los registros. Las segundas permiten alterar el flujo de ejecución del programa mediante saltos condicionales e incondicionales, así como la detención del procesador.

Con el objetivo de favorecer el aprendizaje de la programación en ensamblador y la comprensión del ciclo de instrucción, se presenta a continuación un repertorio de instrucciones alineado con el programa de estudio de la asignatura Arquitectura de Computadoras [@cd023_25_programa2025].

```{r setreducido, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear los datos
setreducido <- data.frame(
  Instrucciones = c(
    "Transferencia de datos",
    "Procesamiento de datos",
    "",
    "",
    "Control de flujo",
    "",
    ""
  ),
  `Nemónico` = c(
    "MOV ",
    "ADD",
    "SUB",
    "CMP",
    "JMP",
    "Jxx",
    "HLT"
  ),
  Acción = c(
   "Copiar",
  "Sumar",
  "Restar",
  "Comparar",
  "Salto incondicional",
  "Salto condicional si xx=1",
  "Detiene CPU"
  )
)

# Crear la tabla con formato dinámico
tabla <- kable(setreducido,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Tabla de instrucciones de VonSim8",
               col.names = c("Instrucciones", "nemónico", "Acción"), # nolint: line_length_linter.
               booktabs = TRUE,
               escape = FALSE)


# Mostrar la tabla en formato adecuado según el tipo de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>% # nolint: line_length_linter.
    column_spec(2, width = "4cm") %>%
    column_spec(3, width = "6cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(setreducido)), extra_latex_after = "\\addlinespace[8pt]") # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "25em", bold = TRUE) %>% # nolint: line_length_linter.
    column_spec(2, width = "15em") %>%
    column_spec(3, width = "25em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

El parámetro `xx` en las instrucciones `Jxx` hace referencia a diferentes combinaciones de banderas de estado (flags), tales como cero (Z), acarreo (C), signo (S) y desbordamiento (O). La negación de un flag se indica con la letra N, lo que amplía la flexibilidad de control del flujo de ejecución en programas condicionales.


```{r saltoscondicionales, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

saltoscondicionales <- data.frame(
  Instrucción = c(
    "JZ Dirección", "JNZ Dirección", "JC Dirección", "JNC Dirección",
    "JS Dirección", "JNS Dirección", "JO Dirección", "JNO Dirección"
  ),
  Acción = c(
    "Salta a _Dirección_ si Z = 1",
    "Salta a _Dirección_ si Z = 0",
    "Salta a _Dirección_ si C = 1",
    "Salta a _Dirección_ si C = 0",
    "Salta a _Dirección_ si S = 1",
    "Salta a _Dirección_ si S = 0",
    "Salta a _Dirección_ si O = 1",
    "Salta a _Dirección_ si O = 0"
  )
)

tabla <- kable(
  saltoscondicionales,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Saltos condicionales: instrucciones y condiciones",
  col.names = c("Instrucción", "Acción"),
  booktabs = TRUE,
  escape = TRUE,
  align = c("c", "c")
)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "6cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(saltoscondicionales)), extra_latex_after = "\\addlinespace[8pt]")
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE) %>%
    column_spec(2, width = "18em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Con base en las entrevistas realizadas a los docentes y el análisis de los contenidos del curso, a continuación se presenta el uso pedagógico esperado para cada categoría de instrucciones.

- **Transferencia y procesamiento de datos**: instrucciones que permiten mover datos entre registros y memoria, así como realizar operaciones aritméticas. Estas instrucciones son fundamentales para comprender el flujo de datos en una arquitectura computacional, mostrando cómo se ejecutan operaciones aritméticas de manera análoga a las implementadas en lenguajes de alto nivel como Python:

```python
x=2
y=3
z=0
z = x + y
```

La traducción equivalente en lenguaje ensamblador es:

```{r  codearit, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
  x db 2
  y db 3
  z db 0
  mov AL, x   ;Se carga el valor de x (2) en AL
  add AL, y   ;Se suma el valor de y (3) a AL (2) = 5
  mov z, AL   ;Se guarda el valor del registro AL (5) en z 
  hlt\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
    x db 2
    y db 3
    z db 0
    mov AL, x   ;Se carga el valor de x (2) en AL
    add AL, y   ;Se suma el valor de y (3) a AL (2) = 5
    mov z, AL   ;Se guarda el valor del registro AL (5) en z 
    hlt
    ```")
}
```

- **Control de flujo**: Instrucciones que permiten alterar el flujo de ejecución del programa mediante saltos condicionales e incondicionales, así como la detención del procesador. Estas instrucciones son esenciales para comprender cómo se controlan las decisiones y el flujo de ejecución en un programa. Por ejemplo, lo que posibilita la implementación de estructuras condicionales análogas a las de lenguajes de alto nivel, como Python:

```python
x=2
y=3
z=0
if x == y:
  z = y  + x
```

La traducción equivalente en lenguaje ensamblador es:

```{r  codeifZ, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
x db 2 
y db 3
z db 0
          mov AL, x
          cmp AL, y
          jz EsIgual
          jmp Fin
EsIgual:  add AL, y
          mov z, AL 
Fin:      hlt\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
x db 2 
y db 3
z db 0
          mov AL, x
          cmp AL, y
          jz EsIgual
          jmp Fin
EsIgual:  add AL, y
          mov z, AL 
Fin:      hlt ```")
}
```

```python
x=2
y=3
z=0
if x < y:
  z = y  + x
```

La traducción equivalente en lenguaje ensamblador es:

```{r  codeifC, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
x db 2 
y db 3
z db 0
          mov AL, x
          cmp AL, y
          jc EsMenor
          jmp Fin
EsMenor:  add AL, y
          mov z, AL 
Fin:      hlt\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
x db 2 
y db 3
z db 0
          mov AL, x
          cmp AL, y
          jc EsMenor
          jmp Fin
EsMenor:  add AL, y
          mov z, AL 
Fin:      hlt ```")
}
```

Por ejemplo, la estructura iterativa `while` en Python:

```python
x = 0
suma = 0

while x < 10:
    suma = suma + x
    x = x + 1
```

La traducción equivalente en lenguaje ensamblador es:

```{r  codewhile, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
x     db 1   
suma  db 0   
Condicion:  cmp x, 10 
            jc Bucle   		; si x < 10  salta a etiqueta Bucle:
            jmp FinBucle      ; si no salta a la etiqueta FinBucle:
Bucle:      mov BL, x
            add suma, BL
            add x, 1
            jmp Condicion      ; salta a Condicion:
FinBucle: 	hlt
\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
x     db 1   
suma  db 0   
Condicion:  cmp x, 10 
            jc Bucle   		; si x < 10  salta a etiqueta Bucle:
            jmp FinBucle      ; si no salta a la etiqueta FinBucle:
Bucle:      mov BL, x
            add suma, BL
            add x, 1
            jmp Condicion      ; salta a Condicion:
FinBucle: 	hlt ```")
}
```

Tratamiento de vectores: El simulador permite trabajar con vectores y matrices, lo que facilita la comprensión de cómo se manejan estructuras de datos más complejas en una arquitectura computacional. Por ejemplo, el siguiente código en Python busca el máximo de un vector:

```python
# Búsqueda del máximo en un vector
vector = [5, 2, 10, 4, 5, 0, 4, 8, 1, 9]
maximo = 0

for i in range(len(vector)):
    if vector[i] > maximo:
        maximo = vector[i]
```

La traducción equivalente en lenguaje ensamblador es:

```{r codevector, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}[breaklines=true]

max     db 0
vector  db 5, 2, 10, 4, 5, 0, 4, 8, 1, 9
            mov CL, 0 ; contador
            mov BL, offset vector  ; dirección inicial del vector
Condicion:  cmp CL, 10 
            jc Bucle          ; si x < 10  salta a etiqueta Bucle
            jmp FinBucle      ; si no salta a la etiqueta FinBucle
Bucle:      mov AL, [BL]      ; AL = vector[indice] 
            cmp AL, max
            jc Proximo        ; si AL < max, salta a Proximo
            mov max, AL       ; si no, actualiza max
Proximo:    add BL, 1         ; BL = BL + 1 
            add CL, 1         ; CL = CL + 1            
            jmp Condicion 
FinBucle: 	hlt
\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
max     db 0
vector  db 5, 2, 10, 4, 5, 0, 4, 8, 1, 9
            mov CL, 0 ; contador
            mov BL, offset vector  ; obtiene la dirección del primer elemento del vector
Condicion:  cmp CL, 10 
            jc Bucle          ; si x < 10  salta a etiqueta Bucle
            jmp FinBucle      ; si no salta a la etiqueta FinBucle
Bucle:      mov AL, [BL]      ; AL = vector[indice] 
            cmp AL, max
            jc Proximo        ; si AL < max, salta a Proximo
            mov max, AL       ; si no, actualiza max
Proximo:    add BL, 1         ; BL = BL + 1 
            add CL, 1         ; CL = CL + 1         
            jmp Condicion 
FinBucle: 	hlt```")
}
```

La selección de instrucciones está diseñada para facilitar la comprensión de los procesos esenciales de la arquitectura de computadoras, como la ejecución de operaciones aritméticas, la transferencia de datos entre registros y memoria, y el control del flujo de ejecución. Al emplear un repertorio reducido e inspirado en la arquitectura x86, se logra un equilibrio entre el rigor conceptual y la simplicidad pedagógica.

La implementación de estas instrucciones en el simulador VonSim8 tiene como objetivo ofrecer una experiencia de aprendizaje que favorezca la asimilación de los principios fundamentales de la arquitectura de computadoras, disminuyendo la carga cognitiva en las etapas iniciales y fortaleciendo la transición hacia repertorios más avanzados. Esta selección de instrucciones y modos de direccionamiento, inspirada en x86 pero pedagógicamente acotada, proporciona al estudiante un modelo mental preciso sobre la ejecución de operaciones aritméticas, la transferencia de datos entre registros y memoria, y la gestión del flujo de ejecución.

### Modos de direccionamiento
Los modos de direccionamiento especifican cómo el procesador determina la ubicación de los operandos de una instrucción. Estos mecanismos permiten identificar de dónde se obtienen los datos necesarios para ejecutar una operación y dónde se almacena el resultado. En VonSim8 se implementan los siguientes modos de direccionamiento:

- **Registro a registro (`Rx`, `Ry`)**: ambos operandos corresponden a registros del procesador; `Rx` es el registro destino y `Ry` el registro fuente.
- **Directo (`[M]`)**: uno de los operandos es el contenido de una dirección de memoria `[M]`.
- **Indirecto (`[BL]`)**: la dirección del operando se encuentra almacenada en el registro `[BL]`.
- **Inmediato (`d`)**: uno de los operandos es un valor inmediato incluido en la propia instrucción.

La Tabla \@ref(tab:modosdireccionamiento) resume los modos de direccionamiento disponibles en el simulador para instrucciones de dos operandos e incluye ejemplos ilustrativos de su uso.

```{r modosdireccionamiento, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

if (knitr::is_latex_output()) {
  modosdireccionamiento <- data.frame(
    Destino = c(
      "Registro Rx",
      "Memoria puede ser: \\begin{itemize}\\item dirección [M]\\item dirección registro [BL] \\end{itemize}"
    ),
    Fuente = c(
      "Puede ser:\\begin{itemize} \\item registro Ry\\item dirección [M] (1) \\item dirección registro [BL] (2)\\item valor inmediato d (3)\\end{itemize}",
      "Puede ser:\\begin{itemize} \\item Registro: Ry\\item valor en la instrucción d \\end{itemize}"
    ),
    Ejemplo = c(
      "\\begin{itemize} \\item Entre registro: MOV Rx, Ry\\item Directo: MOV Rx, [M] \\item Indirecto: MOV Rx, [BL]\\item Inmediato: MOV Rx, d \\end{itemize}",
      "\\begin{itemize} \\item Directo: MOV [M], Ry \\item Indirecto: MOV [BL], Ry\\item Directo-Inmediato: MOV [M], d\\item Indirecto-Inmediato: MOV [BL], d \\end{itemize}"
    ),
    stringsAsFactors = FALSE
  )
} else {
  modosdireccionamiento <- data.frame(
    Destino = c(
      "Registro Rx",
      "Memoria puede ser: <ul><li>dirección `[M]`</li><li>dirección registro `[BL]`</li></ul>"
    ),
    Fuente = c(
      "Puede ser:<ul><li>registro `Ry`</li><li>dirección `[M]` (1)</li><li>dirección registro `[BL]` (2)</li><li>valor inmediato `d` (3)</li></ul>",
      "Puede ser:<ul><li>Registro: `Ry`</li><li>valor en la instrucción `d`</li></ul>"
    ),
    Ejemplo = c(
      "<ul><li>Entre registro: MOV `Rx`,`Ry`</li><li>Directo: MOV `Rx`,`[M]`</li><li>Indirecto: MOV `Rx`,`[BL]`</li><li>Inmediato: MOV `Rx`,`d`</li></ul>",
      "<ul><li>Directo: MOV `[M]`,`Ry`</li><li>Indirecto: MOV `[BL]`,`Ry`</li><li>Directo-Inmediato: MOV `[M]`,`d`</li><li>Indirecto-Inmediato: MOV `[BL]`,`d`</li></ul>"
    ),
    stringsAsFactors = FALSE
  )
}

tabla <- kable(
  modosdireccionamiento,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Tabla de modos de direccionamiento",
  col.names = c("Destino", "Fuente", "Ejemplo"),
  booktabs = TRUE,
  escape = FALSE
)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "5cm") %>%
    column_spec(3, width = "8cm", latex_column_spec = "p{8cm}") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(modosdireccionamiento)), extra_latex_after = "\\addlinespace[10pt]") %>%
    footnote(
      general = c(
        "Las instrucciones de dos operandos, tanto de transferencia y procesamiento tienen los mismos modos de direccionamiento.",
        "Rx y Ry pueden ser un registro de propósito general: AL, BL, CL y DL."
      ),
      general_title = "Nota: ",
      symbol = c("La notación M indica dirección de memoria."),
      symbol_title = "Símbolos: ",
      number = c("La notación [M] indica el contenido de la dirección de memoria.", "La notación [BL] indica el contenido de la dirección del registro BL.", "La notación d indica dato inmediato."),
      number_title = "Notas numéricas: ",
      threeparttable = TRUE
    )
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "15em", bold = TRUE) %>%
    column_spec(2, width = "25em") %>%
    column_spec(3, width = "35em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2") %>%
    row_spec(seq_len(nrow(modosdireccionamiento)), extra_css = "border-top: 2px solid #000;") %>%
    footnote(
      general = "Las instrucciones de dos operando, tanto de transferencia y procesamiento tienen los mismos modos de direccionamiento.",
      general_title = "Nota: ",
      threeparttable = TRUE
    )
}
```

Estos modos de direccionamiento permiten al simulador ejecutar una variedad de operaciones, desde la manipulación directa de registros hasta el acceso flexible a la memoria. Constituyen una base esencial para comprender el flujo de datos en una arquitectura computacional.

Ejemplo de los modos de direccionamiento:

```{r  codemoddir, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
x db 2 
y db 3

; Ejemplo modos direccionamiento
;----------------------
; carga en registro
;----------------------
; Directo
mov al, x

; Por registro
mov dl, al

; Inmediato
mov bl, 16

; Indirecto
mov cl, [bl] ; celda 16 = bl

;----------------------
; Almacenar en memoria
;----------------------
; Directo
mov x, cl

; Indirecto
mov [bl], al

; Directo-Inmediato
mov x, 5

; Indirecto-Inmediato
mov [bl], 4

hlt\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
x db 2 
y db 3

; Ejemplo modos direccionamiento
;----------------------
; carga en registro
;----------------------
; Directo
mov al, x

; Por registro
mov dl, al

; Inmediato
mov bl, 16

; Indirecto
mov cl, [bl] ; celda 16 = BL

;----------------------
; Almacenar en memoria
;----------------------
; Directo
mov x, cl

; Indirecto
mov [bl], al

; Directo-Inmediato
mov x, 5

; Indirecto-Inmediato
mov [bl], 4

hlt
```")
}
```

### Formato de instrucciones
El formato de las instrucciones en VonSim8 se fundamenta en una codificación binaria de longitud variable (1, 2 o 3 bytes). Los 4 bits de mayor peso del primer byte corresponden al código de operación (opcode), mientras que los 4 bits restantes pueden contener información adicional sobre los operandos, dependiendo del modo de direccionamiento utilizado. El opcode determina la operación a ejecutar, y los operandos especifican los datos o registros implicados en la instrucción.

Las instrucciones del simulador VonSim8 se agrupan en dos categorías principales: instrucciones de transferencia y procesamiento de datos, e instrucciones de control de flujo.

```{r tisaredu, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

tisaredu <- data.frame(
  Categoría = c(
    "Transferencia de datos",
    "Procesamiento de datos", "", "",
    "Control de flujo", ""

  ),
  Instrucción = c(
    "MOV",
    "ADD", "SUB", "CMP",
    "JMP / Jxx",
    "HLT"
  ),
  `Código operación` = c(
    "{0, 1, 2}",
    "{3, 4, 5}", "{6, 7, 8}", "{9, 10, 11}",
    "{12}",
    "{13}"
  ),
  `Operandos` = c(
    "2",
    "2", "2", "2",
    "1",
    "0"
  ),
  Acción = c(
    "Copiar entre registros, cargar de memoria a registro, almacenar en memoria",
    "Operación aritmética: operando1 ← operando1 + operando2",
    "Operación aritmética: operando1 ← operando1 - operando2",
    "Comparación: operando1 - operando2 (no actualiza el destino)",
    "Salto incondicional JMP, condicionales Jxx",
    "HLT: detiene el CPU"
  ),
  stringsAsFactors = FALSE
)

tabla_kable <- kable(tisaredu,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Categoría de instrucciones y códigos de operación en VonSim8",
               col.names = c("Categoría", "Instrucción","Código operación", "Operandos", "Acción"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c", "l"))

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "4cm") %>%
    column_spec(3, width = "3cm") %>%
    column_spec(4, width = "3cm") %>%
    column_spec(5, width = "8cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tisaredu)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "12em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "16em") %>%
    column_spec(3, width = "8em") %>%
    column_spec(4, width = "8em") %>%
    column_spec(5, width = "32em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Cada instrucción se codifica en un formato binario específico, que incluye un código de operación (opcode) y, en algunos casos, operandos adicionales. La Tabla \@ref(tab:instcodif) presenta una lista de las instrucciones implementadas en el simulador, junto con su codificación binaria.

```{r instcodif, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

instcodif <- data.frame(
  CodOp = c(
    "0", "1", "1", "1", "2", "2", "2", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "C", "D"
  ),
  Instrucción = c(
    "`MOV Rx, Ry`", "`MOV Rx, [M]`", "`MOV Rx, [BL]`", "`MOV Rx, D`",
    "`MOV [M], Ry`", "`MOV [BL], Ry`", "`MOV [M], D`", "`MOV [BL], D`",
    "`ADD Rx, Ry`", "`ADD Rx, --`", "`ADD [M], --`", "`SUB Rx, Ry`", "`SUB Rx, --`", "`SUB [M], --`",
    "`CMP Rx, Ry`", "`CMP Rx, --`", "`CMP [M], --`", "`JMP M`", "`Jxx M`", "`HLT`"
  ),
  Byte = c(
    "1", "2", "1", "2", "2", "2", "3", "2", "1", "Idem", "Idem", "1","Idem", "Idem",
    "1", "Idem", "Idem", "1", "1", "1"
  ),
  Codificación = c(
    "`0000 RxRy`", "`0001 Rx00 MMMMMMMM`", "`0001 Rx01`", "`0001 Rx10 DDDDDDDD`",
    "`0010 00Ry MMMMMMMM`", "`0010 01Ry`", "`0010 1100 MMMMMMMM DDDDDDDD`", "`0010 1101 DDDDDDDD`",
    "`0011 RxRy`", "`0100 ---- --------`", "`0101 ---- -------- --------`", "`0110 RxRy`", "`0111 ---- --------`",
    "`1000 ---- -------- --------`", "`1001 RxRy`", "`1010 ---- --------`", "`1011 ---- -------- --------`",
    "`1100 0000 MMMMMMMM`", "`1100 ffff MMMMMMMM`", "`1101 0000`"
  ),
  stringsAsFactors = FALSE
)

# Para monoespaciado en PDF reemplaza los backticks por \texttt{}
if (knitr::is_latex_output()) {
  instcodif$Instrucción <- gsub("`([^`]*)`", "\\\\texttt{\\1}", instcodif$Instrucción)
  instcodif$Codificación <- gsub("`([^`]*)`", "\\\\texttt{\\1}", instcodif$Codificación)
}

tabla_kable <- kable(instcodif,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Tabla de codificación de instrucciones",
               col.names = c("CodOp", "Instrucción", "Byte", "Codificación"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "l", "l", "l"))

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "2cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "3.5cm") %>%
    column_spec(3:4, width = "6cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(instcodif)), extra_latex_after = "\\addlinespace[10pt]") %>%
    footnote(
      general = c(
        "Las instrucciones de dos operandos, tanto de transferencia y procesamiento tienen los mismos modos de direccionamiento.",
        "Considerando:",
        "____: Código de operación de la instrucción, 4 bits.",
        "Rx o Ry: Índices de registros de propósito general, 0 a 3, 2 bits cada uno.",
        "M: Dirección de memoria 8 bits.",
        "D: Dato inmediato 8 bits.",
        "ffff: representa el comportamiento de la instrucción 4 bits."
      ),
      general_title = "Nota: ",
      threeparttable = TRUE
    )
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "10em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "25em") %>%
    column_spec(3:4, width = "35em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2") %>%
    footnote(
      general = paste(
        "Las instrucciones de dos operandos, tanto de transferencia y procesamiento tienen los mismos modos de direccionamiento.",
        "Considerando:",
        "____: Código de operación de la instrucción, 4 bits.",
        "Rx o Ry: Índices de registros de propósito general, 0 a 3, 2 bits cada uno.",
        "M: Dirección de memoria 8 bits.",
        "ffff: representa el comportamiento de la instrucción 4 bits.",
        "d: Dato inmediato 8 bits.",
        "MMMMMMMM: Dirección de memoria 8 bits.",
        "dddddddd: Dato inmediato 8 bits.",
        sep = "<br>"
      ),
      general_title = "Nota: ",
      threeparttable = TRUE
    )
}
```

La tabla \@ref(tab:tablaregistros) presenta los códigos binarios y decimales correspondientes a los registros de propósito general AL, BL, CL y DL, los cuales pueden ser utilizados como Rx y Ry en las instrucciones del simulador.

```{r tablaregistros, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

tablaregistros <- data.frame(
  Registro = c("AL", "BL", "CL", "DL"),
  Binario = c("00", "01", "10", "11"),
  Decimal = c(0, 1, 2, 3)
)

if (knitr::is_latex_output()) {
  kable(tablaregistros, format = "latex", booktabs = TRUE, align = "c",
        col.names = c("Registros R", "Binario", "Decimal"),
        caption = "Tabla de registros del simulador") %>%
    kable_styling(latex_options = c("hold_position", "scale_down"), position = "center") %>%
    column_spec(1, width = "2.5cm") %>%
    column_spec(2, width = "2.5cm") %>%
    column_spec(3, width = "2.5cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    footnote(
      general = "Los registros AL, BL, CL y DL corresponden a registros de propósito general de 8 bits.",
      general_title = "Nota: ",
      threeparttable = TRUE
    )
} else {
  kable(tablaregistros, format = "html", table.attr = "class='table table-striped'", align = "c",
        col.names = c("Registros R", "Binario", "Decimal"),
        caption = "Tabla de registros del simulador") %>%
    kable_styling(full_width = FALSE, position = "center") %>%
    column_spec(1, width = "7em") %>%
    column_spec(2, width = "7em") %>%
    column_spec(3, width = "7em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2") %>%
    footnote(
      general = "Los registros AL, BL, CL y DL corresponden a registros de propósito general de 8 bits.",
      general_title = "Nota: ",
      threeparttable = TRUE
    )
}
```

## Ciclo de la instrucción
El ciclo de la instrucción es la secuencia de pasos que realiza la Unidad de Control (UC) para ejecutar cada instrucción de un programa. Este proceso es fundamental para el funcionamiento de cualquier computadora, ya que involucra elementos clave como registros, buses de datos, direcciones y señales de control generadas por la UC.

Las microoperaciones que lo componen se expresan mediante la notación de transferencia entre registros: `destino` $\leftarrow$ `origen`.

La Figura \@ref(fig:flujoCicloInstruccion) ilustra el flujo general del ciclo, el cual se divide en dos etapas principales: captación (fetch) y ejecución.

```{r flujoCicloInstruccion, echo=FALSE, fig.cap="Flujo del ciclo de instrucción en VonSim8", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/cicloinstruccion3.png")
```

### Etapa 1: Captación
Esta etapa es igual para todas las instrucciones. Su objetivo es leer la instrucción desde la memoria y cargarla en el **Registro de Instrucciones** (`IR`). Consta de tres microoperaciones:

1. **`MAR` $\leftarrow$ `IP`**
  La UC transfiere al **Registro de Direcciones de Memoria** (`MAR`) la dirección de la próxima instrucción, almacenada en el **Puntero de Instrucción** (`IP`) .

2. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1**
  La UC activa la señal de lectura para leer la instrucción ubicada en la dirección contenida en el `MAR`. El valor leído se guarda en el **Registro de Datos de Memoria** (`MBR`) y, al mismo tiempo, el `IP` se incrementa para apuntar a la siguiente instrucción u operando.

3. **`IR` $\leftarrow$ `MBR`**
  El contenido del `MBR` se transfiere al `IR`, dejando la instrucción lista para ser decodificada y ejecutada.

### Etapa 2: Ejecución
En esta etapa, el **decodificador de instrucciones** interpreta el valor en el registro `IR`. A partir del código de operación, lee las microinstrucciones necesarias en la **memoria de control** para determinar el tipo de instrucción, la cantidad de operandos y el modo de direccionamiento.

Luego, estas microinstrucciones se envían a **secuenciador**, que genera las señales de control precisas para ejecutar la operación.

A continuación se detallan las instrucciones más comunes:

#### Instrucciones con dos operandos `MOV`, `ADD`, `SUB` y `CMP`:

- **Destino en registro (`Rx`)**
  - **Modo entre registros (`Rx`, `Ry`)**
    4. La ejecución se realiza en un solo paso:
        - MOV: **`Rx` $\leftarrow$ `Ry`**
        - ADD: **`Rx` $\leftarrow$ `Rx` + `Ry` | update(Flags)**
        - SUB: **`Rx` $\leftarrow$ `Rx` - `Ry` | update(Flags)**
        - CMP: **`Rx` - `Ry` | update(Flags)** (solo actualiza flags, no guarda el resultado)
  - **Modo directo (`Rx`, `[Dirección]`)**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección del operando fuente.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer la dirección desde memoria e incrementar IP.
    6. **`MAR` $\leftarrow$ `MBR`** – Transferir la dirección al MAR.
    7. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Obtener el dato.
    8. Ejecutar la operación:
        - MOV: **`Rx`  $\leftarrow$ `MBR`**
        - ADD: **`Rx`  $\leftarrow$ `Rx` + `MBR` | update(Flags)**
        - SUB: **`Rx`  $\leftarrow$ `Rx` - `MBR` | update(Flags)**
        - CMP: **`Rx` - `MBR` | update(Flags)**
  - **Modo inmediato (`Rx`, `Dato`)**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección del dato inmediato.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer el dato e incrementar IP.
    6. Ejecutar la operación (igual que en el caso anterior).
  - **Modo indirecto (`Rx`, `[BL]`)**
    4. **`MAR` $\leftarrow$ `BL`** – Obtener dirección del dato desde el registro BL.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer el dato.
    6. Ejecutar la operación (igual que en el caso anterior).

- **Destino en memoria (`[Dirección]` o `[BL]`)**
En este caso, el resultado de la operación se almacena en una dirección de memoria especificada en la instrucción o indicada por el contenido del registro BL.
  - **Modo Directo (`[Dirección]`, `Ry`)**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección destino.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer la dirección e incrementar IP.
    6. **`MAR` $\leftarrow$ `MBR`** – Transferir dirección a MAR.
    Según la instrucción:
      - MOV:
          7. **`MBR` $\leftarrow$ `Ry`** – Copiar Ry al MBR.
          8. **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.
      - ADD, SUB, CMP:
          7. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer el dato.
          8. Ejecutar la operación:
              - ADD: **`MBR` $\leftarrow$ `MBR` + `Ry` | update(Flags)**
              - SUB: **`MBR` $\leftarrow$ `MBR` - `Ry` | update(Flags)**
              - CMP: **`MBR` - `Ry` | update(Flags)**
          9. Si es `ADD` o `SUB`: **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.
  - **Modo Indirecto (`[BL]`, `Ry`)**
    4. **`MAR` $\leftarrow$ `BL`** – Transferir dirección de destino (en BL) a MAR.
    Según la instrucción:
      - MOV:
          5. **`MBR` $\leftarrow$ `Ry`** – Copiar Ry al MBR.
          6. **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.
      - ADD, SUB, CMP:
          5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer el dato.
          6. Ejecutar la operación (igual que en el caso anterior).
          7. Si es `ADD` o `SUB`: **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.
  - **Modo Directo-Inmediato (`[Dirección]`, `Dato`)**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección destino.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer dirección e incrementar IP.
    6. **`MAR` $\leftarrow$ `IP` | `ri` $\leftarrow$ `MBR`** – Preparar para leer el dato y guardar la dirección destino en un registro intermedio (ri).
    7. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer dato e incrementar IP.
    Según la instrucción:
      - MOV:
          8. **`MAR` $\leftarrow$ `ri`** – Copiar dirección destino.
          9. **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.
      - ADD, SUB, CMP:
          8. **`MAR` $\leftarrow$ `ri` | `id` $\leftarrow$ `MBR`** – Cargar dirección destino y guardar el valor inmediato en id.
          9. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer el valor actual de destino.
          10. Ejecutar la operación:
              - ADD: **`MBR` $\leftarrow$ `MBR` + `id` | update(Flags)**
              - SUB: **`MBR` $\leftarrow$ `MBR` - `id` | update(Flags)**
              - CMP: **`MBR` - `id` | update(Flags)**
          11. Si es `ADD` o `SUB`: **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.
  - **Modo Indirecto-Inmediato (`[BL]`, `Dato`)**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección del dato inmediato.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer dato e incrementar IP.
    Según la instrucción:
      - MOV:
          6. **`MAR` $\leftarrow$ `BL`** – Copiar dirección de destino.
          7. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**
      - ADD, SUB, CMP:
          6. **`MAR` $\leftarrow$ `BL` | `id` $\leftarrow$ `MBR`** – Cargar la dirección destino y guardar el valor inmediato en id.
          7. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer el valor actual de destino.
          8. Ejecutar la operación (igual que en el caso anterior).
          9. Si es `ADD` o `SUB`: **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.

#### Instrucciones con un operando `JMP` y `Jxx`:
  - **Salto a (`Dirección`)**
    Tanto incondicional `JMP` como condicionales `Jxx` tienen estos pasos:
    4. **`MAR` $\leftarrow$ `IP`** – Obtener la dirección del salto.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`; `IP` $\leftarrow$ `IP` + 1** – Leer la dirección de destino e incrementar IP.

    Según la instrucción:
      - JMP: 
        6. **`IP` $\leftarrow$ `MBR`**

      - Jxx: 
        6. **`IP` $\leftarrow$ `MBR`** si se cumple la condición del flag `xx`; en caso contrario, continúa con la siguiente instrucción.

#### Instrucciones sin operandos
  - HLT: 
    4. Detiene la ejecución de la CPU.

## Modelado con xDEVS del ciclo de instrucción MOV AL, BL
Con el propósito de validar la arquitectura del simulador VonSim8 y analizar su comportamiento interno, se modela la instrucción MOV AL, BL como un caso de estudio representativo del flujo básico de ejecución a nivel de hardware.

VonSim8 adopta el modelo de Von Neumann, caracterizada por la utilización de un bus único compartido para instrucciones y datos, lo cual introduce el clásico cuello de botella estructural (limitación en el acceso concurrente a datos e instrucciones). En este contexto, la Unidad de Control (UC) debe sincronizar con precisión los accesos concurrentes a memoria y al bus.

Este modelo aplica el formalismo DEVS (Discrete EVents System Specification), introducido en el capítulo \@ref(devs), para representar la ejecución a nivel de Transferencia entre Registros (RTL) como una secuencia de eventos discretos temporizados. La simulación se construye sobre la plataforma xDEVS, utilizando la biblioteca xdevs.py (Python), cuya elección se justificó en la sección \@ref(xdevs).

De acuerdo con el formalismo DEVS, cada componente funcional del procesador —como los registros, la Unidad de Control (UC), la memoria y el bus— se modela como un modelo atómico, mientras que las interacciones entre ellos se describen mediante un modelo acoplado jerárquico. Esta estructura jerárquica permite capturar la concurrencia de eventos y la propagación temporal de señales entre componentes, manteniendo la trazabilidad de cada transición de estado.

### Componentes del simulador VonSim8
Los componentes que intervienen en el ciclo completo de instrucción (Fases de Captación y Ejecución) se modelan como modelos atómicos o acoplados dentro de la plataforma xDEVS, cada uno con sus puertos de entrada, salida y retardos (tiempos de avance $\tau$) definidos.

La tabla \@ref(tab:componentesvonsim8) resume los modelos y componentes principales del simulador VonSim8, detallando sus funciones, señales de entradas/salidas y retardos asociados.

```{r componentesvonsim8, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

componentes_vonsim8 <- data.frame(
  Modelo = c(
    "IP (Instruction Pointer)",
    "MAR (Memory Address Register)",
    "MEM (Memoria unificada)",
    "MBR (Memory Buffer Register)",
    "IR (Instruction Register)",
    "REG\\_BANK (Banco de Registros)",
    "UC (Unidad de Control)",
    "BUS / Árbitro"
  ),
  Descripción = c(
    "Contiene la dirección de la próxima instrucción a ejecutar. Envía su valor al MAR.",
    "Almacena la dirección recibida desde el IP y la utiliza para acceder a la memoria unificada.",
    "Memoria compartida que contiene instrucciones y datos. Devuelve o almacena la palabra solicitada.",
    "Registro intermedio que conecta la memoria con los registros internos.",
    "Registro de instrucción que recibe la palabra desde el MBR y la expone a la UC para su decodificación.",
    "Modelo acoplado que agrupa los registros AL, BL, CL y DL. Cada uno se modela como componente atómico capaz de leer o escribir datos a través del bus compartido. El banco administra las señales de control (\\texttt{enable\\_in}, \\texttt{enable\\_out}) y coordina las operaciones entre los registros bajo las órdenes de la UC.",
    "Coordina el ciclo de captación y ejecución, generando las señales de control y arbitraje del bus.",
    "Canal compartido de comunicación entre IP, MAR, MEM y el banco de registros. Garantiza acceso exclusivo mediante señales de control."
  ),
  `Entradas / Salidas` = c(
    "\\texttt{salida: addr\\_out; entrada: ip\\_write}",
    "\\texttt{entrada: addr\\_in; salida: addr\\_out (a MEM)}",
    "\\texttt{entrada: addr, rw; salida: data\\_out}",
    "\\texttt{entrada: data\\_in; salida: data\\_out}",
    "\\texttt{entrada: inst\\_in; salida: opcode, operandos}",
    "\\texttt{entradas: enable\\_in[n], enable\\_out[n]; salida: data\\_bus; (n = AL, BL, CL, DL)}",
    "\\texttt{entradas: IR; salidas: enable\\_out, enable\\_in, mem\\_read, mem\\_write}",
    "\\texttt{señales req / grant para acceso exclusivo al bus}"
  ),
  Retardo = c(
    "$\\tau_{ip} = t_{ip}$",
    "$\\tau_{mar} = t_{mar}$",
    "$\\tau_{mem} = t_{mem}$",
    "$\\tau_{mbr} = t_{mbr}$",
    "$\\tau_{ir} = t_{ir}$",
    "$\\tau_{regbank} = t_{regbank}$",
    "$\\tau_{control} = t_{control}$",
    "$\\tau_{bus} = t_{bus}$"
  ),
  stringsAsFactors = FALSE
)

tabla_componentes_vonsim8 <- kable(
  componentes_vonsim8,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Modelos y componentes principales del simulador VonSim8",
  col.names = c("Modelo", "Descripción", "Entradas / Salidas", "Retardo"),
  booktabs = TRUE,
  escape = FALSE,
  align = c("l", "l", "l", "l")
)

if (knitr::is_latex_output()) {
  tabla_componentes_vonsim8 %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "5cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "8cm") %>%
    column_spec(3, width = "8cm") %>%
    column_spec(4, width = "3cm", bold = TRUE) %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(componentes_vonsim8)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_componentes_vonsim8 %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "16em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "32em") %>%
    column_spec(3, width = "24em") %>%
    column_spec(4, width = "10em", bold = TRUE) %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

### Fases del ciclo de instrucción
El ciclo de instrucción se compone de dos fases principales, controladas por la Unidad de Control (UC) y modeladas mediante transiciones de estado y funciones temporizadas en el formalismo DEVS:

  1. Fase de captación (Fetch): lectura de la instrucción desde la memoria unificada.

  2. Fase de ejecución (Execute): transferencia del contenido del registro fuente BL al registro destino AL.

### Fase de captación (Fetch)
La fase de captación tiene como objetivo obtener la instrucción almacenada en la memoria unificada, utilizando el valor del Instruction Pointer (IP) como dirección base, y transferirla al Instruction Register (IR) para su posterior decodificación. Este proceso marca el inicio del ciclo de instrucción y determina la secuenciación temporal de accesos a memoria, condicionada por el modelo Von Neumann (memoria y bus compartidos). 

En VonSim8, esta fase reproduce la restricción estructural propia de la arquitectura Von Neumann (bus y memoria compartidos), modelando el acceso exclusivo durante la lectura de la instrucción.

La tabla \@ref(tab:microcaptacionfetch) presenta la secuencia de microoperaciones y eventos DEVS que modelan esta fase.
  
```{r microcaptacionfetch, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

microoperaciones_fetch <- data.frame(
  Paso = c("1", "2", "3", "4", "5", "6"),
  Microoperación = c(
    "UC $\\rightarrow$ IP",
    "IP $\\rightarrow$ MAR",
    "UC $\\rightarrow$ MEM$\\,$; $\\,$IP $\\leftarrow$ IP+1",
    "MEM $\\rightarrow$ MBR",
    "MBR $\\rightarrow$ IR",
    "IR $\\rightarrow$ UC"
  ),
  Descripción = c(
    "La UC genera una señal de lectura hacia el Instruction Pointer.",
    "El IP emite la dirección actual de instrucción hacia el MAR.",
    "La UC activa la señal mem\\_read para iniciar la lectura de la instrucción y, de forma concurrente, incrementa el valor del IP en una unidad.",
    "La memoria unificada devuelve la instrucción solicitada después de su retardo interno ($\\tau{mem}$).",
    "El MBR transfiere la instrucción recibida al registro IR.",
    "El IR genera un evento de salida notificando a la UC que la instrucción está lista para decodificación."
  ),
  `Funciones DEVS` = c(
    "$\\lambda(UC) \\rightarrow \\delta_{ext}(IP)$",
    "$\\lambda(IP) \\rightarrow \\delta_{ext}(MAR)$",
    "$\\lambda(UC) \\rightarrow \\delta_{ext}(MEM)$; $\\lambda_{UC} \\rightarrow \\delta_{ext}(IP)$",
    "$\\delta_{int}(MEM) \\rightarrow \\lambda(MEM) \\rightarrow \\delta_{ext}(MBR)$",
    "$\\lambda(MBR) \\rightarrow \\delta_{ext}(IR)$",
    "$\\lambda(IR) \\rightarrow \\delta_{ext}(UC)$"
  ),
  stringsAsFactors = FALSE
)

tabla_fetch <- kable(
  microoperaciones_fetch,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Secuencia de microoperaciones y eventos DEVS para la Fase de Captación (Fetch)",
  col.names = c("Paso", "Microoperación", "Descripción", "Funciones DEVS"),
  booktabs = TRUE,
  escape = FALSE
)

if (knitr::is_latex_output()) {
  tabla_fetch %>%
    kable_styling(latex_options = c("scale_down", "hold_position"), font_size = 10) %>%
    column_spec(1, width = "1cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "5cm") %>%
    column_spec(3, width = "7cm") %>%
    column_spec(4, width = "7cm", bold = TRUE) %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3")
} else {
  tabla_fetch %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE, position = "center") %>%
    column_spec(1, width = "4em", bold = TRUE) %>%
    column_spec(2, width = "10em") %>%
    column_spec(3, width = "30em") %>%
    column_spec(4, width = "24em", bold = TRUE) %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Durante esta fase, el bus se arbitra mediante un protocolo de petición-concesión (\texttt{req}/\texttt{grant}), garantizando exclusión mutua en el acceso y previniendo colisiones.
    
### Fase de Ejecución (Execute): MOV AL, BL
En la fase de ejecución, la UC decodifica el contenido del IR y activa las señales necesarias para que el Banco de Registros (REG_BANK) transfiera el dato desde el registro fuente BL hacia el registro destino AL a través del bus compartido.

El REG_BANK se modela como un componente acoplado que contiene cuatro modelos atómicos: AL, BL, CL y DL. Cada registro posee sus propias entradas (enable_in, enable_out, data_in, data_out), mientras que el banco actúa como mediador, gestionando la habilitación del registro fuente y destino según las señales emitidas por la UC.

La tabla \@ref(tab:microoperacioneseje) muestra la secuencia de microoperaciones que implementan esta instrucción.

```{r microoperacioneseje, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

microoperaciones_eje <- data.frame(
  Paso = c("1", "2", "3", "4", "5"),
  Microoperación = c(
    "UC: decodifica(IR)",
    "UC $\\rightarrow$ REG\\_BANK.enable\\_out(BL)",
    "BUS $\\leftarrow$ BL",
    "UC $\\rightarrow$ REG\\_BANK.enable\\_in(AL)",
    "AL $\\leftarrow$ BUS"
  ),
  Descripción = c(
    "La UC interpreta el opcode MOV y determina los operandos AL y BL.",
    "La UC habilita la salida del registro BL en el Banco de Registros.",
    "El valor de BL se transfiere al bus compartido.",
    "La UC habilita la entrada del registro AL en el Banco de Registros.",
    "El registro AL captura el dato presente en el bus y actualiza su valor interno."
  ),
  `Funciones DEVS` = c(
    "$\\lambda(UC) \\rightarrow \\delta_{ext}(REG\\_BANK)$",
    "$\\lambda(REG\\_BANK) \\rightarrow \\delta_{ext}(BL)$",
    "$\\lambda(BL) \\rightarrow \\delta_{ext}(BUS)$",
    "$\\lambda(UC) \\rightarrow \\delta_{ext}(REG\\_BANK)$",
    "$\\lambda(BUS) \\rightarrow \\delta_{ext}(AL)$"
  ),
  stringsAsFactors = FALSE
)

tabla_microop <- kable(
  microoperaciones_eje,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Secuencia de microoperaciones y eventos DEVS para la Fase de Ejecución (MOV AL, BL)",
  col.names = c("Paso", "Microoperación", "Descripción", "Funciones DEVS"),
  booktabs = TRUE,
  escape = FALSE
)

if (knitr::is_latex_output()) {
  tabla_microop %>%
    kable_styling(latex_options = c("scale_down", "hold_position"), font_size = 10) %>%
    column_spec(1, width = "1cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "6cm") %>%
    column_spec(3, width = "6cm") %>%
    column_spec(4, width = "5cm", bold = TRUE) %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3")
} else {
  tabla_microop %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE, position = "center") %>%
    column_spec(1, width = "4em", bold = TRUE) %>%
    column_spec(2, width = "10em") %>%
    column_spec(3, width = "30em") %>%
    column_spec(4, width = "24em", bold = TRUE) %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Las microoperaciones se ejecutan conforme a las funciones DEVS de transición interna $\delta_{int}$, transición externa $\delta_{ext}$ y de salida ($\lambda$). 

### Validación experimental
La implementación en xdevs.py reproduce 11 microoperaciones (6 en Fetch y 5 en Execute) y, para este caso de estudio, produce 14 ciclos totales y 45 transiciones DEVS. Se mantiene esta métrica de forma consistente en el cuerpo del texto y el Anexo D (\@ref(anexoD)). Los resultados confirman:

- **Correctitud funcional**: la transferencia AL ← BL se ejecuta correctamente (`AL: 0x01h → 0x0Ah`).
- **Coherencia temporal**: cada componente respeta sus retardos $\tau$ especificados.
- **Sincronización del bus**: el acceso exclusivo se garantiza mediante señales de control.

La traza completa de ejecución, que incluye todos los eventos $\lambda$, $\delta_{int}$ y $\delta_{ext}$ con sus marcas temporales, se presenta en el Anexo D (\@ref(anexoD)), donde se evidencia la coordinación correcta entre la UC, el bus y los registros involucrados.

### Conclusión
El modelado del ciclo de instrucción MOV AL, BL mediante el formalismo DEVS, implementado sobre la plataforma xDEVS con la biblioteca xdevs.py, demuestra la viabilidad de representar con rigor y precisión el comportamiento temporal de la arquitectura VonSim8 a nivel de transferencia entre registros (RTL). La descomposición del procesador en modelos atómicos (IP, MAR, MEM, MBR, IR, REG_BANK) y su orquestación mediante un modelo acoplado jerárquico permiten capturar tanto la concurrencia de eventos como las dependencias estructurales inherentes a la arquitectura de Von Neumann.

Los resultados experimentales validan la correctitud del modelo: la ejecución de la instrucción requiere 14 ciclos distribuidos en 6 microoperaciones de captación (FETCH) y 5 de ejecución (EXECUTE), generando un total de 45 transiciones DEVS ($\lambda$, $\delta_{int}$, $\delta_{ext}$) con un tiempo real de simulación de 3.36 ms. La traza temporal evidencia cómo la Unidad de Control sincroniza el acceso exclusivo al bus compartido y a la memoria unificada, reproduciendo fielmente el cuello de botella estructural de Von Neumann.

Desde una perspectiva de validación arquitectural, este enfoque posibilita la instrumentación de métricas cuantitativas de rendimiento —CPI (Cycles Per Instruction), latencia de acceso a memoria, tiempo de ocupación del bus— que constituyen indicadores objetivos para evaluar el comportamiento del sistema y detectar inconsistencias en el diseño. La modularidad del modelo DEVS facilita, además, la extensión futura del simulador mediante la incorporación de nuevos componentes (ALU, pipeline, cache) sin comprometer la estructura existente.

Desde una perspectiva pedagógica, el modelo ofrece una representación explícita y observable de las dependencias funcionales entre componentes internos del procesador, permitiendo a los estudiantes comprender cómo las restricciones arquitecturales —bus único, acceso secuencial a memoria, coordinación mediante señales de control— impactan directamente en el rendimiento del sistema. De este modo, la visualización de las transiciones de estado y la propagación temporal de eventos no solo valida el modelo, sino que refuerza el aprendizaje de conceptos fundamentales como el ciclo de instrucción, la sincronización de componentes y las limitaciones estructurales de las arquitecturas clásicas.

## Módulo de entrada/salida e interrupciones
El simulador permite configurar la conexión de diversos módulos de entrada/salida y otros dispositivos al bus principal, agrupados en las siguientes categorías:

  - Teclado y pantalla.

  - Un módulo PIO, que puede conectarse a LEDs e interruptores.

  - Módulo Handshake, con posibilidad de conexión a una impresora, con o sin controlador PIC.
  
  - Un controlador PIC, que interactúa con la tecla F10 para generar interrupciones, junto con un temporizador y su reloj asociado.

La Figura \@ref(fig:dispositivos) muestra una visión general de los dispositivos que pueden conectarse al simulador.

```{r dispositivos, echo=FALSE, fig.cap="Arquitectura general del simulador", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/esquemavonsim8.png")
```

El componente chipSelect se encarga de activar el dispositivo correspondiente en cada momento. Para ello, recibe las señales de control del CPU junto con el bus de direcciones, y genera las señales de selección de chip (CS) necesarias para habilitar el dispositivo adecuado.

Para interactuar con los módulos de entrada y salida, es necesario incorporar nuevas instrucciones al repertorio del procesador. Estas instrucciones permiten la comunicación con los puertos de E/S y la gestión de interrupciones. La Tabla \@ref(tab:tisa) detalla las categorías de instrucciones, sus códigos de operación y las acciones que realizan.

```{r tisa, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

tisa <- data.frame(
  Categoría = c(
    "Transferencia de datos",
    "Procesamiento de datos", "", "",
    "Control de flujo",
    "Gestión de flujo",
    "Manejo de pila y E/S",
    "Miscelánea"
  ),
  Instrucción = c(
    "MOV",
    "ADD", "SUB", "CMP",
    "JMP / Jxx / CALL / INT",
    "HLT / RET / IRET / CLI / STI",
    "OUT / IN / PUSH / POP",
    "AND / OR / XOR / NOT / NEG / INC / DEC"
  ),
  `Código operación` = c(
    "{0, 1, 2}",
    "{3, 4, 5}", "{6, 7, 8}", "{9, 10, 11}",
    "{12}",
    "{13}",
    "{14}",
    "{15}"
  ),
  Acción = c(
    "Copiar entre registros, cargar a registro, almacenar en memoria",
    "Operación aritmética: operando1 ← operando1 + operando2",
    "Operación aritmética: operando1 ← operando1 - operando2",
    "Comparación: operando1 - operando2 (no actualiza el destino)",
    "Salto incondicional JMP, salto condicionales Jxx, subrutina CALL, llamar rutina de interrupción INT",
    "Detener CPU HLT, retorno subrutina RET, retornar de interrupción IRET,  deshabilita interrupciones CLI, habilita interrupciones STI",
    "Enviar a puerto OUT, recibir desde puerto IN, poner en la pila PUSH, retirar de la pila POP",
    "Operaciones lógicas y aritméticas"
  ),
  stringsAsFactors = FALSE
)

tabla_kable <- kable(tisa,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Categoría de instrucciones y códigos de operación en VonSim8",
               col.names = c("Categoría", "Instrucción", "Código operación", "Acción"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c", "l"))

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "4cm") %>%
    column_spec(3, width = "3cm") %>%
    column_spec(4, width = "8cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tisa)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "12em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "16em") %>%
    column_spec(3, width = "8em") %>%
    column_spec(4, width = "32em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

El simulador utiliza un código de operación de 4 bits para las instrucciones, lo que simplifica la arquitectura del sistema pero limita el número máximo de instrucciones implementables a 16 opciones diferentes. Con el objetivo de ampliar el repertorio de instrucciones sin incrementar el tamaño de la codificación, se adoptó una estrategia de agrupación para el código de operación 15.

Bajo esta implementación, las instrucciones lógicas (AND, OR y XOR) comparten el código de operación 15 con las instrucciones aritméticas de un operando (INC, DEC, NEG y NOT). Esta decisión de diseño permite mantener la compatibilidad con los modos de direccionamiento establecidos para las instrucciones aritméticas de dos operandos (ADD, SUB y CMP), garantizando consistencia en la interfaz del simulador mientras se maximiza la funcionalidad dentro de las limitaciones impuestas por el esquema de codificación de 4 bits.

Esta solución representa un compromiso eficaz entre la simplicidad arquitectural y la capacidad funcional del simulador, permitiendo una mayor diversidad de operaciones sin comprometer la claridad pedagógica del diseño.

### Etapa de ejecución de instrucciones
Finalmente, se detallan los pasos correspondientes a las instrucciones restantes del repertorio de instrucciones:

- **Subrutinas**
  - **CALL `Dirección`**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección destino.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer la dirección e incrementar IP.
    6. **`ri` $\leftarrow$ `MBR` | `SP` $\leftarrow$ `SP` - 1** -  Guardar la dirección en ri y decrementar SP.
    7. **`MAR` $\leftarrow$ `SP` | `MBR` $\leftarrow$ `IP`** - Preparar para apilar.
    8. **`write(Memoria[MAR])` $\leftarrow$ `MBR` | `IP` $\leftarrow$ `ri`** - Guardar IP en la pila y saltar a la subrutina.
  - **RET**
    4. **`MAR` $\leftarrow$ `SP`** – Obtener dirección de retorno desde la pila.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer la dirección de retorno.
    6. **`IP` $\leftarrow$ `MBR`| `SP` $\leftarrow$ `SP` + 1** – Restaurar IP y actualizar SP.

- **Interrupciones**
  - **INT `Dirección`**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección destino.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer la dirección e incrementar IP.
    6. **`ri` $\leftarrow$ `MBR` | `SP` $\leftarrow$ `SP` - 1** – Guardar la dirección en ri y decrementar SP.
    7. **`MAR` $\leftarrow$ `SP` | `MBR` $\leftarrow$ `Flags`** – Preparar para apilar los registros de estado.
    8. **`write(Memoria[MAR])` $\leftarrow$ `MBR` | update(Flags I=0)** – Guardar los registros de estado y desactivar interrupciones.
    9. **`MBR` $\leftarrow$ `IP` | `SP` $\leftarrow$ `SP` - 1** – Guardar IP en la pila.
    10. **`MAR` $\leftarrow$ `SP`** – Preparar para apilar.
    11. **`write(Memoria[MAR])` $\leftarrow$ `MBR`** - Guardar en la pila.
    12. **`MAR` $\leftarrow$ `ri`** - Obtener dirección rutina.
    13. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer la dirección.
    14. **`IP` $\leftarrow$ `MBR`** – Asigno dirección de la rutina de interrupción.
  - **IRET**
    4. **`MAR` $\leftarrow$ `SP`** – Obtener dirección de retorno desde la pila
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer la dirección de retorno.
    6. **`IP` $\leftarrow$ `MBR` | `SP` $\leftarrow$ `SP` + 1** – Restaurar IP y actualizar SP.
    7. **`MAR` $\leftarrow$ `SP`** – Preparar para leer los registros de estado.
    8. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer los registros de estado
    9. **`Flags` $\leftarrow$ `MBR` | `SP` $\leftarrow$ `SP` + 1** – Restaurar los registros de estado y actualizar SP.
  - **CLI**
    4. **update(Flags I=0)** – Desactivar interrupciones.
  - **STI**
    4. **update(Flags I=1)** – Activar interrupciones.
- **E/S**
  - **OUT**
    - Direccion destino en registro **OUT DL, AL**
        4. **`MAR` $\leftarrow$ `DL`** – Obtener dirección destino.
        5. **`MBR` $\leftarrow$ `AL`** – Preparar el contenido a escribir.
        6. **`write(E-S[MAR])` $\leftarrow$ `MBR`** – Escribir el contenido en el puerto de E/S.
    - Direccion destino inmediato **OUT inmediato, AL**  
        4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección del dato inmediato.
        5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer el dato e incrementar IP.
        6. **`MAR` $\leftarrow$ `MBR`** – Preparar la dirección destino.
        7. **`MBR` $\leftarrow$ `AL`** – Preparar el contenido a escribir.
        8. **`write(E-S[MAR])` $\leftarrow$ `MBR`** – Escribir el contenido en el puerto de E/S.
  - **IN**
    - Direccion destino en registro **IN AL, DL**
      4. **`MAR` $\leftarrow$ `DL`**  – Obtener dirección del puerto de entrada.
      5. **`MBR` $\leftarrow$ `read(E-S[MAR])`** – Leer el contenido del puerto.
      6. **`AL` $\leftarrow$ `MBR`** – Almacenar el contenido en AL.
    - Direccion destino inmediato **IN  AL, inmediato**
      4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección del dato inmediato.
      5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer el dato e incrementar IP.
      6. **`MAR` $\leftarrow$ `MBR`** – Preparar la dirección del puerto de entrada..
      7. **`MBR` $\leftarrow$ `read(E-S[MAR])`** – Leer el contenido del puerto.
      8. **`AL` $\leftarrow$ `MBR`** – Almacenar el contenido en AL.
- **Pila**
  - **POP Rx**
    4. **`MAR` $\leftarrow$ `SP`** – Obtener dirección de la pila.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer el contenido de la pila.
    6. **`Rx` $\leftarrow$ `MBR`** | `SP` $\leftarrow$ `SP` + 1 – Almacenar el contenido en Rx y actualizar SP.
  - **PUSH Ry**
    4. **`MAR` $\leftarrow$ `SP`** – Preparar la dirección de la pila.
    5. **`MBR` $\leftarrow$ `Ry`** | `SP` $\leftarrow$ `SP` - 1 – Preparar el contenido a escribir y actualizar SP.
    5. **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir el contenido en la pila.

- **Operaciones Lógicas y Aritméticas**
  - **Operaciones con dos operandos (AND, OR, XOR)**
  -   Siguen los mismos pasos de ejecución que las operaciones aritméticas ADD y SUB, con la diferencia en la operación realizada por la ALU.

  - **Operaciones con un operando (NOT, NEG, INC, DEC)**
    - **Destino en registro (`Rx`)**
      - **INC `Rx`** 
        4. **`Rx`  $\leftarrow$ `Rx` + 1 | update(Flags)** - Incrementar el valor del registro y actualizar los flags.
      - **DEC `Rx`** 
        4. **`Rx`  $\leftarrow$ `Rx` - 1 | update(Flags)** - Decrementar el valor del registro y actualizar los flags.
      - **NOT `Rx`** 
        4. **`Rx`  $\leftarrow$ NOT `Rx` | update(Flags)** - Realizar la operación lógica NOT y actualizar los flags.
      - **NEG `Rx`** 
        4. **`Rx`  $\leftarrow$ CA2 `Rx` | update(Flags)** - Realizar la operación de complemento a dos y actualizar los flags.
    - **Destino en memoria (`[Dirección]` o `[BL]`)**
      - **Modo Directo (`[Dirección]`)**
        4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección destino.
        5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer la dirección e incrementar IP.
        6. **`MAR` $\leftarrow$ `MBR`** – Transferir dirección a MAR.
        7. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer el dato.
        8. Ejecutar la operación:
                  - INC: **`MBR` $\leftarrow$ `MBR` + 1 | update(Flags)**
                  - DEC: **`MBR` $\leftarrow$ `MBR` - 1 | update(Flags)**
                  - NOT: **`MBR` $\leftarrow$ NOT `MBR` | update(Flags)**
                  - NEG: **`MBR` $\leftarrow$ CA2 `MBR` | update(Flags)**
        9. **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.
      - **Modo Indirecto (`[BL]`)**
        4. **`MAR` $\leftarrow$ `BL`** – Transferir dirección de destino (en BL) a MAR.
        5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer el dato.
        6. Ejecutar la operación (igual que en el caso anterior).
        7. **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.


###  Pila y subrutinas 
El procesador implementa una pila como método de almacenamiento, accesible tanto por el usuario como por la CPU para su funcionamiento interno. La pila opera bajo el esquema _Last In, First Out_ (LIFO), es decir, el último elemento en ingresar es el primero en salir. Está ubicada en la memoria principal, comenzando en la dirección más alta (`FFh`) y creciendo hacia direcciones más bajas (`FEh`, `FCh`, etc.). El tope de la pila se gestiona mediante el registro `SP`, y cada elemento almacenado ocupa 8 bits.

Además, el procesador permite el uso de subrutinas, que son fragmentos de código reutilizables y pueden ser invocados desde cualquier parte del programa. Para llamar a una subrutina se utiliza la instrucción [`CALL`], que apila el valor actual de `IP` y salta a la dirección de la subrutina, modificando el `IP` para apuntar a la primera instrucción de la misma. El retorno se realiza mediante la instrucción [`RET`], que desapila la dirección previamente guardada y restaura el `IP`, permitiendo continuar la ejecución justo después de la llamada.

Ejemplo de subrutina:
```{r  codecall, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
      mov al, 1
      mov bl, 2
      mov cl, 3
      call sum3
      ; ax = 6
      hlt

      ; suma al, bl y cl
      sum3: add al, bl
            add al, cl
            ret\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
      mov al, 1
      mov bl, 2
      mov cl, 3
      call sum3
      ; ax = 6
      hlt

      ; suma al, bl y cl
      sum3: add al, bl
            add al, cl
            ret
```")
}
```

###  Interrupciones y llamadas al sistema
El simulador VonSim8 incorpora un teclado y una pantalla como dispositivos de entrada y salida, permitiendo la interacción básica entre el usuario y el sistema para la entrada de datos y la visualización de resultados.

```{r tecladopantalla, echo=FALSE, fig.cap="Teclado y pantalla", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/tecladopantalla.png")
```

El vector de interrupciones está predefinido en posiciones reservadas de la memoria principal, donde se almacenan las direcciones de las rutinas del sistema para interactuar con el teclado y la pantalla. En el caso de las interrupciones por software, el número de interrupción se indica como operando en la instrucción `INT`. Al producirse una interrupción, el procesador ejecuta la rutina asociada al número de interrupción, cuya dirección de inicio se obtiene del vector de interrupciones. Este vector ocupa las celdas de memoria desde `00h` hasta `07h`, y cada elemento tiene 1 byte de longitud, correspondiendo cada uno a la dirección de inicio de la rutina respectiva.

El procesador admite interrupciones tanto por hardware como por software, generadas por el PIC o por la instrucción `INT`, respectivamente. Para que las interrupciones por hardware sean atendidas, el procesador debe tener habilitada la bandera de interrupciones (I=1). En ambos casos, se debe proporcionar un número de interrupción entre `0` y `7`.

El procedimiento que sigue el procesador ante una interrupción es el siguiente:

  1. obtiene el número de la interrupción (0-7),
  2. apila el registro `Flags`,
  3. inhabilita las interrupciones `I=0`,
  4. apila el registro `IP`,
  5. obtiene la dirección de la rutina de interrupción desde el vector de interrupciones,
  6. carga en el `IP` la dirección de la rutina de interrupción.

La rutina de interrupción se ejecuta como una subrutina, pero finaliza con la instrucción `IRET` en lugar de `RET`.

###  Llamadas al sistema
El simulador permite realizar llamadas al sistema (syscalls) mediante interrupciones, utilizando el número de interrupción correspondiente. Los números de interrupción reservados para llamadas al sistema son:

- `INT 0`: termina la ejecución del programa (equivalente a `HLT`);
- `INT 6`: lee un carácter del teclado;
- `INT 7`: escribe una cadena de caracteres en pantalla.

Las direcciones del vector de interrupciones asociadas a estas llamadas están protegidas por el sistema y no pueden ser modificadas por el usuario. El contenido de las rutinas correspondientes se encuentra almacenado en el monitor del sistema en las direcciones `A0h`, `B0h` y `C0h`, respectivamente.

### Pantalla
La pantalla es un dispositivo de salida que permite mostrar caracteres. La forma de comunicarse con la pantalla es mediante una llamada al sistema. Esto es así por simplicidad, ya que una pantalla real es mucho más compleja.

Con la llamada INT 7 se escribe una cadena de caracteres en la pantalla. Recibe dos parámetros:

AL: longitud de la cadena a imprimir
BL: dirección de memoria donde empieza la cadena

Ejemplo de hola mundo en lenguaje ensamblador para el simulador VonSim8:

```{r  codepantalla, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
cadena DB `Hola!`
MOV BL, offset cadena
MOV AL, 5
INT 7
; Se imprime Hola! (sin las comillas) en la pantalla.
HLT\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
cadena DB `Hola!`
MOV BL, offset cadena
MOV AL, 5
INT 7
; Se imprime Hola! (sin las comillas) en la pantalla.
HLT
```")
}
```

Hay tres caracteres especiales:

  - el carácter de retroceso (`BS`, 8 en decimal) borra el carácter previo;
  - el carácter de salto de línea (`LF`, 10 en decimal) imprime, en efecto, un salto de línea — útil para no imprimir todo en una sola línea;
  - el carácter de _form feed_ (`FF`, 12 en decimal) limpia la pantalla.

### Teclado
El teclado se modela como un vector de 16 posiciones, cada una capaz de almacenar un carácter ASCII. La pantalla, por su parte, permite visualizar caracteres, facilitando así la comprensión del manejo de entrada y salida de datos en una arquitectura computacional simplificada.

El teclado es un dispositivo de entrada que permite al usuario ingresar caracteres al sistema. La forma de comunicarse con el teclado es mediante una llamada al sistema. Esto es así por simplicidad, ya que un teclado real es mucho más complejo.

Con la llamada INT 6 se detiene la ejecución del código hasta que se presione una tecla en el teclado. El carácter que correspona será guardado en la dirección de memoria almacenada en BL según su representación en ASCII.

```{r  codeteclado, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
car db 0
mov bl, offset car
int 6
hlt

; El carácter escrito se almacenó en 'car'.
; Por ejemplo, si el usuario presionó la tecla 'a', entonces
; se almacena el valor 61h en 'car'.\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
car db 0
mov bl, offset car
int 6
hlt

; El carácter escrito se almacenó en 'car'.
; Por ejemplo, si el usuario presionó la tecla 'a', entonces
; se almacena el valor 61h en 'car'.
```")
}
```

### Puertos de E/S
La memoria de entrada/salida está completamente separada de la memoria principal. Para interactuar con ella, se emplean exclusivamente las instrucciones [IN] y [OUT]. Cuando se requiere acceder a un módulo de entrada/salida, la [CPU] activa la señal IO/M, lo que provoca que un selector de chips (chip select) interprete la dirección presente en el bus de direcciones y envíe la señal de activación al módulo correspondiente.

El rango de direcciones asignado a la memoria de entrada/salida abarca desde `00h` hasta `FFh`, lo que permite un total de 256 direcciones. A continuación, se presentan las direcciones de entrada/salida disponibles en el simulador, todas de 8 bits:

```{r tpuertos, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)


# Crear los datos de la tabla reorganizada
tpuertos <- data.frame(
  Modulo = c(
    "Timer", "",
    "PIC", "", "", "", "", "", "", "",
    "PIO", "", "", "",
    "Handshake", ""
  ),
  Direccion = c(
    "10h", "11h", "20h", "21h", "22h", "23h", "24h", "25h", "26h", "27h",
    "28h", "29h", "2Ah", "2Bh", "40h", "41h"
  ),
  Nombre = c(
    "CONT", "COMP", "EOI", "IMR", "IRR", "ISR", "INT0", "INT1", "INT2", "INT3",
    "PA", "PB", "CA", "CB", "DATA", "STATE"
  ),
  stringsAsFactors = FALSE
)

# Crear la tabla con el nuevo orden
tabla_puertos <- kable(tpuertos,
  format               = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption              = "Módulos, direcciones y nombres del simulador",
  col.names            = c("Módulo", "Dirección", "Nombre"),
  booktabs             = TRUE,
  escape               = FALSE,
  align                = c("c", "c", "c"))

if (knitr::is_latex_output()) {
  tabla_puertos %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10,
      position = "center"
    ) %>%
    column_spec(1, width = "3cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "2cm") %>%
    column_spec(3, width = "3cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    # Agregar espacios después de cada grupo de módulos
    row_spec(2, extra_latex_after = "\\addlinespace[5pt]") %>%   # Después de Timer
    row_spec(14, extra_latex_after = "\\addlinespace[5pt]") %>%  # Después de PIC
    row_spec(18, extra_latex_after = "\\addlinespace[5pt]") %>%  # Después de PIO
    # Resaltar las filas de inicio de cada módulo
    row_spec(c(1, 3, 11, 15), background = "#F0F0F0")
} else {
  tabla_puertos %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "16em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "12em") %>%
    column_spec(3, width = "16em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2") %>%
    # Resaltar las filas de inicio de cada módulo
    row_spec(c(1, 3, 11, 15), background = "#F0F0F0")
}
```

### Instrucciones IN y OUT
La comunicación con los módulos de entrada/salida se realiza a través de puertos, que son direcciones específicas dentro del espacio de direcciones del procesador. En este simulador, se implementan dos instrucciones fundamentales para gestionar esta comunicación:

  - `OUT puerto, AL`: envía el contenido del registro `AL` al puerto especificado. El puerto es una dirección de 8 bits, lo que permite un total de 256 puertos diferentes (de `00h` a `FFh`). Esta instrucción se utiliza para transmitir datos a dispositivos externos, como impresoras o pantallas.
  - `IN AL, puerto`: recibe un byte desde el puerto especificado y lo almacena en el registro `AL`.  Al igual que la instrucción `OUT`, el puerto es una dirección de 8 bits.

### Módulo PIO (Leds e Interruptores)
El módulo de entrada/salida programada (Programmed Input-Output, PIO) actúa como interfaz entre la CPU y los dispositivos periféricos genéricos. Su diseño está basado en el controlador PPI 8255 de Intel, específicamente en su modo `0`, pero incorpora modificaciones orientadas a simplificar su funcionamiento para fines educativos [@intel8086manual; @godse2020microprocessor].

El módulo cuenta con dos puertos bidireccionales de 8 bits (A y B) que pueden ser configurados de manera independiente. Su arquitectura incluye cuatro registros accesibles:

  - PA (dirección 30h en el espacio de memoria E/S): registro de datos del puerto A
  - PB (dirección 31h en el espacio de memoria E/S): registro de datos del puerto B
  - CA (dirección 32h en el espacio de memoria E/S): registro de configuración del puerto A
  - CB (dirección 33h en el espacio de memoria E/S): registro de configuración del puerto B

La configuración de cada puerto se define a través de sus respectivos registros de control (CA y CB). Cada bit del registro de configuración determina la dirección del bit correspondiente en el puerto de datos: un valor `0` configura el bit como salida, mientras que un valor `1` lo configura como entrada. Por ejemplo, si CA = 00001111b, los cuatro bits más significativos del puerto A funcionarán como salidas, y los cuatro bits menos significativos como entradas. El puerto B opera de manera idéntica mediante su registro CB.

Este módulo PIO puede conectarse a diferentes tipos de dispositivos periféricos, como LEDs y interruptores, o a dispositivos más complejos como una impresora, proporcionando así una interfaz versátil para la comunicación con el mundo exterior.

#### Leds
Los diodos emisores de luz (LEDs) funcionan como dispositivos de salida y están conectados al puerto B del módulo PIO. Su control se realiza mediante la manipulación del registro de datos PB (dirección 31h) en conjunto con el registro de configuración CB (dirección 33h).

Para que los LEDs respondan correctamente, es necesario configurar previamente el puerto B como salida escribiendo el valor apropiado en el registro CB. Una vez configurado correctamente el PIO, cualquier modificación en el valor del registro PB se reflejará inmediatamente en el estado de los LEDs correspondientes. En caso de que la configuración del puerto sea incorrecta o se omita este paso, los LEDs permanecerán apagados independientemente de los valores escritos en PB.

Esta configuración permite controlar individualmente cada LED mediante los bits del puerto, ofreciendo flexibilidad para crear patrones luminosos o indicadores visuales en aplicaciones educativas y de demostración.

Las luces o LEDs están conectadas al puerto PB/CB del PIO y funcionan como dispositivos de salida. Su estado solo puede modificarse alterando el valor del puerto PB. Estos cambios se reflejarán en las luces si el PIO está configurado correctamente; de lo contrario, las luces permanecerán apagadas.

```{r codeluces, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
; Enciende las luces (una sí, una no): 1010 1010b
; 31h = PB --> puerto de datos para las luces (LEDs)
; 33h = CB --> puerto de control para las luces

; Configura todos los bits de PB como salida para controlar las luces
mov al, 0                ; 0000 0000b: todos los bits de PB en modo salida
out 33h, al              ; Escribe en CB para configurar PB como salida

; Enciende las luces alternadas: 1010 1010b (170 decimal)
mov al, 170              ; 1010 1010b: enciende LEDs pares, apaga impares
out 31h, al              ; Escribe el valor en PB para actualizar las luces

hlt                      ; Detiene la ejecución del programa\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
; Enciende las luces (una sí, una no): 1010 1010b
; 31h = PB --> puerto de datos para las luces (LEDs)
; 33h = CB --> puerto de control para las luces

; Configura todos los bits de PB como salida para controlar las luces
mov al, 0                ; 0000 0000b: todos los bits de PB en modo salida
out 33h, al              ; Escribe en CB para configurar PB como salida

; Enciende las luces alternadas: 1010 1010b (170 decimal)
mov al, 170              ; 1010 1010b: enciende LEDs pares, apaga impares
out 31h, al              ; Escribe el valor en PB para actualizar las luces

hlt                      ; Detiene la ejecución del programa
```")
}
```

#### interruptores
Los interruptores (también denominados llaves) funcionan como dispositivos de entrada conectados al puerto A del módulo PIO. Su operación se gestiona mediante el registro de datos PA (dirección 30h) y el registro de configuración CA (dirección 32h).

Para que los interruptores operen correctamente, es fundamental configurar previamente el puerto A como entrada mediante el registro CA. Una vez establecida la configuración apropiada, cualquier cambio en el estado físico de los interruptores se reflejará automáticamente en los bits correspondientes del registro PA, permitiendo al programa leer su estado actual.

Es importante destacar que la comunicación es unidireccional desde los dispositivos hacia el procesador: aunque es posible escribir valores directamente en el registro PA mediante software, estos cambios no alterarán el estado físico de los interruptores. Los dispositivos de entrada mantienen su estado independientemente de las modificaciones realizadas por programa en sus registros asociados, garantizando así la integridad de la información proveniente del mundo exterior.

```{r  codellaves, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
; Leer el valor de las llaves como una contraseña 
; hasta que el usuario la adivine

clave db 15            ; Contraseña esperada: 00001111 (en decimal 15)
mensaje_ok db 'Bienvenido!' ; Mensaje si la contraseña es correcta

; Configurar PA (Puerto A) como entrada
mov al, 15   ; 00001111b: configura los primeros 4 bits de PA como entrada
out 32h, al            ; Escribe en CA para configurar PA

bucle:
  in al, 30h           ; Lee el valor actual de las llaves desde PA
  cmp al, clave        ; Compara el valor leído con la contraseña
  jz Mostrar_Mensaje   ; Si coincide, salta a Mostrar_Mensaje
  jmp bucle            ; Si no coincide, vuelve a intentar

Mostrar_Mensaje:
  mov bl, offset mensaje_ok ; BL apunta al mensaje de éxito
  mov al, 11           ; Longitud del mensaje (tiene 11 caracteres)
  int 7
  hlt                  ; Detiene la ejecución del programa\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
; Leer el valor de las llaves como una contraseña hasta que el usuario la adivine

clave db 15               ; Contraseña esperada: 00001111 (en decimal 15)
mensaje_ok db 'Bienvenido!' ; Mensaje a mostrar si la contraseña es correcta

; Configurar PA (Puerto A) como entrada
mov al, 15                ; 00001111b: configura los primeros 4 bits de PA como entrada
out 32h, al               ; Escribe en CA para configurar PA

bucle:
    in al, 30h            ; Lee el valor actual de las llaves desde PA
    cmp al, clave         ; Compara el valor leído con la contraseña
    jz Mostrar_Mensaje    ; Si coincide, salta a Mostrar_Mensaje
    jmp bucle             ; Si no coincide, vuelve a intentar

Mostrar_Mensaje:
    mov bl, offset mensaje_ok ; BL apunta al mensaje de éxito
    mov al, 11                ; Longitud del mensaje tiene 11 caracteres
    int 7
    hlt                       ; Detiene la ejecución del programa
```")
}
```

### Módulo handshake (Impresora)
El módulo Handshake es un controlador especializado diseñado para facilitar la comunicación con impresoras que utilizan el protocolo Centronics. Su diseño se inspira en el controlador PPI 8255 de Intel, operando en modo "1", pero incluye modificaciones específicas para simplificar su uso y comprensión en entornos educativos.

El módulo cuenta con una arquitectura simplificada basada en dos registros de 8 bits:

  - **Registro de datos**: ubicado en la dirección 40h del espacio de memoria de E/S.
  - **Registro de estado**: ubicado en la dirección 41h del espacio de memoria de E/S.

La estructura de estos registros se organiza de la siguiente manera:

```
Datos  = DDDD DDDD
Estado = I___ __SB
```

#### Funcionamiento del registro de datos

El registro de datos almacena el carácter que se desea imprimir, codificado en formato ASCII. Una característica destacada del módulo Handshake es su capacidad de automatización: cada vez que la CPU escribe un valor en este registro, el controlador genera automáticamente un flanco ascendente en la señal strobe, iniciando el proceso de impresión sin necesidad de intervención adicional por parte del software.

#### Funcionamiento del registro de estado

El registro de estado gestiona las señales de control y supervisión del protocolo de comunicación. Sus principales componentes son:

  - **Bits S y B (strobe y busy)**: los dos bits menos significativos controlan las señales de comunicación, con diferencias clave respecto a la implementación en el PIO:
    - El bit busy es de solo lectura y refleja automáticamente el estado de la impresora
    - El bit strobe permanece normalmente en 0 y es gestionado automáticamente por el módulo. Cuando la CPU escribe un 1 en el bit strobe, se genera un flanco ascendente que transmite los datos almacenados en el registro de datos, retornando automáticamente a 0.
  - **Bit I (interrupción)**: El bit más significativo controla el sistema de interrupciones del módulo. Cuando este bit está habilitado (I=1) y la impresora se encuentra disponible (B=0), el módulo Handshake genera una interrupción por hardware a través de la línea INT2 del controlador PIC, notificando al sistema que la impresora está lista para recibir nuevos datos.

Esta implementación ofrece una interfaz intuitiva para el control de impresoras, automatizando aspectos críticos del protocolo de comunicación y manteniendo la flexibilidad necesaria para comprender los fundamentos de la interacción con dispositivos periféricos.

#### Ejemplo de uso del módulo Handshake con sondeo
Para imprimir utilizando el módulo Handshake, se deben seguir los siguientes pasos:

  1. Verificar que el buffer no esté lleno (flag busy).
  2. Escribir el carácter en el registro de datos.

Además de los caracteres ASCII comunes, el módulo admite caracteres especiales útiles para la impresión:
  - Salto de línea (`LF`, 10 en decimal): Imprime un salto de línea, evitando que todo el texto se imprima en una sola línea.
  - Form feed (`FF`, 12 en decimal): Limpia la impresora, equivalente a arrancar una hoja.

A continuación, se presenta un ejemplo en ensamblador para imprimir la cadena "Hola" utilizando el módulo Handshake:


```{r code Handshakesondeo, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
; Imprime el string 'Hola' en la impresora usando sondeo

dato DB 'Hola', 0         ; String a imprimir, terminado en (carácter nulo)

HS_DATA   EQU 40h         ; Dirección del registro de datos del Handshake
HS_STATUS EQU 41h         ; Dirección del registro de estado del Handshake

;  Deshabilita las interrupciones del Handshake (bit 7 en 0) 
IN  AL, HS_STATUS
AND AL, 01111111b         ; Fuerza el bit 7 a 0 (sin interrupciones)
OUT HS_STATUS, AL

;  Inicializa el puntero al string 
MOV BL, OFFSET dato       ; BL apunta al primer carácter del string

; - Bucle principal: espera espacio en el buffer e imprime 
Sondeo:
    IN  AL, HS_STATUS
    AND AL, 00000001b     ; Lee el flag busy (bit 0) 1=lleno, 0=libre
    JZ  ImprimirCadena   ; Si busy=0, hay espacio y puede imprimir
    JMP Sondeo            ; Si busy=1, espera hasta que haya espacio

ImprimirCadena:
    MOV AL, [BL]          ; Carga el siguiente carácter del string
    CMP AL, 0             ; Es el final del string carácter nulo
    JZ fin                ; Si sí, termina el programa

    OUT HS_DATA, AL       ; Envía el carácter al Handshake

    INC BL                ; Avanza al siguiente carácter del string
    JMP Sondeo            ; Repite el proceso para el próximo carácter

fin:
    HLT   ; Detiene la ejecución\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
; Imprime el string 'Hola' en la impresora usando sondeo

dato DB 'Hola', 0         ; String a imprimir, terminado en 0 (carácter nulo)

HS_DATA   EQU 40h         ; Dirección del registro de datos del Handshake
HS_STATUS EQU 41h         ; Dirección del registro de estado del Handshake

;  Deshabilita las interrupciones del Handshake (bit 7 en 0) 
IN  AL, HS_STATUS
AND AL, 01111111b         ; Fuerza el bit 7 a 0 (sin interrupciones)
OUT HS_STATUS, AL

; Inicializa el puntero al string 
MOV BL, OFFSET dato       ; BL apunta al primer carácter del string

; Bucle principal: espera espacio en el buffer e imprime 
Sondeo:
    IN  AL, HS_STATUS
    AND AL, 00000001b     ; Lee el flag busy (bit 0): 1=lleno, 0=libre
    JZ  ImprimirCadena   ; Si busy=0, hay espacio y puede imprimir
    JMP Sondeo            ; Si busy=1, espera hasta que haya espacio

ImprimirCadena:
    MOV AL, [BL]          ; Carga el siguiente carácter del string
    CMP AL, 0             ; ¿Es el final del string? (carácter nulo)
    JZ fin                ; Si sí, termina el programa

    OUT HS_DATA, AL       ; Envía el carácter al registro de datos del Handshake

    INC BL                ; Avanza al siguiente carácter del string
    JMP Sondeo            ; Repite el proceso para el próximo carácter

fin:
    HLT   ; Detiene la ejecución
```")
}
```

Para mejorar la lectura del programa se utilizan constantes en ensamblador "EQU" para definir las direcciones de los puertos del módulo Handshake.

### Módulo PIC (Controlador de Interrupciones)
El Programmable Interrupt Controller (PIC) es un módulo que actúa como intermediario entre los dispositivos que generan interrupciones y la CPU. Dado que la CPU dispone de una única línea de entrada para interrupciones, el PIC se encarga de recibir solicitudes de múltiples dispositivos y multiplexarlas en esta línea única.

Este módulo está basado en el PIC 8259A de Intel, aunque se han realizado modificaciones para simplificar su funcionamiento y adaptarlo a fines educativos.

#### Líneas de interrupción
El PIC dispone de 4 líneas de interrupción, denominadas INT0 a INT3 (aunque no todas son utilizadas). Cada línea está asociada a un registro de 8 bits en la memoria de E/S. Por ejemplo, la línea INT0 corresponde a la dirección 24h, la línea INT1 a la dirección 25h, y así sucesivamente hasta la línea INT3, que utiliza la dirección 26h. En estos registros se almacena el número de interrupción asociado a cada línea.

Cuando un dispositivo o módulo solicita una interrupción, el PIC envía a la CPU el número de interrupción almacenado en el registro correspondiente, desacoplando así el número de línea del número de interrupción.

Las líneas están conectadas a los siguientes dispositivos:

```{r tPIC, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

tinterrupciones <- data.frame(
  `Línea` = c("INT0", "INT1", "INT2", "INT3"),
  `Módulo/Disp.` = c("[Tecla F10]", "[Timer]", "[Handshake]", "--")
)

tabla_kable <- kable(
  tinterrupciones,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Líneas de interrupción y dispositivos asociados",
  col.names = c("Línea", "Módulo/Disp."),
  booktabs = TRUE,
  escape = FALSE,
  align = c("c", "l")
)

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "2cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "7cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tinterrupciones)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "6em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "22em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

#### Registros de control
El PIC cuenta con tres registros adicionales para gestionar las interrupciones. Cada bit de estos registros corresponde a una línea de interrupción, donde el bit menos significativo representa la línea da bit corresponde con una línea de interrupción: el bit menos significativo corresponde a la línea  y el más significativo la línea `INT3`.

  - **Registro IMR (Interrupt Mask Register)**: Ubicado en la dirección `21h` de la memoria de E/S, este registro permite enmascarar (inhabilitar) líneas de interrupción. Si un bit está en 1, la línea correspondiente está enmascarada y no generará interrupciones en la CPU. Si el bit está en 0, la línea está habilitada. Este registro puede ser modificado por la CPU.

  - **Registro IRR (Interrupt Request Register)**: Ubicado en la dirección `22h`, este registro indica las interrupciones pendientes. Si un bit está en 1, la línea correspondiente tiene una interrupción pendiente. Este registro es de solo lectura para la CPU y es gestionado por el PIC.

  - **Registro ISR (In-Service Register)**: Ubicado en la dirección `23h`, este registro muestra qué interrupción está siendo atendida en un momento dado. Si un bit está en 1, la línea correspondiente está en servicio. Este registro también es de solo lectura para la CPU y es gestionado por el PIC.

#### Funcionamiento
Cuando una línea de interrupción se activa, el PIC la registra en el `IRR`. Si la línea no está enmascarada y no hay otra interrupción en servicio (es decir, si `ISR = 00h`), el PIC envía una señal de interrupción a la CPU activando la línea `INTR`.

El proceso de atención de la interrupción sigue estos pasos:

  1. La CPU responde a la señal `INTR` enviando un pulso por la línea `INTA`.
  2. Al recibir la señal, el PIC marca la línea como _in-service_ en el registro `ISR` y la elimina del registro `IRR`.
  3. El PIC envía a la CPU, a través del bus de datos, el número de interrupción correspondiente a la línea activa.
  4. La CPU envía un segundo pulso por la línea `INTA`.
  5. El PIC desactiva la línea `INTR`.

Para finalizar la atención de la interrupción, la CPU escribe el byte EOI (End of Interrupt) en la dirección 20h de la memoria de E/S. Al recibir este byte, el PIC desmarca la línea como in-service en el registro ISR. Si hay interrupciones pendientes, el PIC reactiva la línea INTR y repite el proceso.

Este PIC no admite interrupciones anidadas. Si ocurre una nueva interrupción mientras otra está siendo atendida, la nueva solicitud se encola en el registro IRR y se procesará una vez que la interrupción en curso haya finalizado, sin importar su prioridad. 

#### Prioridades
Cuando hay múltiples interrupciones pendientes, el PIC atiende primero la de mayor prioridad. La prioridad de cada línea está determinada por su número de interrupción: las líneas con números más bajos tienen mayor prioridad. Por ejemplo, la línea `INT0` tiene mayor prioridad que la línea `INT1`.
  
#### Ejemplo de uso del módulo Handshake con interrupciones
A continuación, se presenta un ejemplo en ensamblador que utiliza el módulo Handshake junto con el PIC para imprimir la cadena "Hola" mediante interrupciones por hardware. En este ejemplo, se configura el PIC para que solo la línea `INT2` (asociada al módulo Handshake) esté habilitada, y se define una rutina de interrupción que se ejecuta automáticamente cuando la impresora está lista para recibir un nuevo carácter.

```{r codeHandshakeint, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
; 
; PROGRAMA Impresión de string usando Handshake con interrupciones
; DESCRIPCIÓN Imprime el string 'Hola' en la impresora utilizando el módulo
;              Handshake con interrupciones por hardware (INT2)
; 

; SECCIÓN DE DATOS 
mensaje     db 'Hola', 0    ; String a imprimir, terminado en carácter nulo
restantes   db 4           ; Contador de caracteres restantes por imprimir
puntero     db 0           ; Puntero al siguiente carácter (8 bits)

;  CONSTANTES DE HANDSHAKE 
HS_DATA     EQU 40h        ; Registro de datos del Handshake (puerto E-S)
HS_STATUS   EQU 41h        ; Registro de estado del Handshake (puerto E-S)

; CONSTANTES DE INTERRUPCIONES 
ID          EQU 2          ; ID de la interrupción para Handshake (0-7)
IMR         EQU 21h        ; Registro de máscara de interrupciones del PIC
EOI         EQU 20h        ; Puerto para enviar End Of Interrupt al PIC
INT2        EQU 26h        ; Puerto para configurar la línea INT2

; PROGRAMA PRINCIPAL



;  1) CONFIGURACIÓN INICIAL 
cli                        ; Deshabilitar interrupciones globales

;  2) CONFIGURACIÓN DEL HANDSHAKE
; Habilitar interrupciones del Handshake (bit 7 = 1)
in  al, HS_STATUS         ; Leer estado actual del Handshake
or  al, 10000000b         ; Activar bit 7 (habilitar interrupciones)
out HS_STATUS, al         ; Escribir configuración al Handshake

;  3) CONFIGURACIÓN DEL PIC (Controlador de Interrupciones)

; 3.1) Configurar máscara de interrupciones - Solo habilitar INT2
mov al, 11111011b         ; Máscara: habilita solo INT2 (bit 2=0),
                          ; resto deshabilitado
out IMR, al               ; Aplicar máscara al PIC

; 3.2) Asignar ID de interrupción a la línea INT2
mov al, ID                ; Cargar ID de interrupción (2)
out INT2, al              ; Configurar línea INT2 con este ID

; 3.3) Configurar vector de interrupción en memoria
mov bl, ID                ; BL = posición en tabla de vectores (ID=2)
mov [bl], int2_handler    ; Almacenar dirección de rutina en vector[2]

;  4) INICIALIZACIÓN DE VARIABLES 
mov al, offset mensaje    ; AL = dirección del primer carácter del string
mov puntero, al           ; Guardar en variable puntero

;  5) ENVIAR PRIMER CARÁCTER PARA INICIAR EL PROCESO 
; Esperar que la impresora esté lista
esperar_listo:
    in al, HS_STATUS
    and al, 00000001b     ; Verificar bit busy
    jnz esperar_listo     ; Si busy=1, esperar

; Enviar primer carácter
mov bl, puntero           ; Cargar puntero
mov al, [bl]              ; Obtener primer carácter
cmp al, 0                 ; Es string vacío
jz fin                    ; Si está vacío, terminar

out HS_DATA, al           ; Enviar primer carácter
inc bl                    ; Avanzar puntero
mov puntero, bl           ; Guardar puntero actualizado
dec restantes             ; Decrementar contador

;  6) HABILITAR INTERRUPCIONES Y ESPERAR 
sti                       ; Habilitar interrupciones globales

;  7) BUCLE DE ESPERA
; El programa principal espera hasta que se impriman todos los caracteres
bucle_espera:
    cmp restantes, 0      ; Quedan caracteres por imprimir
    jnz bucle_espera      ; Si quedan, seguir esperando

;  8) FINALIZACIÓN 
fin:
hlt                       ; Detener ejecución del programa


; RUTINA DE INTERRUPCIÓN INT2 - HANDSHAKE
; DESCRIPCIÓN Se ejecuta automáticamente cuando la impresora está lista
;              para recibir un nuevo carácter (busy = 0)
; ENTRADA Variable puntero = dirección del siguiente carácter a imprimir
; SALIDA Carácter enviado a la impresora, puntero actualizado

org 80h
int2_handler:
    ;  PRESERVAR CONTEXTO 
    push al               ; Guardar registros que se van a modificar
    push bl

    ;  VERIFICAR SI HAY MÁS CARACTERES 
    cmp restantes, 0      ; Quedan caracteres por imprimir
    jz fin_interrupcion   ; Si no quedan, terminar

    ;  OBTENER SIGUIENTE CARÁCTER 
    mov bl, puntero       ; BL = puntero al siguiente carácter
    mov al, [bl]          ; AL = carácter apuntado por BL
    cmp al, 0             ; Es el carácter nulo (fin de string)
    jz fin_interrupcion   ; Si es 0, terminar

    ;  ENVIAR CARÁCTER A LA IMPRESORA 
    out HS_DATA, al       ; Escribir carácter en el Handshake

    ;  ACTUALIZAR PUNTEROS Y CONTADORES 
    inc bl                ; Avanzar al siguiente carácter
    mov puntero, bl       ; Guardar puntero actualizado
    dec restantes         ; Decrementar contador de caracteres restantes

fin_interrupcion:
    ; - ENVIAR EOI AL PIC 
    mov al, 20h           ; Señal de fin de interrupción
    out EOI, al           ; Notificar al PIC

    ;  RESTAURAR CONTEXTO 
    pop bl                ; Restaurar registros preservados
    pop al

    ;  RETORNO DE INTERRUPCIÓN 
    iret                  ; Retorno de interrupción
\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
; 
; PROGRAMA Impresión de string usando Handshake con interrupciones
; DESCRIPCIÓN Imprime el string 'Hola' en la impresora utilizando el módulo
;              Handshake con interrupciones por hardware (INT2)
; 

; SECCIÓN DE DATOS 
mensaje     db 'Hola', 0    ; String a imprimir, terminado en carácter nulo
restantes   db 4           ; Contador de caracteres restantes por imprimir
puntero     db 0           ; Puntero al siguiente carácter (8 bits)

;  CONSTANTES DE HANDSHAKE 
HS_DATA     EQU 40h        ; Registro de datos del Handshake (puerto E-S)
HS_STATUS   EQU 41h        ; Registro de estado del Handshake (puerto E-S)

; CONSTANTES DE INTERRUPCIONES 
ID          EQU 2          ; ID de la interrupción para Handshake (0-7)
IMR         EQU 21h        ; Registro de máscara de interrupciones del PIC
EOI         EQU 20h        ; Puerto para enviar End Of Interrupt al PIC
INT2        EQU 26h        ; Puerto para configurar la línea INT2

; PROGRAMA PRINCIPAL



;  1) CONFIGURACIÓN INICIAL 
cli                        ; Deshabilitar interrupciones globales

;  2) CONFIGURACIÓN DEL HANDSHAKE
; Habilitar interrupciones del Handshake (bit 7 = 1)
in  al, HS_STATUS         ; Leer estado actual del Handshake
or  al, 10000000b         ; Activar bit 7 (habilitar interrupciones)
out HS_STATUS, al         ; Escribir configuración al Handshake

;  3) CONFIGURACIÓN DEL PIC (Controlador de Interrupciones)

; 3.1) Configurar máscara de interrupciones - Solo habilitar INT2
mov al, 11111011b         ; Máscara: habilita solo INT2 (bit 2=0), resto deshabilitado
out IMR, al               ; Aplicar máscara al PIC

; 3.2) Asignar ID de interrupción a la línea INT2
mov al, ID                ; Cargar ID de interrupción (2)
out INT2, al              ; Configurar línea INT2 con este ID

; 3.3) Configurar vector de interrupción en memoria
mov bl, ID                ; BL = posición en tabla de vectores (ID=2)
mov [bl], int2_handler    ; Almacenar dirección de rutina en vector[2]

;  4) INICIALIZACIÓN DE VARIABLES 
mov al, offset mensaje    ; AL = dirección del primer carácter del string
mov puntero, al           ; Guardar en variable puntero

;  5) ENVIAR PRIMER CARÁCTER PARA INICIAR EL PROCESO 
; Esperar que la impresora esté lista
esperar_listo:
    in al, HS_STATUS
    and al, 00000001b     ; Verificar bit busy
    jnz esperar_listo     ; Si busy=1, esperar

; Enviar primer carácter
mov bl, puntero           ; Cargar puntero
mov al, [bl]              ; Obtener primer carácter
cmp al, 0                 ; Es string vacío
jz fin                    ; Si está vacío, terminar

out HS_DATA, al           ; Enviar primer carácter
inc bl                    ; Avanzar puntero
mov puntero, bl           ; Guardar puntero actualizado
dec restantes             ; Decrementar contador

;  6) HABILITAR INTERRUPCIONES Y ESPERAR 
sti                       ; Habilitar interrupciones globales

;  7) BUCLE DE ESPERA
; El programa principal espera hasta que se impriman todos los caracteres
bucle_espera:
    cmp restantes, 0      ; Quedan caracteres por imprimir
    jnz bucle_espera      ; Si quedan, seguir esperando

;  8) FINALIZACIÓN 
fin:
hlt                       ; Detener ejecución del programa


; RUTINA DE INTERRUPCIÓN INT2 - HANDSHAKE
; DESCRIPCIÓN Se ejecuta automáticamente cuando la impresora está lista
;              para recibir un nuevo carácter (busy = 0)
; ENTRADA Variable puntero = dirección del siguiente carácter a imprimir
; SALIDA Carácter enviado a la impresora, puntero actualizado

org 80h
int2_handler:
    ;  PRESERVAR CONTEXTO 
    push al               ; Guardar registros que se van a modificar
    push bl

    ;  VERIFICAR SI HAY MÁS CARACTERES 
    cmp restantes, 0      ; Quedan caracteres por imprimir
    jz fin_interrupcion   ; Si no quedan, terminar

    ;  OBTENER SIGUIENTE CARÁCTER 
    mov bl, puntero       ; BL = puntero al siguiente carácter
    mov al, [bl]          ; AL = carácter apuntado por BL
    cmp al, 0             ; Es el carácter nulo (fin de string)
    jz fin_interrupcion   ; Si es 0, terminar

    ;  ENVIAR CARÁCTER A LA IMPRESORA 
    out HS_DATA, al       ; Escribir carácter al registro de datos del Handshake

    ;  ACTUALIZAR PUNTEROS Y CONTADORES 
    inc bl                ; Avanzar al siguiente carácter
    mov puntero, bl       ; Guardar puntero actualizado
    dec restantes         ; Decrementar contador de caracteres restantes

fin_interrupcion:
    ; - ENVIAR EOI AL PIC 
    mov al, 20h           ; Señal de fin de interrupción
    out EOI, al           ; Notificar al PIC

    ;  RESTAURAR CONTEXTO 
    pop bl                ; Restaurar registros preservados
    pop al

    ;  RETORNO DE INTERRUPCIÓN 
    iret                  ; Retorno de interrupción
```")
}
```

#### Tecla F10
La tecla F10 es un dispositivo que habilita una forma rápida y práctica de ejecutar una interrupción por hardware. Está conectada a la línea `INT0` del [PIC]. Puede accionarse presionando la tecla F10 el teclado físicamente o haciendo clic en el "botón rojo de interrupción" en la interfaz gráfica.

```{r  codeteclaf10, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
; Programa Contador de pulsaciones de la tecla F10 usando interrupciones

; 1) Definiciones y variables

cantidad db 0   ; Variable almacena la cantidad de veces que se presionó F10

ID   EQU 1      ; ID de la interrupción para F10 (puede ser 0-7)
IMR  EQU 21h    ; Dirección del registro IMR (máscara de interrupciones)
EOI  EQU 20h    ; Dirección para enviar End Of Interrupt al PIC
INT0 EQU 24h    ; Dirección para configurar la línea INT0 (F10)

; 2) Inicialización del PIC y vector de interrupción

; 2.1) Habilitar solo la interrupción de F10 (INT0)
mov al, 11111110b      ; Habilita solo INT0 (bit 0 en 0),
                       ; el resto deshabilitado
out IMR, al

; 2.2) Configurar el ID de la interrupción para INT0
mov al, ID             ; Cargar el ID elegido para F10
out INT0, al

; 2.3) Asociar el vector de interrupción con la subrutina atenderf10
mov bl, ID             ; BL = ID de la interrupción
mov [bl], atenderf10   ; Vector de interrupción: dirección de la rutina

; 3) Bucle principal (espera activa)

loop: jmp loop         ; Espera indefinida 
                       ; (el programa queda esperando interrupciones)

hlt                    ; (Opcional) Detiene la CPU si sale del bucle

; 4) Rutina de atención de la interrupción F10

org 50h                ; Dirección de la subrutina de atención

atenderf10:
    inc cantidad     ; Incrementa el contador cada vez que se presiona F10
    mov al, 20h      ; Código de End Of Interrupt (EOI)
    out EOI, al      ; Notifica al PIC que terminó la atención
    iret             ; Retorna de la interrupción\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
; Programa Contador de pulsaciones de la tecla F10 usando interrupciones

; 1) Definiciones y variables

cantidad db 0          ; Variable almacena la cantidad de veces que se presionó F10

ID   EQU 1             ; ID de la interrupción para F10 (puede ser 0-7)
IMR  EQU 21h           ; Dirección del registro IMR (máscara de interrupciones)
EOI  EQU 20h           ; Dirección para enviar End Of Interrupt al PIC
INT0 EQU 24h           ; Dirección para configurar la línea INT0 (F10)

; 2) Inicialización del PIC y vector de interrupción

; 2.1) Habilitar solo la interrupción de F10 (INT0)
mov al, 11111110b      ; Habilita solo INT0 (bit 0 en 0), el resto deshabilitado
out IMR, al

; 2.2) Configurar el ID de la interrupción para INT0
mov al, ID             ; Cargar el ID elegido para F10
out INT0, al

; 2.3) Asociar el vector de interrupción con la subrutina atenderf10
mov bl, ID             ; BL = ID de la interrupción
mov [bl], atenderf10   ; Vector de interrupción dirección de la rutina

; 3) Bucle principal (espera activa)

loop: jmp loop         ; Espera indefinida (el programa queda esperando interrupciones)

hlt                    ; (Opcional) Detiene la CPU si sale del bucle

; 4) Rutina de atención de la interrupción F10

org 50h                ; Dirección de la subrutina de atención

atenderf10:
    inc cantidad       ; Incrementa el contador cada vez que se presiona F10
    mov al, 20h        ; Código de End Of Interrupt (EOI)
    out EOI, al        ; Notifica al PIC que terminó la atención
    iret               ; Retorna de la interrupción
```")
}
```

### Módulo timer
El timer es un módulo que dispone de dos registros internos:

  - Registro `CONT`: ubicado en la dirección `10h` de la memoria E/S.
  - Registro `COMP`: ubicado en la dirección `11h` de la memoria E/S.

Este módulo está basado en el PIT 8253 de Intel, aunque se han realizado modificaciones para simplificar su funcionamiento. El registro `COMP` permite establecer el valor de comparación con `CONT`. Si se escribe un valor de `0` en `COMP`, el timer se desactiva y no genera interrupciones. Cualquier otro valor habilita el timer y permite su funcionamiento normal.

El reloj es un dispositivo que hace tic cada segundo. Al hacer tic, incrementa el registro `CONT` del [_timer_] en uno.

```{r  codetimer, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
; Programa Imprime 'Hola' a los 10 segundos de iniciado y luego termina.
; Utiliza la interrupción del TIMER (ID = 5).

mensaje db 'Hola'        ; Mensaje a imprimir
imprimio db 0            ; Flag para saber si ya imprimió

; Definición de direcciones de registros de dispositivos
CONT equ 10h             ; Registro de conteo del timer
COMP equ 11h             ; Registro de comparación del timer

EOI  equ 20h             ; End Of Interrupt (para PIC)
IMR  equ 21h             ; Interrupt Mask Register (PIC)
INT1 equ 25h             ; Registro de vector de interrupción 1

;  Habilitar interrupciones del timer 
; IMR = 1111 1101b (solo habilita interrupciones del timer y teclado)
mov al, 11111101b        ; Habilita interrupciones del timer (bit 1 en 0)
out IMR, al

; Configurar vector de interrupción del timer 
mov al, 5                ; ID de interrupción del timer
out INT1, al             ; Asigna rutina de atención a la posición 5

;  Instalar rutina de interrupción en el vector 
mov bl, 5                ; Vector de interrupción 5
mov [bl], imp_msj        ; Apunta a la rutina imp_msj

;  Configurar timer para 3 segundos 
mov al, 10                ; Valor de comparación (10 segundos)
out COMP, al

mov al, 0                ; Reinicia el contador del timer
out CONT, al

;  Esperar a que se imprima el mensaje 
loopinf: cmp imprimio, 0 ; Ya imprimió
         jz loopinf      ; Si no, sigue esperando

hlt                      ; Termina el programa

;  Rutina de interrupción del timer 
org 50h
imp_msj:
         mov bl, offset mensaje ; Dirección del mensaje
         mov al, 4             ; Servicio de impresión
         int 7                 ; Llama a la interrupción de impresión
         mov imprimio, 1       ; Marca que ya imprimió
         mov al, 20h           ; Señal de fin de interrupción
         out EOI, al           ; Notifica al PIC
         iret                  ; Retorna de la interrupción\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
; Programa Imprime 'Hola' a los 10 segundos de iniciado y luego termina.
; Utiliza la interrupción del TIMER (ID = 5).

mensaje db 'Hola'        ; Mensaje a imprimir
imprimio db 0            ; Flag para saber si ya imprimió

; Definición de direcciones de registros de dispositivos
CONT equ 10h             ; Registro de conteo del timer
COMP equ 11h             ; Registro de comparación del timer

EOI  equ 20h             ; End Of Interrupt (para PIC)
IMR  equ 21h             ; Interrupt Mask Register (PIC)
INT1 equ 25h             ; Registro de vector de interrupción 1

;  Habilitar interrupciones del timer 
; IMR = 1111 1101b (solo habilita interrupciones del timer y teclado)
mov al, 11111101b        ; Habilita interrupciones del timer (bit 1 en 0)
out IMR, al

; Configurar vector de interrupción del timer 
mov al, 5                ; ID de interrupción del timer
out INT1, al             ; Asigna rutina de atención a la posición 5

;  Instalar rutina de interrupción en el vector 
mov bl, 5                ; Vector de interrupción 5
mov [bl], imp_msj        ; Apunta a la rutina imp_msj

;  Configurar timer para 3 segundos 
mov al, 10                ; Valor de comparación (10 segundos)
out COMP, al

mov al, 0                ; Reinicia el contador del timer
out CONT, al

;  Esperar a que se imprima el mensaje 
loopinf: cmp imprimio, 0 ; Ya imprimió
         jz loopinf      ; Si no, sigue esperando

hlt                      ; Termina el programa

;  Rutina de interrupción del timer 
org 50h
imp_msj:
         mov bl, offset mensaje ; Dirección del mensaje
         mov al, 4             ; Servicio de impresión
         int 7                 ; Llama a la interrupción de impresión
         mov imprimio, 1       ; Marca que ya imprimió
         mov al, 20h           ; Señal de fin de interrupción
         out EOI, al           ; Notifica al PIC
         iret                  ; Retorna de la interrupción
```")
}
```

## Validación pedagógica del simulador {#validacionpedagogica}
Con el objetivo de evaluar rigurosamente la eficacia pedagógica del simulador VonSim8 en la enseñanza de arquitectura de computadoras, se realizó una prueba piloto durante el segundo cuatrimestre de 2025. Esta experiencia estuvo dirigida a estudiantes de segundo año de la Licenciatura en Sistemas y se centró en medir el nivel de comprensión alcanzado respecto a conceptos fundamentales, como el ciclo de instrucción, la manipulación de registros y la gestión de interrupciones.

### Objetivos de la validación
- Analizar el impacto del simulador en la comprensión de los principios esenciales de la arquitectura de computadoras.
- Identificar mejoras en la habilidad de los estudiantes para analizar y depurar programas en lenguaje ensamblador.
- Evaluar la percepción de usabilidad y utilidad didáctica de la herramienta desde la perspectiva de los usuarios.

### Población de estudio

La validación se realizó sobre una muestra de 14 estudiantes matriculados en la asignatura Arquitectura de Computadoras y 2 docentes a cargo. La participación fue voluntaria, asegurando la representatividad del perfil académico habitual en la materia.

### Instrumentos de recolección de datos (ver Apéndice: Anexo B \@ref(anexoB))

Para la validación se emplearon instrumentos diseñados para medir la calidad didáctica y recoger opiniones cualitativas tanto de estudiantes como de docentes. Los instrumentos, adaptados al contexto universitario y alineados con los objetivos pedagógicos del capítulo, fueron los siguientes:

- **Cuestionario de conocimiento:** Aplicado a estudiantes, utiliza una escala tipo Likert (por ejemplo, 1-5) para evaluar la satisfacción y percepción de eficacia en aspectos clave del simulador, tales como visualización, editor, progresividad de instrucciones, métricas, documentación y manejo de periféricos. Incluye además un apartado para comentarios abiertos.

- **Entrevistas semiestructuradas a docentes:** Este instrumento permitió recoger valoraciones expertas sobre el potencial pedagógico del simulador, así como comparaciones con herramientas previas y sugerencias de mejora. Las preguntas se organizaron en categorías como usabilidad, claridad conceptual, impacto en la motivación estudiantil y utilidad de la documentación.

### Análisis de resultados (ver Apéndice: Anexo C \@ref(anexoC))
La validación pedagógica del simulador VonSim8 se realizó mediante dos instrumentos principales: una encuesta de retroalimentación aplicada a estudiantes y entrevistas semiestructuradas realizadas a docentes. A continuación, se presenta un análisis integral de los resultados obtenidos a partir de ambos enfoques.

#### 1. Encuesta de retroalimentación a estudiantes
La encuesta fue respondida por 14 estudiantes y permitió evaluar la claridad de los contenidos teóricos, la calidad del material didáctico y la utilidad del simulador. Los resultados reflejan una valoración positiva de la experiencia educativa, destacándose los siguientes aspectos:

- **Resultados cuantitativos:**
  - Los recursos visuales obtuvieron la puntuación más alta (promedio 4.21), seguidos por la claridad de los modos de direccionamiento (4.14) y la conexión entre teoría y práctica (4.14). Estos resultados evidencian la efectividad del simulador para facilitar la comprensión de conceptos clave.
  - La visualización de las microoperaciones fue el ítem con menor puntuación (3.57), lo que sugiere la necesidad de optimizar este aspecto para mejorar la experiencia de aprendizaje.

- **Resultados cualitativos:**
  - Los estudiantes destacaron como aspectos más útiles la posibilidad de observar paso a paso la ejecución de instrucciones y los cambios en registros y memoria, así como el carácter práctico e intuitivo del simulador.
  - Las principales dificultades mencionadas incluyeron la interpretación de las banderas, las animaciones de lectura/escritura en memoria y las instrucciones de salto, lo que indica áreas de mejora en la documentación y los recursos de apoyo.

- **Conclusión:**
  El simulador VonSim8 fue percibido como una herramienta pedagógica eficaz, que facilita la comprensión del ciclo de instrucción y promueve un aprendizaje activo. Se recomienda continuar perfeccionando las representaciones visuales y ampliar los materiales de apoyo para abordar las dificultades identificadas.

#### 2. Entrevistas semiestructuradas a docentes
Las entrevistas realizadas a dos docentes especializados en la enseñanza de Arquitectura de Computadoras permitieron recoger valoraciones cualitativas sobre el simulador VonSim8. Los resultados se agrupan en las siguientes categorías:

- **Usabilidad y claridad conceptual:**
  - Los docentes valoraron positivamente la claridad de las explicaciones teóricas (promedio 4.20) y la utilidad de los recursos visuales (4.50), destacando su efectividad para enseñar conceptos abstractos como el ciclo de instrucción y el flujo de datos.
  - Se identificaron oportunidades de mejora en la interfaz del simulador, especialmente para estudiantes principiantes, y en la representación de las microoperaciones.

- **Impacto en la motivación estudiantil:**
  - Ambos docentes coincidieron en que el simulador incrementa la motivación de los estudiantes al ofrecer una experiencia práctica e interactiva, que conecta teoría y práctica de manera efectiva.

- **Sugerencias de mejora:**
  - Los docentes recomendaron optimizar la representación de las banderas y las animaciones de lectura/escritura en memoria, así como mejorar la accesibilidad de la interfaz para estudiantes con poca experiencia.

- **Conclusión:**
  Los docentes consideraron que VonSim8 es una herramienta didáctica eficaz, que facilita la enseñanza de la arquitectura x86 y promueve un aprendizaje progresivo. Las sugerencias recogidas servirán de base para orientar futuras mejoras en el desarrollo del simulador.

#### 3. Análisis integral
La integración de los resultados de ambos instrumentos permite obtener una visión completa del impacto pedagógico del simulador VonSim8:

- **Fortalezas:**
  - El simulador facilita la comprensión de conceptos complejos como el ciclo de instrucción, el flujo de datos y la interacción entre registros y memoria.
  - Los recursos visuales y la conexión entre teoría y práctica son altamente valorados tanto por estudiantes como por docentes.
  - La activación progresiva del repertorio de instrucciones y las métricas de rendimiento contribuyen a un aprendizaje gradual y reflexivo.

- **Áreas de mejora:**
  - Optimizar la representación de las microoperaciones y las animaciones de lectura/escritura en memoria.
  - Mejorar la accesibilidad de la interfaz para estudiantes principiantes.
  - Ampliar los materiales de apoyo y las explicaciones sobre aspectos técnicos como las banderas y las instrucciones de salto.

- **Conclusión general:**
  El simulador VonSim8 se consolida como una herramienta educativa integral, que combina visualización interactiva, ejecución progresiva y análisis de rendimiento. Los resultados de la validación confirman su efectividad pedagógica y destacan su potencial para seguir mejorando en función de las sugerencias recogidas. En conclusión, la triangulación de datos cuantitativos (encuestas a estudiantes) y cualitativos (entrevistas a docentes) validó la pertinencia pedagógica de VonSim8. Las fortalezas identificadas ratifican las decisiones de diseño, mientras que las oportunidades de mejora proporcionan una hoja de ruta clara para futuras iteraciones.

## Aportes y contribuciones del simulador VonSim8
El simulador VonSim8 constituye una valiosa contribución al ámbito educativo en la enseñanza de arquitectura de computadoras, destacándose por los siguientes aspectos:

1. **Simplificación pedagógica de la arquitectura x86:**
   VonSim8 implementa una arquitectura simplificada de 8 bits, diseñada para reducir la complejidad inherente a la arquitectura x86. Esta simplificación permite a los estudiantes concentrarse en conceptos fundamentales, como el ciclo de instrucciones, la interacción entre registros y la gestión de interrupciones, sin verse abrumados por detalles técnicos avanzados. La selección de un repertorio reducido de instrucciones se fundamenta en principios de la psicología cognitiva, que destacan la importancia de introducir gradualmente conceptos técnicos para mejorar la retención y reducir la sobrecarga cognitiva [@sweller2010cognitive; @nationalacademies2018how].

2. **Activación progresiva del repertorio de instrucciones:**
   El simulador habilita de manera escalonada un repertorio reducido de instrucciones, en correspondencia con el avance de los contenidos curriculares. Este enfoque progresivo facilita la asimilación de conceptos más complejos, mitigando la sobrecarga cognitiva y promoviendo un aprendizaje gradual y efectivo.

3. **Visualización interactiva del ciclo de instrucciones:**
   VonSim8 incorpora una representación visual basada en el modelo de Nivel de Transferencia entre Registros (RTL), que permite observar el flujo de datos y las señales de control en cada etapa del ciclo de instrucción. Esta funcionalidad refuerza la conexión entre teoría y práctica, facilitando la comprensión de procesos internos del procesador mediante una representación clara y dinámica.

4. **Simulación de periféricos y gestión de interrupciones:**
   El simulador incluye un módulo de entrada/salida programada (PIO) y un vector de interrupciones predefinido, que emulan interacciones con dispositivos externos como teclados y monitores. Estas características permiten explorar conceptos clave como la asincronía y el manejo de eventos, esenciales para comprender sistemas reales.

5. **Entorno integrado de desarrollo y simulación:**
   VonSim8 ofrece un editor de ensamblador con funciones como resaltado de sintaxis, autocompletado y ejemplos predefinidos, junto con un simulador que permite ejecutar programas paso a paso o de manera continua. Este entorno integrado mejora la experiencia del usuario y fomenta un aprendizaje práctico y autónomo.

6. **Métricas de rendimiento y análisis cuantitativo:**
   El simulador proporciona indicadores clave como ciclos por instrucción (CPI), tiempo de CPU y tiempo de ciclo, que permiten a los estudiantes analizar la eficiencia de sus programas. Estas métricas promueven una comprensión integral del rendimiento del procesador y su impacto en la ejecución de programas.

7. **Documentación y recursos de apoyo:**
   VonSim8 incluye una documentación clara y accesible, complementada con tutoriales interactivos y ejemplos prácticos que guían al estudiante en el uso del simulador. Este recurso fomenta un aprendizaje activo y reflexivo, facilitando la adquisición de competencias técnicas.

8. **Compatibilidad y accesibilidad:**
   El simulador es de código abierto y se distribuye bajo licencias que permiten su estudio, modificación y mejora continua. Su diseño accesible y sostenible asegura su utilidad en diversos contextos educativos.

En resumen, VonSim8 se presenta como una herramienta educativa integral que combina visualización interactiva, ejecución progresiva y análisis de rendimiento. Su diseño responde a las necesidades pedagógicas y técnicas de la enseñanza de arquitectura de computadoras, promoviendo un aprendizaje activo, reflexivo y centrado en la comprensión de los principios fundamentales de la disciplina.

## Resumen del capítulo
En este capítulo se ha descrito el diseño y desarrollo del simulador VonSim8, destacando sus características pedagógicas y técnicas. Las modificaciones implementadas, como la simplificación de la arquitectura y la visualización interactiva, están orientadas a facilitar la enseñanza de la arquitectura de computadoras. Estas mejoras aseguran que el simulador no solo sea una herramienta funcional, sino también un recurso educativo efectivo.

La efectividad pedagógica del simulador fue evaluada mediante una prueba piloto con estudiantes de la asignatura Arquitectura de Computadoras, tal como se detalló en la sección (\@ref(validacionpedagogica)). Los resultados de dicha validación, que incluyeron encuestas y entrevistas, confirmaron el valor de la herramienta para la comprensión de conceptos clave.

Asimismo, la validación formal mediante el modelado xDEVS permitió demostrar la correctitud funcional y temporal del simulador VonSim8, evidenciando la sincronización precisa entre los componentes y la reproducción fiel de las restricciones arquitecturales de Von Neumann. Este enfoque no solo aporta rigor científico al desarrollo, sino que también facilita la instrumentación de métricas objetivas de rendimiento y la extensión futura del simulador. La integración del formalismo DEVS refuerza el valor pedagógico de la herramienta, al ofrecer una representación explícita y trazable de los procesos internos del procesador.