# Diseño y Construcción del Simulador {#desarrollo}
En este capítulo se describe el diseño y desarrollo de una herramienta de simulación específica para la arquitectura x86, orientada a facilitar la enseñanza de los principios de arquitectura de computadoras. Se detalla la justificación del diseño, los pasos seguidos para su construcción y los métodos utilizados para validar su funcionalidad.

En el capítulo anterior se analizaron y evaluaron las herramientas de simulación existentes para la arquitectura x86. Esta revisión exhaustiva permitió identificar las limitaciones de las soluciones actuales y fundamentar la necesidad de desarrollar una herramienta específica (véase el capítulo \@ref(comparativa)).

A partir de esta necesidad, se establecieron un conjunto de requisitos funcionales y pedagógicos que guiaron de manera integral el diseño, la implementación y la validación del simulador. Estos requisitos no solo responden a las limitaciones observadas en herramientas existentes, sino que se alinean con los objetivos educativos previamente definidos.

## Requisitos de la herramienta y su justificación
Esta sección expone los requisitos que orientaron el diseño del simulador, clasificados en dos dimensiones complementarias: pedagógica y funcional. La primera se vincula con los objetivos formativos definidos en el capítulo introductorio (\@ref(intro)), mientras que la segunda refiere a las características técnicas necesarias para garantizar su implementación eficaz. La definición de los requisitos se apoyó en principios pedagógicos y técnicos, complementados con una validación empírica realizada mediante entrevistas semiestructuradas a docentes expertos (ver Anexo A \@ref(anexoA)). Este proceso permitió identificar necesidades auténticas del aula y carencias específicas en las herramientas existentes, aportando una base empírica rigurosa para la formulación pedagógica y técnica de los requisitos [@huberman2019qualitative].

1. **Visualización de la estructura general de la computadora:**
Incluir una representación gráfica de la arquitectura básica de la computadora —compuesta por CPU, buses, memoria y dispositivos de entrada/salida— durante la ejecución de los programas. La visualización debe destacar los componentes activos en cada etapa del ciclo de ejecución, facilitando una comprensión sistémica e integrada del funcionamiento de la computadora [@w3c_accessibility_2021]. El uso de representaciones gráficas como recurso didáctico está respaldado por estudios que demuestran su efectividad para facilitar la comprensión de conceptos abstractos en disciplinas técnicas [@sorva2013visualizations]. La Figura \@ref(fig:diagramasimulador) presenta un diagrama estructural que representa los principales módulos del simulador y sus interacciones. Este recurso visual permite integrar, de forma esquemática, los componentes funcionales implementados y su correspondencia con los objetivos pedagógicos definidos.

```{r diagramasimulador, echo=FALSE, fig.cap="Estructura del simulador y componentes funcionales", fig.align = 'center', out.width = "90%"}
knitr::include_graphics("images/estructurasimulador.png")
```

2. **Soporte para la generación y ejecución de programas en ensamblador:**
Incorporar la posibilidad de ejecutar programas escritos en lenguaje ensamblador tanto de forma paso a paso como en ejecución continua. Esta funcionalidad posibilita el análisis detallado de cada instrucción, fortaleciendo competencias en trazado y depuración de código ensamblador, fundamentales para comprender la relación entre software y hardware.
Para apoyar este proceso, se propone la inclusión de un editor de ensamblador que incorpore funciones como resaltado de sintaxis y autocompletado. Estas características mejoran la experiencia del usuario y facilitan la escritura y comprensión del código, en consonancia con principios de diseño de interfaces que priorizan la usabilidad y la accesibilidad [@w3c_accessibility_2021]. El editor debe permitir al usuario escribir, editar, guardar y ejecutar programas en ensamblador dentro del simulador, además de ofrecer ejemplos predefinidos como apoyo didáctico. La incorporación de entornos de desarrollo integrados (IDEs) en contextos educativos ha demostrado ser eficaz para la enseñanza de lenguajes de programación, según diversos estudios [@mccracken2001does].

```{r editor, echo=FALSE, fig.cap="Editor ensamblador", fig.align = 'center', out.width = "90%"}
knitr::include_graphics("images/editor.png")
```

3. **Repertorio reducido de instrucciones con activación progresiva:**
Se selecciona un subconjunto esencial del conjunto de instrucciones x86, el cual se habilita en etapas secuenciales del proceso de enseñanza, en correspondencia con el avance de los contenidos curriculares. Esta decisión se fundamenta en principios de la psicología cognitiva que sugieren que la introducción escalonada de contenidos técnicos mejora la retención y reduce la sobrecarga cognitiva [@nationalacademies2018how]. Esta estrategia también se encuentra respaldada por autores como Hasan [@hasan_survey_2012], Null y Lobur [@null_essentials_2023], y Stallings [@stallings_computer_2021], quienes proponen abordajes similares en la enseñanza de arquitecturas complejas.

```{r activacionprogresiva, echo=FALSE, message=FALSE, warning=FALSE}
    library(knitr)
    library(kableExtra)

    # Crear los datos de la tabla de activación progresiva
    activacionprogresiva <- data.frame(
      Fase = c("Inicial", "Intermedia", "Avanzada"),
      `Instrucciones activadas` = c(
        "MOV, ADD, SUB, HLT",
        "CMP, JMP, Jxx",
        "CALL, RET, INT, IRET, CLI, STI, IN, OUT"
      ),
      `Objetivo didáctico` = c(
        "Comprensión del ciclo de instrucción básico",
        "Introducción a control de flujo",
        "Manejo de periféricos e interrupciones"
      )
    )

    tabla_activacion <- kable(activacionprogresiva,
                  format = ifelse(knitr::is_latex_output(), "latex", "html"),
                  caption = "Activación progresiva del repertorio de instrucciones",
                  col.names = c("Fase", "Instrucciones activadas", "Objetivo didáctico"),
                  booktabs = TRUE,
                  escape = FALSE,
                  align = c("c", "c", "c"))

    if (knitr::is_latex_output()) {
      tabla_activacion %>%
        kable_styling(
          latex_options = c("scale_down", "hold_position"),
          font_size = 10,
          position = "right"
        ) %>%
        column_spec(1, width = "2cm", bold = TRUE, border_right = TRUE) %>%
        column_spec(2, width = "4cm") %>%
        column_spec(3, width = "6cm") %>%
        row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
        row_spec(seq_len(nrow(activacionprogresiva)),
                 extra_latex_after = "\\addlinespace[10pt]")
    } else {
      tabla_activacion %>%
        kable_styling(
          bootstrap_options = c("striped", "hover", "condensed", "responsive"),
          full_width = FALSE,
          position = "center"
        ) %>%
        column_spec(1, width = "12em", bold = TRUE, border_right = TRUE) %>%
        column_spec(2:3, width = "28em") %>%
        row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
    }
```

Este enfoque promueve el desarrollo progresivo de competencias, al mitigar la sobrecarga cognitiva que implicaría abordar de forma prematura el repertorio completo de instrucciones. La activación progresiva del repertorio se fundamenta en teorías de aprendizaje que sugieren que la exposición gradual a nuevos conceptos mejora la comprensión y retención [@sweller2010cognitive]. Además, esta estrategia se alinea con las recomendaciones de autores como Null y Lobur [@null_essentials_2023], quienes destacan la importancia de introducir los conceptos de forma escalonada para facilitar el aprendizaje efectivo.

4. **Simulación visual e interactiva de micropasos de instrucciones:**
Se implementa una visualización interactiva del flujo de datos basada en el modelo de Nivel de Transferencia entre Registros (Register Transfer Level, RTL). Este enfoque permite representar con precisión el desplazamiento de datos entre registros, buses y unidades funcionales del procesador, así como las señales de control involucradas en cada fase del ciclo de instrucción [@ASMVisualizer2025; @harris2015digital]. Stallings [@stallings_computer_2021] propone utilizar el modelo RTL para representar el ciclo de instrucción, desde la captura (fetch) hasta la ejecución (execute), facilitando la visualización del recorrido de datos y señales de control en cada etapa del proceso.
Como complemento a la descripción anterior, la Figura \@ref(fig:cicloinstruccion) ilustra un ciclo de instrucción típico utilizando la operación MOV AL, BL como ejemplo. Esta representación facilita la identificación de las etapas *fetch*  y *execute*, así como los registros que participan activamente en cada fase.

```{r cicloinstruccion, echo=FALSE, fig.cap="Ciclo de instrucción: captación y ejecución", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/cicloinstruccion.png")
```

5. **Gestión básica de interrupciones y periféricos:**
Incluir un vector de interrupciones predefinido que simule eventos externos, como la entrada de datos mediante teclado o la salida de información a través de un monitor. Estas interacciones permiten emular situaciones de asincronía, esenciales para comprender mecanismos como la interrupción del flujo de ejecución. Desde el punto de vista pedagógico, esta funcionalidad ofrece al estudiante la posibilidad de explorar de manera interactiva conceptos clave como la asincronía, el manejo de eventos y la interrupción del flujo secuencial, todos ellos característicos del diseño de arquitecturas modernas y fundamentales para el entendimiento de sistemas reales. Su inclusión se alinea con las recomendaciones de autores como Null y Lobur [@null_essentials_2023], quienes destacan el valor de abordar estos conceptos en etapas tempranas de la formación. Además, se incorpora un módulo genérico de entrada/salida programada (Programmed Input/Output, PIO), que actúa como interfaz entre la CPU y los dispositivos periféricos. Este módulo permite simular operaciones mediante instrucciones como IN y OUT, facilitando la interacción del estudiante con dispositivos representados gráficamente, como interruptores y teclas. De esta forma, se promueve una comprensión más tangible de los mecanismos subyacentes al intercambio de información entre el procesador y los dispositivos externos.

```{r perifericos, echo=FALSE, fig.cap="Módulo genérico de entrada/salida programada", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/perifericos.png")
```

6. **Métricas de rendimiento:**
Incluir indicadores clave como tiempo de ciclo, tiempo de CPU y ciclos por instrucción (CPI), generados automáticamente a partir de la ejecución de los programas. Asimismo, se permite configurar la frecuencia del CPU dentro de un rango de valores (1–10 Hz). Estos indicadores permiten al estudiante analizar cuantitativamente la eficiencia en la ejecución de un programa, facilitando comparaciones entre diferentes implementaciones. Su inclusión apunta a fortalecer la comprensión de aspectos clave del rendimiento del procesador, promoviendo una formación integral que contemple tanto aspectos funcionales como métricos del comportamiento del sistema [@hennessy2017computer].

```{r metricas, echo=FALSE, fig.cap="Métricas de rendimiento", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/metricas.png")
```

7. **Documentación y recursos de apoyo:**
Proporcionar documentación clara y accesible que explique el funcionamiento del simulador, sus componentes y las instrucciones disponibles. Esta documentación debe incluir ejemplos prácticos, guías de uso y recursos adicionales para facilitar la comprensión y el aprendizaje autónomo. La inclusión de tutoriales interactivos y ejemplos prácticos es fundamental para guiar al estudiante en el uso efectivo del simulador, promoviendo un aprendizaje activo y reflexivo [@bonwell1991active].

```{r documentacion, echo=FALSE, fig.cap="Documentación on line", fig.align = 'center', out.width = "90%"}
knitr::include_graphics("images/documentacion.png")
```

En conjunto, estos requisitos constituyen la base del diseño del simulador, garantizando tanto su pertinencia pedagógica como su viabilidad técnica. Su formulación responde a la necesidad de contar con un recurso didáctico que facilite la enseñanza y el aprendizaje de la arquitectura x86, integrando aspectos visuales, interactivos y de análisis del rendimiento. La Tabla @ref(tab:requisitosresumen) presenta un resumen de los principales requisitos funcionales, junto con su fundamentación pedagógica y técnica.

```{r requisitosresumen, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear los datos de la tabla de requisitos y fundamento
requisitosresumen <- data.frame(
  Requisito = c(
    "Visualización de estructura general",
    "Soporte para programas en ensamblador",
    "Repertorio reducido y activación progresiva",
    "Simulación visual de micropasos (RTL)",
    "Gestión de interrupciones y periféricos",
    "Métricas de rendimiento",
    "Documentación y recursos de apoyo"
  ),
  Fundamento = c(
    "Facilita comprensión sistémica mediante representaciones gráficas de hardware.",
    "Desarrolla competencias en trazado y depuración de lenguaje ensamblador; mejora usabilidad.",
    "Disminuye sobrecarga cognitiva al introducir instrucciones de manera escalonada.",
    "Permite comprender el flujo interno de datos y señales de control durante el ciclo de instrucción.",
    "Simula asincronía y manejo de eventos, favoreciendo la comprensión de sistemas reales.",
    "Promueve análisis cuantitativo de eficiencia (CPI, ciclos, tiempo de CPU).",
    "Fomenta aprendizaje autónomo y activo mediante guías, tutoriales y ejemplos."
  )
)

tabla_requisitos <- kable(requisitosresumen,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Resumen de requisitos funcionales y su fundamentación pedagógica",
               col.names = c("Requisito", "Fundamento pedagógico / técnico"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c"))

if (knitr::is_latex_output()) {
      tabla_requisitos %>%
        kable_styling(
          latex_options = c("scale_down", "hold_position"),
          font_size = 10
        ) %>%
        column_spec(1, width = "5cm", bold = TRUE, border_right = TRUE) %>%
        column_spec(2, width = "8cm") %>%
        row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
        row_spec(seq_len(nrow(requisitosresumen)),
                 extra_latex_after = "\\addlinespace[10pt]")
    } else {
      tabla_requisitos %>%
        kable_styling(
          bootstrap_options = c("striped", "hover", "condensed", "responsive"),
          full_width = FALSE,
          position = "center"
        ) %>%
        column_spec(1, width = "16em", bold = TRUE, border_right = TRUE) %>%
        column_spec(2, width = "32em") %>%
        row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
    }
```

### Justificación del uso de una arquitectura simplificada en el simulador
A partir de los requisitos funcionales detallados anteriormente, se realizó un proceso colaborativo de análisis con docentes^[Docentes: Marcelo A. Colombani y Amalia G. Delduca] de la asignatura Arquitectura de Computadoras. Su experiencia permitió identificar los elementos de la arquitectura x86 que debían representarse, simplificarse o adaptarse según los objetivos pedagógicos del simulador. Como resultado, se optó por una arquitectura simplificada de 8 bits, cuya elección se justifica por su valor didáctico: reduce la complejidad del modelo sin comprometer la enseñanza de conceptos esenciales como el ciclo de instrucciones, la manipulación de registros o la gestión de interrupciones. Esta simplificación permite representar procesos clave con mayor claridad y menor carga cognitiva, favoreciendo la comprensión de los estudiantes en las etapas iniciales del aprendizaje.

La arquitectura x86 se distingue por su elevada complejidad, derivada de su extenso repertorio de instrucciones y sus múltiples características avanzadas. En respuesta, el diseño del simulador se fundamenta en tres principios pedagógicos centrales:

- **Reducir la carga cognitiva**: simplificar el repertorio y los componentes permite a los estudiantes enfocarse en los principios fundamentales.  
- **Aprendizaje progresivo**: se adopta un enfoque escalonado, comenzando con un modelo simple y avanzando hacia representaciones más completas de x86.  
- **Claridad pedagógica**: las prácticas resultan manejables en términos de tiempo y esfuerzo, favoreciendo un aprendizaje activo y centrado en la resolución progresiva de problemas.  

En este marco, el diseño del simulador contribuye a:  

- **Comprensión fundamental**: los estudiantes pueden concentrarse en el ciclo de instrucciones, la interacción de componentes y el flujo básico de datos.  
- **Análisis crítico**: comparar el modelo simplificado con la arquitectura x86 real favorece un aprendizaje más reflexivo y profundo.  
- **Experimentación práctica**: proporciona un entorno accesible para explorar conceptos y corregir errores.  

Diversos autores como Patterson & Hennessy [@hennessy2017computer], Tanenbaum [@tanenbaum_structured_2016] y Null [@null_essentials_2023] coinciden en que el uso de arquitecturas simplificadas, como las de 8 bits, permite a los estudiantes centrarse en los fundamentos de la arquitectura de computadoras sin verse abrumados por la complejidad técnica de arquitecturas reales. Este enfoque hace posible observar la transferencia de datos entre registros y la activación de señales de control en cada etapa, facilitando la comprensión del funcionamiento interno del procesador.  

El modelo propuesto se inspira en los principios de la arquitectura x86 [@intel_microarchitecture_2021], pero implementa un repertorio reducido de instrucciones en una arquitectura de 8 bits. Esta elección responde a criterios pedagógicos: simplifica el modelo sin sacrificar los principios esenciales del repertorio x86, y facilita una comprensión progresiva de sus componentes [@patt2019introduction; @majid1999design; @morlan_sap1_2021; @Guald_2015_thesis; @silber_tinycpu].  

En síntesis, la definición de estos requisitos integra aspectos funcionales, pedagógicos y técnicos en una herramienta que no solo simula el comportamiento del sistema, sino que además facilita activamente los procesos de enseñanza y aprendizaje en arquitectura de computadoras. La combinación entre visualización, ejecución progresiva y análisis de rendimiento ofrece un entorno didáctico rico que responde tanto a las necesidades del aula como a los desafíos de la disciplina.

## Diseño del Simulador
El simulador implementado adopta la arquitectura de Von Neumann, reconocida por su simplicidad conceptual y operativa. En este modelo, los datos y las instrucciones comparten una única memoria, lo que permite tratar las instrucciones como datos [@stallings_computer_2021].

### VonSim
VonSim^[VonSim: https://vonsim.github.io/] [@vonsim] es una herramienta diseñada específicamente para la enseñanza y el aprendizaje de la arquitectura y organización de computadoras, que sirvió de referencia por su enfoque educativo e interfaz intuitiva. A partir de esta herramienta se desarrolló VonSim8^[VonSim8: https://ruiz-jose.github.io/VonSim8/], adaptado para operar con registros y memoria de 8 bits, y diseñado para favorecer el aprendizaje progresivo.

La arquitectura detallada de VonSim, con su amplio repertorio de instrucciones y componentes, ofrece una visión integral del sistema. Sin embargo, dicha riqueza funcional puede abrumar a estudiantes en etapas iniciales. Por esta razón, VonSim8 implementa una simplificación estratégica para reducir la carga cognitiva en los primeros niveles de aprendizaje, promoviendo una asimilación progresiva de los conceptos fundamentales de la arquitectura de computadoras. A partir de esta base, se introdujeron diversas modificaciones en los componentes, instrucciones y funcionalidades del simulador, priorizando aquellos aspectos conceptuales que se abordan en el programa de la asignatura.

Las siguientes características posicionan a VonSim como una solución educativa integral:

1. **Entorno integrado de desarrollo y simulación:** incluye un editor de código ensamblador con resaltado de sintaxis y un simulador para la ejecución de programas, facilitando el aprendizaje práctico. [@vonsim].

2. **Fundamento en arquitectura real:** basado en el procesador Intel 8088, ofrece una referencia histórica y técnicamente relevante. [@intel8086manual].

3. **Componentes esenciales para el estudio:** incorpora cuatro registros multipropósito de 16 bits, memoria principal de 32 kB, bus de direcciones de 16 bits y bus de datos de 8 bits, entre otros. [@stallings_computer_2021].

4. **Gestión completa de interrupciones:** Implementa tanto interrupciones por software (entrada/salida de datos) como interrupciones por hardware mediante un controlador de interrupciones programable (PIC), cubriendo aspectos fundamentales de la operación del sistema [@hennessy2017computer].

5. **Simulación de periféricos:** incorpora dispositivos como reloj, llaves, luces e impresora, inspirados en los especificados por la familia iAPX 88 de Intel, permitiendo simular interacciones complejas con el sistema.

6. **Enfoque pedagógico mediante simplificaciones estratégicas:** no pretende ser un emulador fiel del 8088, sino una herramienta educativa que implementa simplificaciones deliberadas (repertorio de instrucciones reducido y codificación simplificada) para facilitar la comprensión en contextos educativos [@patt2019introduction].

7. **Desarrollo académico especializado:** fue creado por Facundo Quiroga, Manuel Bustos Berrondo y Juan Martín Seery, con la colaboración de Andoni Zubimendi y César Estrebou, específicamente para las cátedras de Organización de Computadoras y Arquitectura de Computadoras de la Facultad de Informática de la Universidad Nacional de La Plata, garantizando su alineación con objetivos curriculares específicos.

8. **Fundamento en experiencia previa:** se basa en el simulador MSX88, desarrollado en 1988 por Rubén de Diego Martínez para la Universidad Politécnica de Madrid, aprovechando décadas de experiencia acumulada en simuladores educativos.

9. **Accesibilidad y sostenibilidad:** distribuido bajo licencia GNU Affero General Public License v3.0 con código fuente disponible en GitHub, y documentación bajo licencia CC BY-SA 4.0, facilitando su estudio, modificación y mejora continua [@opensource_licensing_2024].

#### Stack tecnológico
El proyecto VonSim está desarrollado íntegramente en TypeScript, lo que permite aprovechar el tipado estático, lograr mayor robustez del código y contar con mejor soporte para autocompletado y detección temprana de errores durante el desarrollo.

La organización del código sigue la estructura de un monorepositorio, compuesto por diversos paquetes especializados que cumplen funciones específicas:

  - vonsim/assembler: ensamblador que traduce el código en lenguaje ensamblador a binario ejecutable.
  - vonsim/simulator: motor que ejecuta los programas ensamblados.
  - vonsim/app: aplicación web que proporciona la interfaz gráfica de usuario e integra el simulador.
  - vonsim/common: utilidades compartidas entre los distintos módulos.
  - eslint-config-vonsim: paquete para la configuración de reglas de estilo y buenas prácticas mediante ESLint.
  - vonsim/scripts y vonsim/tsconfig: paquetes de soporte con scripts de desarrollo y configuraciones específicas para TypeScript.
  - vonsim/docs: módulo destinado a la gestión de la documentación del proyecto.

Para el desarrollo y la ejecución del proyecto se utilizan herramientas modernas como Node.js v22 y el gestor de paquetes pnpm v10. Asimismo, el repositorio incluye una serie de scripts predefinidos para facilitar las tareas de instalación, compilación y despliegue: pnpm install, pnpm dev, pnpm docs:dev y pnpm build.

### Las modificaciones principales de VonSim

Las modificaciones implementadas se alinean con los contenidos curriculares de la asignatura y están fundamentadas en los principios del aprendizaje activo [@bonwell1991active].

  1. Simplificación del repertorio instruccional para una introducción gradual;

  2. Reducción a registros y memoria de 8 bits, coherente con la escala de enseñanza;

  3. Interfaz gráfica esquemática que muestra el flujo de ejecución;

  4. Funciones interactivas para observar explícitamente el ciclo de instrucción y la interacción de componentes.

A continuacion se detallan los cambios más relevantes implementados en VonSim8, junto con capturas de pantalla que ilustran las modificaciones realizadas:

En el registro Flags de VonSim se ocultaron inicialmente las banderas O (overflow) y S (signo), dado que en los primeros ejercicios de ensamblador solo se emplean números enteros positivos. No obstante, estas banderas pueden habilitarse posteriormente desde el menú de configuración del simulador, conforme se abordan ejercicios de mayor complejidad.

```{r banderas, echo=FALSE, fig.cap="Registro Flags", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/flags.png")
```

El flag de interrupcion I solo se muestra cuando el programa lo requiere, por ejemplo, al ejecutar una instrucción de interrupción como `INT` o `IRET`. Esto permite a los estudiantes observar cómo se activa y desactiva este flag en función de las operaciones realizadas.

```{r banderaI, echo=FALSE, fig.cap="Registro de estado I", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/flagi.png")
```

Se modificó el menú de los controles del simulador.

```{r controles, echo=FALSE, fig.cap="Controles del simulador", fig.align = 'center', out.width = "85%"}    
knitr::include_graphics(path = "images/controles.png")
```
En lugar de utilizar registros de 16 bits completos, se emplea únicamente la parte baja de cada registro, lo que simplifica tanto la representación como la manipulación de los datos. Esta decisión responde a la necesidad de reducir la complejidad del modelo, facilitando así la comprensión de los conceptos fundamentales de la arquitectura de computadoras. Además, se ha unificado el criterio de diseño de los registros: todos cuentan ahora con una entrada y una salida independientes, lo que permite visualizar de manera más clara la transferencia de datos entre los registros y la Unidad Aritmético-Lógica (ALU). Esta modificación resulta esencial para comprender el flujo de datos durante el ciclo de instrucción y la interacción entre los distintos componentes del procesador.

```{r registros, echo=FALSE, fig.cap="Registro de 8 bits", fig.align = 'center', out.width = "85%"}    
knitr::include_graphics(path = "images/registros.png")
```

Se elimino el uso de los registros temporales de la ALU (`left`, `right` y `result`).

```{r leftrigth, echo=FALSE, fig.cap="Eliminación registro temporales left, right y result", fig.align = 'center', out.width = "85%"}    
knitr::include_graphics(path = "images/leftrigth.png")
```

Los registros `SP`, `ri` e `id` se mantienen ocultos y solo se habilitan automáticamente cuando una instrucción requiere su utilización.

```{r idrisp, echo=FALSE, fig.cap="Registro SP, id y ri", fig.align = 'center', out.width = "85%"}    
knitr::include_graphics(path = "images/idrisp.png")
```

La memoria principal se modela como una matriz de 16×16 expresada en hexadecimal, lo que permite almacenar hasta 256 bytes de datos.

```{r memoriacomp, echo=FALSE, fig.cap="Memoria principal", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/memoriacomp.png")
```

Resalto de la direccion de memoria apuntada por el registro IP en memoria y también resalta la dirección de memoria apuntada por el registro SP.

```{r resaltadoip, echo=FALSE, fig.cap="Resaltado registro IP y registro SP", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/resaltadoipsp.png")
```

Se resalta en color violeta en la memoria principal el espacio destinado al vector de interrupciones en el VonSim8 es de 8 posiciones de memoria desde `0x00` a `0x07`:

```{r resaltadointsp, echo=FALSE, fig.cap="Resaltado vector de interrupciones", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/resaltadoint.png")
```

Para determinar la dirección de la rutina de tratamiento de interrupción en VonSim, es necesario multiplicar el número de interrupción por 4, ya que cada dirección de rutina ocupa 4 bytes. En cambio, en VonSim8 no es necesario realizar esta multiplicación, dado que cada dirección de rutina de interrupción corresponde a un solo byte. Por lo tanto, la interrupcion `INT 0` se encuentra en la direccion `0x00`, la interrupcion `INT 6` en la direccion `0x06`, y así sucesivamente.

Se incorporó un visor de instrucciones y datos del programa en memoria, que permite visualizar la instrucción, el tamaño en bytes que ocupa en memoria y la etiqueta asociada a los datos.

```{r visorprog, echo=FALSE, fig.cap="Visor de instrucciones y datos del programa en memoria", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/visorprog.png")
```

En VonSim, cuando se escribe un programa en el editor del simulador, es obligatorio que la sección de código inicie con la directiva `org 0x2000h` y que termine con la directiva `end`. Esto se debe a que el simulador comienza a ejecutar la primera instrucción a partir de la dirección de memoria `0x2000h`. De manera complementaria, los datos del programa suelen cargarse a partir de la dirección `0x1000h` mediante la directiva `org 0x1000h`.

En VonSim8, el uso de la directiva `org` para definir la dirección inicial es opcional. Por defecto, si el programa no incluye esta directiva, la primera instrucción se carga en la dirección `0x00h`. En caso de contener instrucciones de interrupción (INT), el simulador asigna automáticamente la dirección `0x08h` como punto de inicio, reservando espacio para el vector de interrupciones.

Por una cuestion de compatibilidad se permite cargar programas de manera similar a VonSim, pero en lugar de cargar el programa en la direccion `0x2000h` se debe cargar en la `0x20h`. En este caso, el simulador comienza a ejecutar las instrucciones a partir de la dirección `0x20h`. Para mantener compatibilidad con VonSim, se conserva esta directiva, permitiendo a los usuarios establecer direcciones personalizadas.

Además, en VonSim8 se incorporó la opción de ampliar la fuente en el editor y se añadieron ejemplos prácticos para que el estudiante pueda experimentar directamente con el simulador. También se desarrolló un tour de aprendizaje que guía al usuario a través de las principales funcionalidades, junto con un centro de aprendizaje que ofrece explicaciones y ejemplos básicos.

```{r editorvonsim, echo=FALSE, fig.cap="Editor con ampliación de fuente y ejemplos", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/editorfuenteejemplo.png")
```

Se ha mejorado el diseño de la unidad de control incorporando, dentro del decodificador, una memoria de control y un secuenciador. Estos componentes permiten representar el ciclo de instrucción de manera detallada, mostrando las microoperaciones y las señales de control generadas en cada etapa del proceso.

```{r decodificador, echo=FALSE, fig.cap="Decodificador en VonSim8", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/decodificador.png")
```

Con el fin de facilitar el aprendizaje del simulador VonSim8 se implementó un tour de aprendizaje que guía a los usuarios a través de las características y funcionalidades del simulador. También se incluye un centro de aprendizaje con explicación de ejemplos básicos.

```{r tour, echo=FALSE, fig.cap="Tour de aprendizaje en VonSim8", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/tour.png")
```

A fin de sintetizar las diferencias más relevantes entre VonSim y VonSim8, se presenta la siguiente tabla comparativa. Esta permite visualizar de manera inmediata los cambios introducidos en el diseño y su impacto en la enseñanza de los conceptos fundamentales de arquitectura de computadoras.

```{r comparativavonsim, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

comparativa_vonsim <- data.frame(
  Característica = c(
    "Registros",
    "Registro FLAGS",
    "Controles del simulador",
    "Directiva org",
    "Memoria principal",
    "Resaltado de IP y SP",
    "Vector de interrupciones",
    "Dirección de rutina de interrupción",
    "Visor de instrucciones y datos",
    "Temporales de la ALU",
    "Unidad de control",
    "Enfoque pedagógico",
    "Editor y recursos didácticos"
  ),
  VonSim = c(
    "Registros de 16 bits (AX, BX, CX, DX)",
    "Incluye todas las banderas del 8088 (O, S, Z, C, etc.)",
    "Menú de controles estándar",
    "Obligatoria. El código comienza en `0x2000h` y los datos en `0x1000h`.",
    "32 KB, organizada en páginas del 8088.",
    "No resalta dinámicamente IP y SP en memoria.",
    "Vector de interrupciones ocupa varias posiciones, cada rutina ocupa 4 bytes.",
    "Se multiplica el número de interrupción por 4 para obtener la dirección.",
    "No incluye visor detallado de instrucciones y datos.",
    "Registros temporales `left`, `right` y `result` visibles.",
    "Decodificador básico sin memoria de control ni secuenciador.",
    "Mayor fidelidad al procesador Intel 8088, con repertorio más amplio.",
    "Editor estándar, sin ampliación de fuente ni tour de aprendizaje."
  ),
  VonSim8 = c(
    "Registros de 8 bits, con entrada y salida independientes. Registros SP, RI e ID se ocultan y habilitan automáticamente.",
    "Se ocultan inicialmente las banderas O (overflow) y S (signo). El flag I (interrupción) se muestra dinámicamente.",
    "Menú de controles modificado y adaptado.",
    "Opcional. Por defecto, el código inicia en `0x00h`. Si hay interrupciones, comienza en `0x08h`. Compatible con `org 0x20h`.",
    "Matriz de 16×16 bytes (256 bytes), expresada en hexadecimal, con resaltado dinámico de IP y SP.",
    "Resalta en memoria la posición apuntada por IP y SP.",
    "Vector de interrupciones ocupa 8 posiciones (`0x00` a `0x07`), cada rutina ocupa 1 byte.",
    "La dirección de la rutina de interrupción coincide con el número de interrupción (ej. INT 6 en `0x06`).",
    "Incluye visor de instrucciones y datos, mostrando tamaño y etiquetas.",
    "Eliminados, para simplificar la representación del ciclo de instrucción.",
    "Decodificador mejorado con memoria de control y secuenciador, permite visualizar microoperaciones y señales de control.",
    "Simplificación estratégica para reducir carga cognitiva y favorecer aprendizaje progresivo.",
    "Editor con ampliación de fuente, ejemplos prácticos, tour de aprendizaje y centro de ayuda."
  ),
  stringsAsFactors = FALSE
)

tabla_comparativa <- kable(
  comparativa_vonsim,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Comparativa de características entre VonSim y VonSim8",
  col.names = c("Característica", "VonSim", "VonSim8"),
  booktabs = TRUE,
  escape = FALSE,
  align = c("l", "l", "l")
)

if (knitr::is_latex_output()) {
  tabla_comparativa %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "5cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "7cm") %>%
    column_spec(3, width = "8cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(comparativa_vonsim)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_comparativa %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "16em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "28em") %>%
    column_spec(3, width = "32em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

### Estructura del VonSim8
En esta sección se describe la estructura del simulador VonSim8. El diseño de los registros se concibió con un propósito pedagógico: facilitar la comprensión de los modos de direccionamiento y del ciclo de instrucción, elementos fundamentales en el estudio de la Arquitectura de Computadoras [@stallings_computer_2021]. En la tabla \@ref(tab:estructuravonsim8) se describen los componentes principales del simulador, junto con sus características y funcionalidades específicas. Esta tabla proporciona una visión general de la arquitectura del simulador, destacando los elementos clave que componen su estructura y su propósito pedagógico:

```{r estructuravonsim8, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Definición mejorada del data frame
estructuravonsim8 <- data.frame(
  `Componente` = c(
    "Arquitectura",
    "Registros generales",
    "Registros específicos",
    "Acceso a registros",
    "Memoria",
    "Puertos"
  ),
  `Características` = c(
    "Von Neumann: memoria compartida para datos e instrucciones.",
    "4 registros de propósito general de 8 bits (`AL`, `BL`, `CL`, `DL`).",
    if (knitr::is_latex_output()) {
      "6 registros de propósito específico:\\begin{itemize} \\item IP (Instruction Pointer) \\item IR (Instruction Register) \\item SP (Stack Pointer) \\item Flags (registro de estado) \\item MAR (Memory Address Register) \\item MBR (Memory Buffer Register)\\end{itemize}"
    } else {
      "6 registros de propósito específico:<ul>
      <li>`IP` (Instruction Pointer)</li>
      <li>`IR` (Instruction Register)</li>
      <li>`SP` (Stack Pointer)</li>
      <li>`Flags` (registro de estado)</li>
      <li>`MAR` (Memory Address Register)</li>
      <li>`MBR` (Memory Buffer Register)</li>
      </ul>"
    },
    "Los registros de propósito general pueden ser accedidos y modificados por el programador. Los específicos son gestionados por la CPU.",
    "Memoria principal de 256 bytes, direccionada por un bus de direcciones de 8 bits. Cada posición almacena un byte. La memoria se organiza en celdas de 16 bytes, con dirección inicial `0x00` y final `0xFF`.",
    if (knitr::is_latex_output()) {
      "Puertos de la CPU:\\begin{itemize} \\item Bus de direcciones de 8 bits (MAR) \\item Bus de datos de 8 bits (MBR) \\item Señal de lectura (rd) y escritura (wr), cada una de 1 bit \\item Señal IO-M (1 bit) para distinguir acceso a memoria o E-S \\item Señal de petición de interrupción (INTR, 1 bit) \\item Señal de reconocimiento de interrupción (INTA, 1 bit)\\end{itemize}"
    } else {
      "Puertos de la CPU:<ul>
      <li>Bus de direcciones de 8 bits, gestionado por el buffer <code>MAR</code>.</li>
      <li>Bus de datos de 8 bits, gestionado por el buffer <code>MBR</code>.</li>
      <li>Señal de lectura (<code>rd</code>) y escritura (<code>wr</code>), cada una de 1 bit.</li>
      <li>Señal <code>IO/M</code> (1 bit) para distinguir acceso a memoria o E/S.</li>
      <li>Señal de petición de interrupción (<code>INTR</code>, 1 bit).</li>
      <li>Señal de reconocimiento de interrupción (<code>INTA</code>, 1 bit).</li>
      </ul>"
    }
  ),
  stringsAsFactors = FALSE
)

tabla <- kable(
  estructuravonsim8,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Estructura VonSim8: componentes principales y características",
  col.names = c("Componente", "Características"),
  booktabs = TRUE,
  escape = FALSE
)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "12cm", latex_column_spec = "p{12cm}") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(estructuravonsim8)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "25em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "60em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Dentro de los registros específicos que no pueden ser accedidos por el usuario, se encuentra el registro `SP` (_Stack Pointer_) para el funcionamiento de la pila, el registro `Flags` (_flags register_), el `IP` (_Instruction Pointer_) que almacena la dirección de la próxima instrucción a ejecutar, el `IR` (_Instruction Register_) que almacena el byte de la instrucción que se está analizando/decodificando en un instante dado. También hay 2 registros dedicados a la transferencia de información entre la CPU y la memoria principal: el `MAR` (_Memory Address Register_) encargado de almacenar direcciones de memoria, y el `MBR` (_Memory Buffer Register_) que almacena el byte que se quiere propagar o se ha recibido por el bus de datos.

Adicionalmente, se incluyen dos registros auxiliares: `ri`, destinado al almacenamiento temporal de direcciones, e `id`, orientado al almacenamiento temporal de datos. Estos registros cumplen una función de apoyo en la ejecución de instrucciones. 

### Unidad de Control
La unidad de control es responsable de coordinar todas las operaciones de la CPU. Se encarga de:

- **Decodificación de instrucciones**: Interpreta el código de operación de cada instrucción.
- **Generación de señales de control**: Activa las señales necesarias para ejecutar microoperaciones.
- **Secuenciación**: Controla el orden de ejecución de las operaciones.

#### Memoria de Control
La memoria de control almacena microinstrucciones que guían la ejecución de cada instrucción en el simulador. Una representación visual de esta memoria, organizada en filas (microinstrucciones) y columnas (microoperaciones y señales de control), facilita la comprensión del papel que desempeña en la coordinación de la unidad de control [@stallings_computer_2021].

#### Secuenciador
El secuenciador complementa la memoria de control mostrando cómo se controla la secuencia de microoperaciones y las señales de control generadas en cada fase del ciclo de instrucción.

### ALU
La ALU (_Arithmetic Logic Unit_) permite realizar operaciones aritméticas y lógicas de 8 bits. Las operaciones disponibles son: `ADD`, `INC`, `SUB`, `DEC`, `NEG`, `NOT`, `AND`, `OR` y `XOR`. Todas estas operaciones modifican el registro `Flags`.

#### Flags
El registro `Flags` es un registro de 8 bits que contiene las _flags_ mostradas en la siguiente tabla. Este registro no es directamente accesible por el usuario, pero puede ser modificado por las operaciones de la ALU y pueden realizarse saltos condicionales en base a sus valores.

```{r tflags, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

tflags <- data.frame(
  `Bit` = c(0, 1, 2, 3, 4),
  Abreviatura = c("Z", "C", "O", "S", "I"),
  Descripción = c(
    "Flag de cero (Zero)",
    "Flag de acarreo (Carry)",
    "Flag de desbordamiento (Overflow)",
    "Flag de signo (Sign)",
    "Flag de interrupción (Interrupt)"
  )
)

tabla_kable <- kable(
  tflags,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Registro Flags: descripción de las banderas",
  col.names = c("Bit N°", "Abreviatura", "Descripción"),
  booktabs = TRUE,
  escape = FALSE,
  align = c("c", "c", "l")
)

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "2cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "3cm") %>%
    column_spec(3, width = "7cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tflags)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "6em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "10em") %>%
    column_spec(3, width = "22em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Los bits restantes del registro Flags están reservados para futuras extensiones del simulador y no se utilizan en la versión actual.

### Memoria
La memoria principal se modela como una matriz de 16×16 expresada en hexadecimal, lo que permite almacenar hasta 256 bytes de datos. Esta capacidad es suficiente para la mayoría de los programas de ejemplo utilizados en el curso, y su diseño simplificado facilita la comprensión de los conceptos fundamentales de la memoria en una computadora.

```{r memoria, echo=FALSE, fig.cap="Memoria principal", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/memoria.png")
```

### Buses y multiplexores
El bus de datos, direcciones y control se modela como un conjunto de líneas que permiten la comunicación entre los distintos componentes del sistema. Este bus es esencial para el intercambio de información entre la CPU, la memoria y los dispositivos de entrada/salida, y su diseño modular permite una fácil expansión en futuras versiones del simulador.

```{r buses, echo=FALSE, fig.cap="Buses", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/buses.png")
```

Dentro de los buses internos de la CPU se incluyen representaciones gráficas de multiplexores, componentes digitales esenciales que permiten seleccionar entre múltiples fuentes de datos o direcciones durante el ciclo de instrucción. Los multiplexores dirigen las señales hacia los registros y la ALU (Unidad Aritmético-Lógica), facilitando el flujo de datos dentro del procesador. Un multiplexor (MUX) funciona como un conmutador digital que conecta datos de una de n fuentes a la salida. Están dotados de entradas de control capaces de seleccionar una y solo una de las entradas de datos para permitir su transmisión desde la entrada seleccionada hacia dicha salida [@mano2017digital]. 

### Periféricos: teclado y pantalla
El simulador incluye la representación de un teclado y una pantalla con el objetivo de emular la interacción básica entre el usuario y el sistema. El teclado se modela como un vector de 16 posiciones, cada una capaz de almacenar un carácter ASCII. La pantalla, por su parte, se representa como una matriz de 16×16 que permite visualizar caracteres, facilitando así la comprensión del manejo de entrada y salida de datos en una arquitectura computacional simplificada.

```{r tecladopantalla, echo=FALSE, fig.cap="Teclado y pantalla", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/tecladopantalla.png")
```

La selección de estos bloques funcionales responde a dos criterios principales: modelar los componentes esenciales de una computadora real y garantizar la modularidad y claridad conceptual con fines pedagógicos. La Tabla \@ref(tab:bloquesfuncionales) resume los principales bloques que conforman la arquitectura simulada, junto con una breve descripción de su funcionalidad.

```{r bloquesfuncionales, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

bloquesfuncionales <- data.frame(
  Bloque = c("Unidad Central de Procesamiento (CPU)",
             "Memoria",
             "Sistema de Entrada/Salida (E/S)",
             "Bus de datos, direcciones y control"),
  Descripción = c("Simulación de registros, Unidad de Control (UC) y Unidad Aritmético Lógica (ALU).", # nolint
                  "Estructura de memoria y simulación de operaciones de lectura y escritura.", # nolint
                  "Interacción con periféricos y manejo de interrupciones.",
                  "Modelado de la comunicación entre componentes.")
)

# Crear la tabla con formato dinámico
tabla <- kable(bloquesfuncionales,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Bloques funcionales principales",
               col.names = c("Bloque Funcional", "Descripción"),
               booktabs = TRUE,
               escape = FALSE)

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "9cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(bloquesfuncionales)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "25em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "40em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

La Figura \@ref(fig:esquemavonsim8) presenta una visión esquemática de la arquitectura general del simulador. En ella se distinguen los flujos de datos y de control, representando gráficamente la interacción entre los distintos módulos funcionales durante la ejecución de programas. Dicha representación facilita la comprensión estructural del sistema y su analogía con una arquitectura computacional real, simplificada para fines educativos.

```{r esquemavonsim8, echo=FALSE, fig.cap="Arquitectura general del simulador", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/esquemavonsim8.png")
```

### Repertorio de instrucciones
El simulador VonSim8 implementa un repertorio reducido de instrucciones, diseñado para facilitar la comprensión de los conceptos fundamentales de la arquitectura de computadoras. Este repertorio incluye instrucciones aritméticas, lógicas, de transferencia de datos y control de flujo, permitiendo a los estudiantes familiarizarse con las operaciones básicas sin abrumarse con la complejidad del conjunto completo de instrucciones x86.

El repertorio de instrucciones se diseñó como una abstracción deliberada inspirada en la arquitectura x86, con el objetivo de optimizar los procesos de enseñanza y aprendizaje en entornos educativos. En una etapa inicial del proceso de enseñanza, se incluyen únicamente aquellas instrucciones esenciales que permiten introducir progresivamente los contenidos básicos de la asignatura Arquitectura de Computadoras. Este enfoque permite introducir progresivamente los conceptos fundamentales de manera accesible, minimizando la complejidad innecesaria que podría obstaculizar la comprensión en las etapas iniciales del aprendizaje [@hennessy2017computer; @tanenbaum_structured_2016]. La Tabla \@ref(tab:setreducido) muestra un conjunto reducido de instrucciones que abarca las operaciones más frecuentes y pertinentes para una etapa introductoria de aprendizaje. El repertorio se centra en instrucciones de transferencia y procesamiento de datos, junto con aquellas de control de flujo. Esta selección permite introducir los conceptos básicos de la arquitectura x86 de manera accesible, evitando la complejidad del repertorio completo y alineándose con los objetivos pedagógicos del curso.  

Las instrucciones del simulador VonSim8 se dividen en dos categorías principales: las instrucciones de transferencia y procesamiento de datos, y las instrucciones de control de flujo. Las primeras permiten mover datos entre registros y memoria, realizar operaciones aritméticas y lógicas, y manipular el contenido de los registros. Las segundas permiten alterar el flujo de ejecución del programa mediante saltos condicionales e incondicionales, así como la detención del procesador.

Con el fin de facilitar el aprendizaje de la programación en ensamblador e introducir el ciclo de instrucción, se propone el siguiente repertorio de instrucciones conforme al programa de estudio de la asignatura Arquitectura de Computadoras [@cd023_25_programa2025].

```{r setreducido, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear los datos
setreducido <- data.frame(
  Instrucciones = c(
    "Transferencia de datos",
    "Procesamiento de datos",
    "",
    "",
    "Control de flujo",
    "",
    ""
  ),
  `Nemónico` = c(
    "MOV ",
    "ADD",
    "SUB",
    "CMP",
    "JMP",
    "Jxx",
    "HLT"
  ),
  Acción = c(
   "Copiar",
  "Sumar",
  "Restar",
  "Comparar",
  "Salto incondicional",
  "Salto condicional si xx=1",
  "Detiene CPU"
  )
)

# Crear la tabla con formato dinámico
tabla <- kable(setreducido,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Tabla de instrucciones de VonSim8",
               col.names = c("Instrucciones", "nemónico", "Acción"), # nolint: line_length_linter.
               booktabs = TRUE,
               escape = FALSE)


# Mostrar la tabla en formato adecuado según el tipo de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>% # nolint: line_length_linter.
    column_spec(2, width = "4cm") %>%
    column_spec(3, width = "6cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(setreducido)), extra_latex_after = "\\addlinespace[8pt]") # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "25em", bold = TRUE) %>% # nolint: line_length_linter.
    column_spec(2, width = "15em") %>%
    column_spec(3, width = "25em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

El parámetro `xx` en las instrucciones `Jxx` hace referencia a diferentes combinaciones de banderas de estado (flags), tales como cero (Z), acarreo (C), signo (S) y desbordamiento (O). La negación de un flag se indica con la letra N, lo que amplía la flexibilidad de control del flujo de ejecución en programas condicionales.


```{r saltoscondicionales, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

saltoscondicionales <- data.frame(
  Instrucción = c(
    "JZ Dirección", "JNZ Dirección", "JC Dirección", "JNC Dirección",
    "JS Dirección", "JNS Dirección", "JO Dirección", "JNO Dirección"
  ),
  Acción = c(
    "Salta a _Dirección_ si Z = 1",
    "Salta a _Dirección_ si Z = 0",
    "Salta a _Dirección_ si C = 1",
    "Salta a _Dirección_ si C = 0",
    "Salta a _Dirección_ si S = 1",
    "Salta a _Dirección_ si S = 0",
    "Salta a _Dirección_ si O = 1",
    "Salta a _Dirección_ si O = 0"
  )
)

tabla <- kable(
  saltoscondicionales,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Saltos condicionales: instrucciones y condiciones",
  col.names = c("Instrucción", "Acción"),
  booktabs = TRUE,
  escape = TRUE,
  align = c("c", "c")
)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "6cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(saltoscondicionales)), extra_latex_after = "\\addlinespace[8pt]")
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE) %>%
    column_spec(2, width = "18em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

En base a las entrevistas con los docentes y el análisis de los contenidos del curso, a continuación se establece para cada categorías de instrucciones su uso pedagógico esperado:

- **Transferencia y procesamiento de datos**: Instrucciones que permiten mover datos entre registros y memoria y realizar operaciones aritméticas. Estas instrucciones son fundamentales para la comprensión del flujo de datos en una arquitectura computacional mostrando como se llevan a cabo operaciones aritméticas como de lenguaje de alto nivel como Python: 

```python
x=2
y=3
z=0
z = x + y
```

La traducción equivalente al lenguaje ensamblador sería:

```{r  codearit, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
  x db 2
  y db 3
  z db 0
  mov AL, x   ;Se carga el valor de x (2) en AL
  add AL, y   ;Se suma el valor de y (3) a AL (2) = 5
  mov z, AL   ;Se guarda el valor del registro AL (5) en z 
  hlt\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
    x db 2
    y db 3
    z db 0
    mov AL, x   ;Se carga el valor de x (2) en AL
    add AL, y   ;Se suma el valor de y (3) a AL (2) = 5
    mov z, AL   ;Se guarda el valor del registro AL (5) en z 
    hlt
    ```")
}
```

- **Control de flujo**: Instrucciones que permiten alterar el flujo de ejecución del programa mediante saltos condicionales e incondicionales, así como la detención del procesador. Estas instrucciones son esenciales para comprender cómo se controlan las decisiones y el flujo de ejecución en un programa. Por ejemplo, permiten implementar estructuras condicionales similares a las de lenguajes de alto nivel como Python:

```python
x=2
y=3
z=0
if x == y:
  z = y  + x
```

Su traduccion a ensamblador sería:

```{r  codeifZ, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
x db 2 
y db 3
z db 0
          mov AL, x
          cmp AL, y
          jz EsIgual
          jmp Fin
EsIgual:  add AL, y
          mov z, AL 
Fin:      hlt\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
x db 2 
y db 3
z db 0
          mov AL, x
          cmp AL, y
          jz EsIgual
          jmp Fin
EsIgual:  add AL, y
          mov z, AL 
Fin:      hlt ```")
}
```

```python
x=2
y=3
z=0
if x < y:
  z = y  + x
```

Su traduccion a ensamblador sería:

```{r  codeifC, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
x db 2 
y db 3
z db 0
          mov AL, x
          cmp AL, y
          jc EsMenor
          jmp Fin
EsMenor:  add AL, y
          mov z, AL 
Fin:      hlt\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
x db 2 
y db 3
z db 0
          mov AL, x
          cmp AL, y
          jc EsMenor
          jmp Fin
EsMenor:  add AL, y
          mov z, AL 
Fin:      hlt ```")
}
```

Por ejemplo, la estructura iterativa `while` en Python:

```python
x = 0
suma = 0

while x < 10:
    suma = suma + x
    x = x + 1
```

Su traduccion a ensamblador sería:

```{r  codewhile, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
x     db 1   
suma  db 0   
Condicion:  cmp x, 10 
            jc Bucle   		; si x < 10  salta a etiqueta Bucle:
            jmp FinBucle      ; si no salta a la etiqueta FinBucle:
Bucle:      mov BL, x
            add suma, BL
            add x, 1
            jmp Condicion      ; salta a Condicion:
FinBucle: 	hlt
\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
x     db 1   
suma  db 0   
Condicion:  cmp x, 10 
            jc Bucle   		; si x < 10  salta a etiqueta Bucle:
            jmp FinBucle      ; si no salta a la etiqueta FinBucle:
Bucle:      mov BL, x
            add suma, BL
            add x, 1
            jmp Condicion      ; salta a Condicion:
FinBucle: 	hlt ```")
}
```

Tratamiento de vectores: El simulador permite trabajar con vectores y matrices, lo que facilita la comprensión de cómo se manejan estructuras de datos más complejas en una arquitectura computacional. Por ejemplo, el siguiente código en Python busca el máximo de un vector:

```python
# Búsqueda del máximo en un vector
vector = [5, 2, 10, 4, 5, 0, 4, 8, 1, 9]
maximo = 0

for i in range(len(vector)):
    if vector[i] > maximo:
        maximo = vector[i]
```

Su traduccion a ensamblador sería:

```{r codevector, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
max     db 0
vector  db 5, 2, 10, 4, 5, 0, 4, 8, 1, 9
            mov CL, 0 ; contador
            mov BL, offset vector  ; obtiene la dirección del primer elemento del vector
Condicion:  cmp CL, 10 
            jc Bucle          ; si x < 10  salta a etiqueta Bucle
            jmp FinBucle      ; si no salta a la etiqueta FinBucle
Bucle:      mov AL, [BL]      ; AL = vector[indice] 
            cmp AL, max
            jc Proximo        ; si AL < max, salta a Proximo
            mov max, AL       ; si no, actualiza max
Proximo:    add BL, 1         ; BL = BL + 1 
            add CL, 1         ; CL = CL + 1            
            jmp Condicion 
FinBucle: 	hlt
\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
max     db 0
vector  db 5, 2, 10, 4, 5, 0, 4, 8, 1, 9
            mov CL, 0 ; contador
            mov BL, offset vector  ; obtiene la dirección del primer elemento del vector
Condicion:  cmp CL, 10 
            jc Bucle          ; si x < 10  salta a etiqueta Bucle
            jmp FinBucle      ; si no salta a la etiqueta FinBucle
Bucle:      mov AL, [BL]      ; AL = vector[indice] 
            cmp AL, max
            jc Proximo        ; si AL < max, salta a Proximo
            mov max, AL       ; si no, actualiza max
Proximo:    add BL, 1         ; BL = BL + 1 
            add CL, 1         ; CL = CL + 1         
            jmp Condicion 
FinBucle: 	hlt```")
}
```

La selección de instrucciones busca facilitar la comprensión de los procesos fundamentales de la arquitectura de computadoras: la ejecución de operaciones aritméticas, la transferencia de datos entre registros y memoria, y el control del flujo de ejecución. Al tratarse de un repertorio reducido e inspirado en la arquitectura x86, se garantiza un equilibrio entre rigor conceptual y simplicidad pedagógica. 

La implementación de estas instrucciones en el simulador VonSim8 está orientada a proporcionar una experiencia de aprendizaje que apoye la comprensión de los principios fundamentales de la arquitectura de computadoras, reduciendo la carga cognitiva en las fases iniciales de la formación y fortaleciendo la transición hacia repertorios más complejos. El simulador facilita que el estudiante comprenda cómo se ejecutan las operaciones aritméticas en la computadora, cómo se transfieren los datos entre registros y memoria, y cómo se controla el flujo de ejecución de un programa.

### Modos de direccionamiento
Los modos de direccionamiento en un repertorio de instrucciones son los métodos que tiene un procesador para especificar la ubicación de los datos (operandos) que se van a utilizar en una instrucción. Esto permite al procesador saber de dónde tomar los datos para realizar una operación y dónde guardar el resultado. A continuación, se describen los modos de direccionamiento definidos en VonSim8:

  - Registro a registro (`Rx`,`Ry`): operandos son registros del procesador y `Rx` indica registro destino y `Ry` indica registro fuente.

  - Directo (`[M]`): un operando es un registro y el otro operando es el contenido de una dirección de memoria `[M]`.

  - Indirecto (`[BL]`): la dirección del operando se encuentra en el registro `[BL]`.

  - Inmediato (`d`): un operando es un valor contenido en la instrucción. 

Estos modos de direccionamiento permiten al simulador representar una variedad de operaciones, desde la manipulación directa de registros hasta el acceso a la memoria. Esto proporciona una base sólida para comprender el flujo de datos en una arquitectura computacional. La Tabla \@ref(tab:modosdireccionamiento) resume los modos de direccionamiento implementados en el simulador para instrucciones de dos operandos, e incluye ejemplos de su uso.

```{r modosdireccionamiento, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

if (knitr::is_latex_output()) {
  modosdireccionamiento <- data.frame(
    Destino = c(
      "Registro Rx",
      "Memoria puede ser: \\begin{itemize}\\item dirección [M]\\item dirección registro [BL] \\end{itemize}"
    ),
    Fuente = c(
      "Puede ser:\\begin{itemize} \\item registro Ry\\item dirección [M] \\item dirección registro [BL] \\item valor inmediato d \\end{itemize}",
      "Puede ser:\\begin{itemize} \\item Registro: Ry\\item valor en la instrucción d \\end{itemize}"
    ),
    Ejemplo = c(
      "\\begin{itemize} \\item Entre registro: MOV Rx, Ry\\item Directo: MOV Rx, [M] \\item Indirecto: MOV Rx, [BL]\\item Inmediato: MOV Rx, d \\end{itemize}",
      "\\begin{itemize} \\item Directo: MOV [M], Ry \\item Indirecto: MOV [BL], Ry\\item Directo-Inmediato: MOV [M], d\\item Indirecto-Inmediato: MOV [BL], d \\end{itemize}"
    ),
    stringsAsFactors = FALSE
  )
} else {
  modosdireccionamiento <- data.frame(
    Destino = c(
      "Registro Rx",
      "Memoria puede ser: <ul><li>dirección `[M]`</li><li>dirección registro `[BL]`</li></ul>"
    ),
    Fuente = c(
      "Puede ser:<ul><li>registro `Ry`</li><li>dirección `[M]`</li><li>dirección registro `[BL]`</li><li>valor inmediato `d`</li></ul>",
      "Puede ser:<ul><li>Registro: `Ry`</li><li>valor en la instrucción `d`</li></ul>"
    ),
    Ejemplo = c(
      "<ul><li>Entre registro: MOV `Rx`,`Ry`</li><li>Directo: MOV `Rx`,`[M]`</li><li>Indirecto: MOV `Rx`,`[BL]`</li><li>Inmediato: MOV `Rx`,`d`</li></ul>",
      "<ul><li>Directo: MOV `[M]`,`Ry`</li><li>Indirecto: MOV `[BL]`,`Ry`</li><li>Directo-Inmediato: MOV `[M]`,`d`</li><li>Indirecto-Inmediato: MOV `[BL]`,`d`</li></ul>"
    ),
    stringsAsFactors = FALSE
  )
}

tabla <- kable(
  modosdireccionamiento,
  format = ifelse(knitr::is_latex_output(), "latex", "html"),
  caption = "Tabla de modos de direccionamiento",
  col.names = c("Destino", "Fuente", "Ejemplo"),
  booktabs = TRUE,
  escape = FALSE
)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "5cm") %>%
    column_spec(3, width = "8cm", latex_column_spec = "p{8cm}") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(modosdireccionamiento)), extra_latex_after = "\\addlinespace[10pt]") %>%
    footnote(
      general = c(
        "Las instrucciones de dos operando, tanto de transferencia y procesamiento tienen los mismos modos de direccionamiento.",
        "Rx y Ry puede ser un registro de propósito general: AL, BL, CL y DL."
      ),
      general_title = "Nota: ",
      number = c("La notación [M] indica el contenido de la dirección de memoria.", "La notación [BL] indica el contenido de la dirección del registro BL.", "La notación d indica dato inmediato."),
      number_title = "Notas numéricas: ",
      symbol = c("La notación M indica dirección de memoria."),
      symbol_title = "Símbolos: ",
      threeparttable = TRUE
    )
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "15em", bold = TRUE) %>%
    column_spec(2, width = "25em") %>%
    column_spec(3, width = "35em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2") %>%
    row_spec(seq_len(nrow(modosdireccionamiento)), extra_css = "border-top: 2px solid #000;") %>%
    footnote(
      general = "Las instrucciones de dos operando, tanto de transferencia y procesamiento tienen los mismos modos de direccionamiento.",
      general_title = "Nota: ",
      threeparttable = TRUE
    )
}
```

Ejemplo de los modos de direccionamiento:

```{r  codemoddir, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
x db 2 
y db 3

; ejemplo modos direccionamiento
;----------------------
; carga en registro
;----------------------
; Directo
mov al, x

; Por registro
mov dl, al

; Inmediato
mov bl, 16

; Indirecto
mov cl, [bl] ; celda 16 = bl

;----------------------
; Almacenar en memoria
;----------------------
; Diecto
mov x, cl

; Indirecto
mov [bl], al

; Directo-Inmediato
mov x, 5

; Indirecto-Inmediato
mov [bl], 4

hlt\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
x db 2 
y db 3

; ejemplo modos direccionamiento
;----------------------
; carga en registro
;----------------------
; Directo
mov al, x

; Por registro
mov dl, al

; Inmediato
mov bl, 16

; Indirecto
mov cl, [bl] ; celda 16 = BL

;----------------------
; Almacenar en memoria
;----------------------
; Diecto
mov x, cl

; Indirecto
mov [bl], al

; Directo-Inmediato
mov x, 5

; Indirecto-Inmediato
mov [bl], 4

hlt
```")
}
```


### Formato de instrucciones
El formato de las instrucciones se basa en la codificación binaria, poseen una longitud variable (1, 2 o 3 bytes), donde los 4 bits de mayor peso del primer byte representa el código de operación (opcode) y los siguientes 4 bits pueden contener operandos adicionales según el modo de direccionamiento utilizado. El opcode determina la operación a realizar, mientras que los operandos especifican los datos o registros involucrados en la operación. 
Las instrucciones del simulador VonSim8 se dividen en dos categorías principales: las instrucciones de transferencia y procesamiento de datos, y las instrucciones de control de flujo.

```{r tisaredu, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

tisaredu <- data.frame(
  Categoría = c(
    "Transferencia de datos",
    "Procesamiento de datos", "", "",
    "Control de flujo", ""

  ),
  Instrucción = c(
    "MOV",
    "ADD", "SUB", "CMP",
    "JMP / Jxx",
    "HLT"
  ),
  `Código operación` = c(
    "{0, 1, 2}",
    "{3, 4, 5}", "{6, 7, 8}", "{9, 10, 11}",
    "{12}",
    "{13}"
  ),
  `Operandos` = c(
    "2",
    "2", "2", "2",
    "1",
    "0"
  ),
  Acción = c(
    "Copiar entre registros, cargar a registro, almacenar en memoria",
    "Operación aritmética: operando1 ← operando1 + operando2",
    "Operación aritmética: operando1 ← operando1 - operando2",
    "Comparación: operando1 - operando2 (no actualiza el destino)",
    "Salto incondicional JMP, condicionales Jxx",
    "HLT: detiene el CPU"   
  ),
  stringsAsFactors = FALSE
)

tabla_kable <- kable(tisaredu,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Categorías de instrucciones y códigos de operación en VonSim8",
               col.names = c("Categoría", "Instrucción","Código operación", "Operandos", "Acción"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c", "l"))

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "4cm") %>%
    column_spec(3, width = "3cm") %>%
    column_spec(4, width = "3cm") %>%
    column_spec(5, width = "8cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tisaredu)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "12em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "16em") %>%
    column_spec(3, width = "8em") %>%
    column_spec(4, width = "8em") %>%
    column_spec(5, width = "32em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Cada instrucción se codifica en un formato binario específico, que incluye un código de operación (opcode) y, en algunos casos, operandos adicionales. La Tabla \@ref(tab:instcodif) presenta una lista de las instrucciones implementadas en el simulador, junto con su acción correspondiente y su codificación binaria.

```{r instcodif, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

instcodif <- data.frame(
  CodOp = c(
    "0", "1", "1", "1", "2", "2", "2", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "C", "D"
  ),
  Instrucción = c(
    "`MOV Rx, Ry`", "`MOV Rx, [M]`", "`MOV Rx, [BL]`", "`MOV Rx, D`",
    "`MOV [M], Ry`", "`MOV [BL], Ry`", "`MOV [M], D`", "`MOV [BL], D`",
    "`ADD Rx, Ry`", "`ADD Rx, --`", "`ADD [M], --`", "`SUB Rx, Ry`", "`SUB Rx, --`", "`SUB [M], --`",
    "`CMP Rx, Ry`", "`CMP Rx, --`", "`CMP [M], --`", "`JMP M`", "`Jxx M`", "`HLT`"
  ),
  Byte = c(
    "1", "2", "1", "2", "2", "2", "3", "2", "1", "Idem", "Idem", "1","Idem", "Idem",
    "1", "Idem", "Idem", "1", "1", "1"
  ),
  Codificación = c(
    "`0000 RxRy`", "`0001 Rx00 MMMMMMMM`", "`0001 Rx01`", "`0001 Rx10 MMMMMMMM`",
    "`0010 00Ry MMMMMMMM`", "`0010 01Ry`", "`0010 1100 MMMMMMMM dddddddd`", "`0010 1101 MMMMMMMM`",
    "`0011 RxRy`", "`0100 ---- --------`", "`0101 ---- -------- --------`", "`0110 RxRy`", "`0111 ---- --------`",
    "`1000 ---- -------- --------`", "`1001 RxRy`", "`1010 ---- --------`", "`1011 ---- -------- --------`",
    "`1100 0000 MMMMMMMM`", "`1100 ffff MMMMMMMM`", "`1101 0000`"
  ),
  stringsAsFactors = FALSE
)

# Para monoespaciado en PDF reemplaza los backticks por \texttt{}
if (knitr::is_latex_output()) {
  instcodif$Instrucción <- gsub("`([^`]*)`", "\\\\texttt{\\1}", instcodif$Instrucción)
  instcodif$Codificación <- gsub("`([^`]*)`", "\\\\texttt{\\1}", instcodif$Codificación)
}

tabla_kable <- kable(instcodif,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Tabla de codificación de instrucciones",
               col.names = c("CodOp", "Instrucción", "Byte", "Codificación"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "l", "l", "l"))

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "2cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "3.5cm") %>%
    column_spec(3:4, width = "6cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(instcodif)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "10em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "25em") %>%
    column_spec(3:4, width = "35em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Considerando:

  - `____`: Código de operación de la instrucción, número de 4 bits.

  - `Rx` o `Ry`: Índices de registros, número entre `0` y `3`, cada índice es de 2 bits.

  - `00`: Junto con el código de operación indica si la operación es tipo B o C.

  - `M`: Dirección de memoria, número de 8 bits.

  - `ffff`: representan el comportamiento de la instrucción, número de 4 bits.

  - `d`: Dato inmediato, número de 8 bits.

  - `MMMMMMMM`: Dirección de memoria, número de 8 bits.

  - `dddddddd`: Dato inmediato, número de 8 bits.


```{r tablaregistros, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

tablaregistros <- data.frame(
  Registro = c("AL", "BL", "CL", "DL"),
  Binario = c("00", "01", "10", "11"),
  Decimal = c(0, 1, 2, 3)
)

if (knitr::is_latex_output()) {
  kable(tablaregistros, format = "latex", booktabs = TRUE, align = "c",
        col.names = c("Registros R", "Binario", "Decimal"),
        caption = "Tabla de registros del simulador") %>%
    kable_styling(latex_options = c("hold_position", "scale_down"), position = "center") %>%
    column_spec(1, width = "2.5cm") %>%
    column_spec(2, width = "2.5cm") %>%
    column_spec(3, width = "2.5cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    footnote(
      general = "Los registros AL, BL, CL y DL corresponden a registros de propósito general de 8 bits.",
      general_title = "Nota: ",
      threeparttable = TRUE
    )
} else {
  kable(tablaregistros, format = "html", table.attr = "class='table table-striped'", align = "c",
        col.names = c("Registros R", "Binario", "Decimal"),
        caption = "Tabla de registros del simulador") %>%
    kable_styling(full_width = FALSE, position = "center") %>%
    column_spec(1, width = "7em") %>%
    column_spec(2, width = "7em") %>%
    column_spec(3, width = "7em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2") %>%
    footnote(
      general = "Los registros AL, BL, CL y DL corresponden a registros de propósito general de 8 bits.",
      general_title = "Nota: ",
      threeparttable = TRUE
    )
}
```

## Ciclo de la instrucción
El ciclo de la instrucción es la secuencia de pasos que sigue la Unidad de Control (UC) para ejecutar cada instrucción de un programa. Es un proceso esencial para el funcionamiento de cualquier computadora, en el que intervienen elementos clave como registros, buses de datos, direcciones y control, y las señales de control generadas por la UC.

Las microoperaciones que lo componen se expresan con la notación de transferencia entre registros: `destino` $\leftarrow$ `origen` .

La Figura \@ref(fig:flujoCicloInstruccion) muestra el flujo general del ciclo, que se divide en dos etapas principales: captación (fetch) y ejecución.

```{r flujoCicloInstruccion, echo=FALSE, fig.cap="Flujo del ciclo de instrucción en VonSim8", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/cicloinstruccion3.png")
```

### Etapa 1: Captación

Esta etapa es igual para todas las instrucciones. Su objetivo es leer la instrucción desde la memoria y cargarla en el **Registro de Instrucciones** (`IR`). Consta de tres microoperaciones:

1. **`MAR` $\leftarrow$ `IP`**
  La UC transfiere la dirección de la próxima instrucción, almacenada en el **Puntero de Instrucción** (`IP`) al **Registro de Direcciones de Memoria** (`MAR`).

2. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1**
  La UC activa la señal de lectura a través del bus de control para obtener la instrucción indicada en la dirección del `MAR`. El valor leído se guarda en el **Registro de Datos de Memoria** (`MBR`) y, al mismo tiempo, el `IP` se incrementa para apuntar a la siguiente instrucción u operando.

3. **`IR` $\leftarrow$ `MBR`**
  El contenido del `MBR` se transfiere al `IR`. A partir de este momento, la instrucción está lista para ser decodificada y ejecutada.

### Etapa 2: Ejecución:
En esta etapa, el **decodificador de instrucciones** interpreta el valor en el registro `IR`. A partir del código de operación (opcode), lee las microinstrucciones necesarias desde la **memoria de control** para determinar el tipo de instrucción, la cantidad de operandos y el modo de direccionamiento.

Luego, envía estas microinstrucciones al **secuenciador**, que genera las señales de control exactas para ejecutar la operación.

A continuación se explican las instrucciones más comunes.

#### Instrucciones con dos operandos `MOV`, `ADD`, `SUB` y `CMP`:

- **Destino en registro (`Rx`)**
  - **Modo entre registros (`Rx`, `Ry`)**
    4. La ejecución ocupa un paso y puede ser:
        - MOV: **`Rx` $\leftarrow$ `Ry`**
        - ADD: **`Rx` $\leftarrow$ `Rx` + `Ry` | update(Flags)**
        - SUB: **`Rx` $\leftarrow$ `Rx` - `Ry` | update(Flags)**
        - CMP: **`Rx` - `Ry` | update(Flags)** (solo actualiza flags, no guarda el resultado)
  - **Modo directo (`Rx`, `[Dirección]`)**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección del operando fuente.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer la dirección desde memoria e incrementar IP.
    6. **`MAR` $\leftarrow$ `MBR`** – Transferir la dirección al MAR.
    7. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Obtener el dato.
    8. Ejecutar la operación:
        - MOV: **`Rx`  $\leftarrow$ `MBR`**
        - ADD: **`Rx`  $\leftarrow$ `Rx` + `MBR` | update(Flags)**
        - SUB: **`Rx`  $\leftarrow$ `Rx` - `MBR` | update(Flags)**
        - CMP: **`Rx` - `MBR` | update(Flags)**
  - **Modo inmediato (`Rx`, `Dato`)**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección del dato inmediato.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer el dato e incrementar IP.
    6. Ejecutar la operación (igual que en el caso anterior).
  - **Modo indirecto (`Rx`, `[BL]`)**
    4. **`MAR` $\leftarrow$ `BL`** – Obtener dirección del dato desde el registro BL.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer el dato.
    6. Ejecutar la operación (igual que en el caso anterior).

- **Destino en memoria (`[Dirección]` o `[BL]`)**
En este caso, el resultado de la operación no se almacena en un registro, sino en una posición de memoria especificada directamente en la instrucción o indicada por el contenido del registro BL.
  - **Modo Directo (`[Dirección]`, `Ry`)**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección destino.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer la dirección e incrementar IP.
    6. **`MAR` $\leftarrow$ `MBR`** – Transferir dirección a MAR.
    Según la instrucción:
      - MOV:
          7. **`MBR` $\leftarrow$ `Ry`** – Copiar Ry al MBR.
          8. **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.
      - ADD, SUB, CMP:
          7. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer el dato.
          8. Ejecutar la operación:
              - ADD: **`MBR` $\leftarrow$ `MBR` + `Ry` | update(Flags)**
              - SUB: **`MBR` $\leftarrow$ `MBR` - `Ry` | update(Flags)**
              - CMP: **`MBR` - `Ry` | update(Flags)**
          9. Si es `ADD` o `SUB`: **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.
  - **Modo Indirecto (`[BL]`, `Ry`)**
    4. **`MAR` $\leftarrow$ `BL`** – Transferir dirección de destino (en BL) a MAR.
    Según la instrucción:
      - MOV:
          5. **`MBR` $\leftarrow$ `Ry`** – Copiar Ry al MBR.
          6. **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.
      - ADD, SUB, CMP:
          5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer el dato.
          6. Ejecutar la operación (igual que en el caso anterior).
          7. Si es `ADD` o `SUB`: **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.
  - **Modo Directo-Inmediato (`[Dirección]`, `Dato`)**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección destino.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer dirección e incrementar IP.
    6. **`MAR` $\leftarrow$ `IP`; `ri` $\leftarrow$ `MBR`** – Preparar para leer el dato y guardar la dirección destino en un registro intermedio (ri).
    7. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer dato e incrementar IP.
    Según la instrucción:
      - MOV:
          8. **`MAR` $\leftarrow$ `ri`** – Copiar dirección destino.
          9. **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.
      - ADD, SUB, CMP:
          8. **`MAR` $\leftarrow$ `ri` | `id` $\leftarrow$ `MBR`** – Cargar dirección destino y guardar el valor inmediato en id.
          9. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer el valor actual de destino.
          10. Ejecutar la operación:
              - ADD: **`MBR` $\leftarrow$ `MBR` + `id` | update(Flags)**
              - SUB: **`MBR` $\leftarrow$ `MBR` - `id` | update(Flags)**
              - CMP: **`MBR` - `id` | update(Flags)**
          11. Si es `ADD` o `SUB`: **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.
  - **Modo Indirecto-Inmediato (`[BL]`, `Dato`)**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección del dato inmediato.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer dato e incrementar IP.
    Según la instrucción:
      - MOV:
          6. **`MAR` $\leftarrow$ `BL`** – Copiar dirección de destino.
          7. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**
      - ADD, SUB, CMP:
          6. **`MAR` $\leftarrow$ `BL` | `id` $\leftarrow$ `MBR`** – Cargar la dirección destino y guardar el valor inmediato en id.
          7. **`MBR` $\leftarrow$ `read(Memoria[MAR])`** – Leer el valor actual de destino.
          8. Ejecutar la operación:
              - ADD: **`MBR` $\leftarrow$ `MBR` + `id` | update(Flags)**
              - SUB: **`MBR` $\leftarrow$ `MBR` - `id` | update(Flags)**
              - CMP: **`MBR` - `id` | update(Flags)**
          9. Si es `ADD` o `SUB`: **`write(Memoria[MAR])` $\leftarrow$ `MBR`** – Escribir en memoria.

#### Instrucciones con un operando `JMP` y `Jxx`:
- **Salto a (`Dirección`)**
  Tanto incondicional `JMP` como condicionales `Jxx` tienen estos pasos:
  4. **`MAR` $\leftarrow$ `IP`** – Obtener la dirección del salto.
  5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`; `IP` $\leftarrow$ `IP` + 1** – Leer la dirección de destino e incrementar IP.

  Según la instrucción:
    - JMP: 
      6. **`IP` $\leftarrow$ `MBR`**

    - Jxx: 
      6. **`IP` $\leftarrow$ `MBR`** si se cumple la condición del flag `xx`; en caso contrario, continúa con la siguiente instrucción.

#### Instrucciones sin operandos
  Según la instrucción:
    - HLT: 
      4. Detiene la ejecución de la CPU.

## Modulo de Entrada/Salida
El simulador puede configurarse para conectar módulos de entrada/salida al bus y otros dispositivos. Estos se encuentran agrupados, y cada uno de estos grupos puede conectarse solo si lo desea el usuario:

  - Teclado y pantalla: un teclado y una pantalla.
  - PIC: un PIC, además de la tecla F10 para interrumpir, y un timer con su reloj.
  - PIO: un PIO que puede conectarse a llaves y luces o a una impresora Centronics.
  - Handshake: Una impresora Centronics conectada por un Handshake.

Para poder utilizar los dispositivos de entrada y salida es necesario presentar nuevas instrucciones al conjunto de instrucciones del procesador.

```{r isacompleta, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

isacompleta <- data.frame(
  `Código operación` = c("MOV", "ADD", "JMP", "PUSH, POP, OUT, IN", "INT , IRET", "NOP , HLT"),
  Instrucciones = c("Transferencia de datos", "Aritmética", "Control de flujo", "Pila y E/S", "Interrupciones", "Control"),
  nemónico = c(
    "MOV destino, origen",
    "ADD destino, origen",
    "JMP destino",
    "PUSH, POP, OUT, IN",
    "INT , IRET",
    "NOP , HLT"
  ),
  Acción = c(
    "1- Copiar entre registros 2- Cargar a registro 3- Almacenar en memoria",
    "1- Sumar  2- Restar 3- Comparar",
    "Salto incondicional JMP. Saltos condicionales Jxx. Llamadas a rutinas CALL y retorno RET",
    "Poner en la pila PUSH. Retirar de la pila POP. Enviar un byte al puerto del dispositivo de E/S. Recibir un byte del dispositivo de E/S",
    "Llamar a una rutina de tratamiento de interrupción INT. Retornar de una rutina de tratamiento de interrupción IRET",
    "No opera NOP. Detiene el CPU HLT"
  )
)

tabla_kable <- kable(isacompleta,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Tabla de Instrucciones y Códigos de Operación de la Arquitectura x86",
               col.names = c("Código operación", "Instrucciones", "Nemónico", "Acción"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c", "c"))

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "5.5cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(isacompleta)),
             extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "10em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "32em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

### Subrutinas
El procesador también implementa subrutinas. Estas son pequeños fragmentos de código que pueden ser llamados desde cualquier parte del programa. Para ello, se utiliza la instrucción [`CALL`]. Esta instrucción almacena el `IP` en la [pila], y luego realiza un salto a la dirección de la subrutina, modificando el `IP` para que este apunte a la primera instrucción de la subrutina. Para volver de la subrutina, se utiliza la instrucción [`RET`], que desapila la dirección apilada previamente por `CALL` y restaura el `IP`, volviendo a el punto de ejecución posterior a la llamada a la subrutina.

Ejemplo de subrutina:

```vonsim
      mov al, 1
      mov bl, 2
      mov cl, 3
      call sum3
      ; ax = 6
      hlt

      ; suma al, bl y cl
      sum3: add al, bl
            add al, cl
            ret
```

### Interrupciones
El simulador tiene predefinido el vector de interrupción en ciertas posiciones de reservadas de memoria, dentro de dicho vector encontraremos las rutinas del sistema predefinidas para interactuar con el teclado y monitor. 
En el caso de las interrupciones por software, esta es dada por el operando de la instrucción `INT` número. Una vez interrumpido, el procesador ejecutará la rutina de interrupción asociada a ese número de interrupción. La dirección de comienzo de esta rutina estará almacenada en el vector de interrupciones. Este vector ocupa las celdas `00h` hasta `07h` de la memoria principal, y cada elemento del vector tiene 1 byte de largo -- el primer elemento se encuentra en `0h`, el segundo en `1h`, el tercero en `2h`, y así. Cada elemento corresponde con la dirección de inicio de la rutina de interrupción.

El procesador admite interrupciones por hardware y por software, que pueden ser emitidas por el PIC o por la instrucción `INT` respectivamente. Para ejecutar interrupciones por hardware, el procesador debe estar habilitado para recibir interrupciones. Esto es, `IF=1` (la _flag_ de interrupciones activada).

Ambas interrupciones deben propocionar un número de interrupción. En el caso de las interrupciones por software, esta es dada por el operando de la instrucción `INT`. En el caso de las interrupciones por hardware, esta es dada por el PIC. El número de interrupción debe ser un número entre `0` y `7`.

Una vez interrumpido, el procesador ejecutará la rutina de interrupción asociada a ese número de interrupción. La dirección de comienzo de esta rutina estará almacenada en el vector de interrupciones. Este vector ocupa las celdas `00h` hasta `07h` de la memoria principal, y cada elemento del vector tiene 1 byte de largo -- el primer elemento se encuentra en `0h`, el segundo en `1h`, el tercero en `2h`, y así. Cada elemento corresponde con la dirección de inicio de la rutina de interrupción.

Específicamente, el procesador:

1. obtiene el número de la interrupción (0-7),
2. apila el registro `FLAGS`,
3. inhabilita las interrupciones `I=0`,
4. apila el registro `IP`,
5. obtiene la dirección de la rutina de interrupción del vector de interrupciones,
6. modifica el `IP` para que apunte a la dirección de la rutina de interrupción.

Y así se comienza a ejecutar la rutina de interrupción. Estas tienen el mismo formato que una subrutina salvo que terminan en `IRET` en vez de `RET`.

#### Llamadas al sistema
El simulador permite realizar llamadas al sistema o _syscalls_. En el simulador, estas llamadas son realizadas idénticamente a las interrupciones. Así, para realizar una _syscall_ basta con interrumpir a la CPU con el número de interrupción correspondiente. Estos números son:

- `INT 0`: termina la ejecución del programa, equivalente a la instrucción `HLT`;
- `INT 6`: lee un carácter del teclado;
- `INT 7`: escribe una cadena de caracteres en pantalla.

Las direcciones del vector de interrupciones asociadas a estos números están protegidas por el sistema, impidiendo que el usuario las modifique.

El contenido de estas rutinas se encuentran almacenadas en el monitor del sistema en las direcciones `A0h`, `B0h` y `C0h` respectivamente.

## Pila
En esta etapa se incorporaron las instrucciones de manejo de pila y de interrupciones, ampliando la funcionalidad del simulador para cubrir un conjunto más completo de operaciones propias de la arquitectura x86.

El procesador implementa la pila como método de almacenamiento accesible por el usuario y por la misma CPU para su correcto funcionamiento. Esta es del estilo _Last In, First Out_ (LIFO), es decir, el último elemento en entrar es el primero en salir. La pila se encuentra en la memoria principal, comenzando en la dirección más alta de la misma (`FFh`) y creciendo hacia las direcciones más bajas (`FEh`, `FCh`, etc.). El tope de la pila se guarda en el registro `SP`. Todos los elementos de la pila son de 8 bits.

### Instrucciones IN y OUT
Para la comunicacion con los módulos de entrada/salida se utilizan puertos, que son direcciones especiales en el espacio de direcciones del procesador. En este simulador, se implementan dos instrucciones para manejar la comunicación con los puertos:
- `OUT puerto, AL`: Esta instrucción envía el contenido del registro `AL` al puerto especificado. El puerto es una dirección de 8 bits, lo que permite un total de 256 puertos diferentes (de `00h` a `FFh`). Esta instrucción se utiliza para enviar datos a dispositivos externos, como impresoras o pantallas.
- `IN AL, puerto`: Esta instrucción recibe un byte desde el puerto especificado y lo almacena en el registro `AL`. Al igual que la instrucción `OUT`, el puerto es una dirección de 8 bits.


### Pantalla
La pantalla es un dispositivo de salida que permite mostrar caracteres. La forma de comunicarse con la pantalla es mediante una llamada al sistema. Esto es así por simplicidad, ya que una pantalla real es mucho más compleja.

Con la llamada INT 7 se escribe una cadena de caracteres en la pantalla. Recibe dos parámetros:

AL: longitud de la cadena a imprimir
BL: dirección de memoria donde empieza la cadena

```{r  code´pantalla, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
org 10h
cadena db `Hola!`

org 20h
mov BL, offset cadena
mov AL, 5
int 7
; Se imprime Hola! (sin las comillas) en la pantalla.
hlt\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
org 10h
cadena db `Hola!`

org 20h
mov BL, offset cadena
mov AL, 5
int 7
; Se imprime Hola! (sin las comillas) en la pantalla.
hlt
```")
}
```

Hay tres caracteres especiales:

- el carácter de retroceso (`BS`, 8 en decimal) borra el carácter previo;
- el carácter de salto de línea (`LF`, 10 en decimal) imprime, en efecto, un salto de línea — útil para no imprimir todo en una sola línea;
- el carácter de _form feed_ (`FF`, 12 en decimal) limpia la pantalla.

### Teclado
El teclado es un dispositivo de entrada que permite al usuario ingresar caracteres al sistema. La forma de comunicarse con el teclado es mediante una llamada al sistema. Esto es así por simplicidad, ya que un teclado real es mucho más complejo.

Con la llamada INT 6 se detiene la ejecución del código hasta que se presione una tecla en el teclado. El carácter que correspona será guardado en la dirección de memoria almacenada en BL según su representación en ASCII.

```{r  codeteclado, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
org 10h
car db 0

org 20h
mov bl, offset car
int 6
; El usuario escribe un carácter
hlt

; El carácter escrito se almacenó en 'car'.
; Por ejemplo, si el usuario presionó la tecla 'a', entonces
; se almacena el valor 61h en 'car'.\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
org 10h
car db 0

org 20h
mov bl, offset car
int 6
; El usuario escribe un carácter
hlt

; El carácter escrito se almacenó en 'car'.
; Por ejemplo, si el usuario presionó la tecla 'a', entonces
; se almacena el valor 61h en 'car'.
```")
}
```

### Puertos de E/S
La memoria de entrada/salida se encuentra aislada de la memoria principal. Es decir, para acceder a ella se utilizan exclusivamente las instrucciones [`IN`] y [`OUT`]). Cuando se quiere acceder a un módulo de entrada/salida, la [CPU] activa la señal `IO/M`, lo que causa que un selector de chips (_chip select_) lea la dirección del bus del direcciones y envíe la señal de lectura/escritura al módulo correspondiente.

El rango de direcciones de la memoria de entrada/salida es de `00h` hasta `FFh` (256 direcciones).

Estos son las direcciones de entrada/salida disponibles en el simulador, todos de 8 bits:

| Dirección | Nombre  | Módulo                   |
| :-------: | :-----: | :----------------------- |
|   `10h`   | `CONT`  | [Timer]         |
|   `11h`   | `COMP`  | [Timer]         |
|   `20h`   |  `EOI`  | [PIC]           |
|   `21h`   |  `IMR`  | [PIC]            |
|   `22h`   |  `IRR`  | [PIC]            |
|   `23h`   |  `ISR`  | [PIC]             |
|   `24h`   | `INT0`  | [PIC]             |
|   `25h`   | `INT1`  | [PIC]            |
|   `26h`   | `INT2`  | [PIC]            |
|   `27h`   | `INT3`  | [PIC]            |
|   `28h`   | `INT4`  | [PIC]           |
|   `29h`   | `INT5`  | [PIC]             |
|   `2Ah`   | `INT6`  | [PIC]             |
|   `2Bh`   | `INT7`  | [PIC]            |
|   `30h`   |  `PA`   | [PIO]          |
|   `31h`   |  `PB`   | [PIO]            |
|   `32h`   |  `CA`   | [PIO]            |
|   `33h`   |  `CB`   | [PIO]             |
|   `40h`   | `DATA`  | [Handshake] |
|   `41h`   | `STATE` | [Handshake] |

### Llaves y luces
Las llaves o interruptores están conectados al puerto PA/CA del PIO y son dispositivos de entrada. Al cambiar su estado, estos se reflejarán en PA (si el PIO está configurado correctamente). Si se altera PA, los cambios no se verán reflejados en las llaves (no se mueven solas, por así decirlo).

```{r  codellaves, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
; Leer el valor de las llaves como una contraseña hasta que el usuario la adivine

clave db 15               ; Contraseña esperada: 00001111 (en decimal 15)
mensaje_ok db `Bienvenido!` ; Mensaje a mostrar si la contraseña es correcta

; Configurar PA (Puerto A) como entrada
mov al, 15                ; 00001111b: configura los primeros 4 bits de PA como entrada
out 32h, al               ; Escribe en CA para configurar PA

bucle:
    in al, 30h            ; Lee el valor actual de las llaves desde PA
    cmp al, clave         ; Compara el valor leído con la contraseña
    jz Mostrar_Mensaje    ; Si coincide, salta a Mostrar_Mensaje
    jmp bucle             ; Si no coincide, vuelve a intentar

Mostrar_Mensaje:
    mov bl, offset mensaje_ok ; BL apunta al mensaje de éxito
    mov al, 11                ; Longitud del mensaje (Bienvenido! tiene 11 caracteres)
    hlt                       ; Detiene la ejecución del programa\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
; Leer el valor de las llaves como una contraseña hasta que el usuario la adivine

clave db 15               ; Contraseña esperada: 00001111 (en decimal 15)
mensaje_ok db `Bienvenido!` ; Mensaje a mostrar si la contraseña es correcta

; Configurar PA (Puerto A) como entrada
mov al, 15                ; 00001111b: configura los primeros 4 bits de PA como entrada
out 32h, al               ; Escribe en CA para configurar PA

bucle:
    in al, 30h            ; Lee el valor actual de las llaves desde PA
    cmp al, clave         ; Compara el valor leído con la contraseña
    jz Mostrar_Mensaje    ; Si coincide, salta a Mostrar_Mensaje
    jmp bucle             ; Si no coincide, vuelve a intentar

Mostrar_Mensaje:
    mov bl, offset mensaje_ok ; BL apunta al mensaje de éxito
    mov al, 11                ; Longitud del mensaje (Bienvenido! tiene 11 caracteres)
    hlt                       ; Detiene la ejecución del programa
```")
}
```

Las luces o LED están conectadas al puerto PB/CB del PIO y son dispositivos de salida. La única forma de cambiar su estado es modificando PB. Estos cambios se reflejarán en las luces si el PIO está configurado correctamente, de lo contrario, las luces se verán apagadas.

```{r  codeluces, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
; Enciende las luces (una sí, una no): 1010 1010b
; 31h = PB --> puerto de datos para las luces (LEDs)
; 33h = CB --> puerto de control para las luces

; Configura todos los bits de PB como salida para controlar las luces
mov al, 0                ; 0000 0000b: todos los bits de PB en modo salida
out 33h, al              ; Escribe en CB para configurar PB como salida

; Enciende las luces alternadas: 1010 1010b (170 decimal)
mov al, 170              ; 1010 1010b: enciende LEDs pares, apaga impares
out 31h, al              ; Escribe el valor en PB para actualizar las luces

hlt                      ; Detiene la ejecución del programa\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
; Enciende las luces (una sí, una no): 1010 1010b
; 31h = PB --> puerto de datos para las luces (LEDs)
; 33h = CB --> puerto de control para las luces

; Configura todos los bits de PB como salida para controlar las luces
mov al, 0                ; 0000 0000b: todos los bits de PB en modo salida
out 33h, al              ; Escribe en CB para configurar PB como salida

; Enciende las luces alternadas: 1010 1010b (170 decimal)
mov al, 170              ; 1010 1010b: enciende LEDs pares, apaga impares
out 31h, al              ; Escribe el valor en PB para actualizar las luces

hlt                      ; Detiene la ejecución del programa
```")
}
```

Actualmente el código de operación de las instrucciones son 4 bits, esto reduce a complejidad del simulador y el numero de instrucciones que se pueden implementar, para no tener que ampliar el tamaño de las instrucciones, pero poder mostrar más instrucciones, por ejemplo logicas y aritmeticas de 1 operando, se implementaron instrucciones con el código de operación 15, entonces las instrucciones logicas con código operación 15 (AND, OR y XOR) tienen los mismos modos de direccionamiento que las instrucciones aritméticas (ADD, SUB y CMP) pero comparten el mismo código de operación.

```{r tisa, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

tisa <- data.frame(
  Categoría = c(
    "Transferencia de datos",
    "Procesamiento de datos", "", "",
    "Control de flujo",
    "Gestión de flujo",
    "Manejo de pila y E/S",
    "Miscelánea"
  ),
  Instrucción = c(
    "MOV",
    "ADD", "SUB", "CMP",
    "JMP / Jxx / CALL / INT",
    "RET / IRET / CLI / STI / HLT",
    "PUSH / POP / OUT / IN",
    "AND / OR / XOR / NOT / INC / DEC"
  ),
  `Código operación` = c(
    "{0, 1, 2}",
    "{3, 4, 5}", "{6, 7, 8}", "{9, 10, 11}",
    "{12}",
    "{13}",
    "{14}",
    "{15}"
  ),
  Acción = c(
    "Copiar entre registros, cargar a registro, almacenar en memoria",
    "Operación aritmética: operando1 ← operando1 + operando2",
    "Operación aritmética: operando1 ← operando1 - operando2",
    "Comparación: operando1 - operando2 (no actualiza el destino)",
    "Salto incondicional JMP, condicionales Jxx, llamada CALL, INT: llamar rutina de interrupción",
    "RET: retorno, IRET: retornar de interrupción, NOP: no opera, HLT: detiene el CPU",
    "PUSH: poner en la pila, POP: retirar de la pila, OUT: enviar a puerto, IN: recibir desde puerto",
    "Operaciones lógicas y aritméticas"
  ),
  stringsAsFactors = FALSE
)

tabla_kable <- kable(tisa,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Categorías de instrucciones y códigos de operación en VonSim8",
               col.names = c("Categoría", "Instrucción", "Código operación", "Acción"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c", "l"))

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "4cm") %>%
    column_spec(3, width = "3cm") %>%
    column_spec(4, width = "8cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tisa)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "12em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "16em") %>%
    column_spec(3, width = "8em") %>%
    column_spec(4, width = "32em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

### Etapa de ejecución de instrucciones

- **Subrutinas**
  - **CALL `Dirección`**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección destino.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer la dirección e incrementar IP.
    6. **`ri` $\leftarrow$ `MBR` | `SP` $\leftarrow$ `SP` - 1**
    7. **`MAR` $\leftarrow$ `SP` | `MBR` $\leftarrow$ `IP`**
    8. **`write(Memoria[MAR])` $\leftarrow$ `MBR` | `IP` $\leftarrow$ `ri`**
  - **RET**
    4. **`MAR` $\leftarrow$ `SP`**
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`**
    6. **`IP` $\leftarrow$ `MBR`| `SP` $\leftarrow$ `SP` + 1**

- **Interrupciones**
  - **INT `Dirección`**
    4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección destino.
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer la dirección e incrementar IP.
    6. **`ri` $\leftarrow$ `MBR` | `SP` $\leftarrow$ `SP` - 1**
    7. **`MAR` $\leftarrow$ `SP` | `MBR` $\leftarrow$ `Flags`**
    8. **`write(Memoria[MAR])` $\leftarrow$ `MBR` | update(Flags I=0)**
    9. **`MBR` $\leftarrow$ `IP` | `SP` $\leftarrow$ `SP` - 1**
    10. **`MAR` $\leftarrow$ `SP`**
    11. **`write(Memoria[MAR])` $\leftarrow$ `MBR` | `IP` $\leftarrow$ `ri`**
  - **IRET**
    4. **`MAR` $\leftarrow$ `SP`**
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`**
    6. **`IP` $\leftarrow$ `MBR` | `SP` $\leftarrow$ `SP` + 1**
    7. **`MAR` $\leftarrow$ `SP`**
    8. **`MBR` $\leftarrow$ `read(Memoria[MAR])`**
    9. **`Flags` $\leftarrow$ `MBR` | `SP` $\leftarrow$ `SP` - 1**
  - **CLI**
    4. **update(Flags I=1)**
  - **STI**
    4. **update(Flags I=0)**
- **E/S**
  - **OUT**
    - Direccion destino en registro **OUT DL, AL**
        4. **`MAR` $\leftarrow$ `DL`** – Dirección destino.
        5. **`MBR` $\leftarrow$ `AL`** – Contenido a escribir.
        6. **`write(E-S[MAR])` $\leftarrow$ `MBR`**.
    - Direccion destino inmediato **OUT inmediato, AL**  
        4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección del dato inmediato.
        5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer el dato e incrementar IP.
        6. **`MAR` $\leftarrow$ `MBR`** – Dirección destino.
        7. **`MBR` $\leftarrow$ `AL`** – Contenido a escribir.
        8. **`write(E-S[MAR])` $\leftarrow$ `MBR`**
  - **IN**
    - Direccion destino en registro **IN AL, DL**
      4. **`MAR` $\leftarrow$ `DL`** – Dirección destino.
      5. **`MBR` $\leftarrow$ `read(E-S[MAR])`** – Contenido a leer.
      6. **`AL` $\leftarrow$ `MBR`**
    - Direccion destino inmediato **IN  AL, inmediato**
      4. **`MAR` $\leftarrow$ `IP`** – Obtener dirección del dato inmediato.
      5. **`MBR` $\leftarrow$ `read(Memoria[MAR])` | `IP` $\leftarrow$ `IP` + 1** – Leer el dato e incrementar IP.
      6. **`MAR` $\leftarrow$ `MBR`** – Dirección destino.
      7. **`MBR` $\leftarrow$ `read(E-S[MAR])`** – Contenido a leer.
      8. **`AL` $\leftarrow$ `MBR`**
- **Pila**
  - **POP Rx**
    4. **`MAR` $\leftarrow$ `SP`** 
    5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`**
    6. **`Rx` $\leftarrow$ `MBR`** | `SP` $\leftarrow$ `SP` + 1
  - **PUSH Ry**
    4. **`MAR` $\leftarrow$ `SP`** 
    5. **`MBR` $\leftarrow$ `Ry`** | `SP` $\leftarrow$ `SP` - 1
    5. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**


Se implementaron operaciones lógicas con dos operandos AND, OR y XOR que tienen los mismos pasos de ejecución que las operaciones ADD y SUB, donde cambia únicamente la operación que realiza la ALU.

Se agregaron operaciones aritméticas y lógicas de un solo operando:
- **INC `Rx`** 
  4 - **`Rx`  $\leftarrow$ `Rx` + 1 | update(Flags)**

- **DEC `Rx`** 
  4 - **`Rx`  $\leftarrow$ `Rx` - 1 | update(Flags)**

- **NOT `Rx`** 
  4 - **`Rx`  $\leftarrow$ NOT `Rx` | update(Flags)**

- **NEG `Rx`** 
  4 - **`Rx`  $\leftarrow$ CA2 `Rx` | update(Flags)**



```{r instaccion, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

instaccion <- data.frame(
  Tipo = c(
    "A: Entre registros",
    "", "", "",
    "B: Cargar a registro",
    "", "", "", "", "", "", "", "", "", "", "",
    "C: Almacenar en memoria",
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
    "D: control de flujo",
    "", ""
  ),
  Ejemplo = c(
    "MOV Rx, Ry", "ADD Rx, Ry", "SUB Rx, Ry", "CMP Rx, Ry",
    "MOV Rx, [M]", "MOV Rx, [BL]", "MOV Rx, d", "ADD Rx, [M]", "ADD Rx, [BL]", "ADD Rx, d",
    "SUB Rx, [M]", "SUB Rx, [BL]", "SUB Rx, d", "CMP Rx, [M]", "CMP Rx, [BL]", "CMP Rx, d",
    "MOV [M], Ry", "MOV [BL], Ry", "MOV [M], d", "MOV [BL], d",
    "ADD [M], Ry", "ADD [BL], Ry", "ADD [M], d", "ADD [BL], d",
    "SUB [M], Ry", "SUB [BL], Ry", "SUB [M], d", "SUB [BL], d",
    "CMP [M], Ry", "CMP [BL], Ry", "CMP [M], d", "CMP [BL], d",
    "JMP M", "Jxx M", "HLT"
  ),
  Acción = c(
    "Rx ← Ry", "Rx ← Rx + Ry", "Rx ← Rx - Ry", "Rx - Ry * ",
    "Rx ← Mem[Dirección]", "Rx ← Mem[BL]", "Rx ← dato", "Rx ← Rx + Mem[Dirección]", "Rx ← Rx + Mem[BL]", "Rx ← Rx + dato",
    "Rx ← Rx - Mem[Dirección]", "Rx ← Rx - Mem[BL]", "Rx ← Rx - dato", "Rx - Mem[Dirección] (*)", "Rx - Mem[BL] (*)", "Rx - dato (*)",
    "Mem[Dirección] ← Rx", "Mem[BL] ← Rx", "Mem[Dirección] ← dato", "Mem[BL] ← dato",
    "Mem[Dirección] ← Mem[Dirección] + Rx", "Mem[BL] ← Mem[BL] + Rx", "Mem[Dirección] ← Mem[Dirección] + dato", "Mem[BL] ← Mem[BL] + dato",
    "Mem[Dirección] ← Mem[Dirección] - Rx", "Mem[BL] ← Mem[BL] - Rx", "Mem[Dirección] ← Mem[Dirección] - dato", "Mem[BL] ← Mem[BL] - dato",
    "Mem[Dirección] - Rx", "Mem[BL] - Rx", "Mem[Dirección] - dato", "Mem[BL] - dato", 
    "IP ← Dirección", "Si xx = 1 entonces IP ← Dirección", "Detiene el procesador"
  ),
  stringsAsFactors = FALSE
)

if (knitr::is_latex_output()) {
  kable(instaccion, format = "latex", booktabs = TRUE, align = "l", col.names = c("Tipo", "Ejemplo", "Acción"),
        caption = "Tabla de instrucciones y acciones") %>%
    kable_styling(latex_options = c("hold_position", "scale_down")) %>%
    column_spec(1, width = "4cm") %>%
    column_spec(2, width = "3cm") %>%
    column_spec(3, width = "8cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    footnote(
      general = "La instrucción CMP no almacena el resultado de la operación en el operando destino.",
      general_title = "Nota *: ",
      threeparttable = TRUE
    )

} else {
  kable(instaccion, format = "html", table.attr = "class='table table-striped'", align = "l", col.names = c("Tipo", "Ejemplo", "Acción"),
        caption = "Tabla de instrucciones y acciones") %>%
    kable_styling(full_width = FALSE, position = "center") %>%
    column_spec(1, width = "20em") %>%
    column_spec(2, width = "30em") %>%
    column_spec(3, width = "30em") %>%
    footnote(
      general = "La instrucción CMP no almacena el resultado de la operación en el operando destino.",
      general_title = "Nota *: ",
      threeparttable = TRUE
    )
}
```

El formato ampliado para las instrucciones incluye los siguientes casos tabla \@ref(tab:formatoampliado):

```{r formatoampliado, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear un dataframe con los datos
formatoampliado <- data.frame(
  Tipo = c("Transferencia y procesamiento", "", "", "", "", "Control"),
  Operación = c("A: entre registros", "B: Cargar a registro", "", "", "C: Almacenar en memoria", "D: control de flujo"), # nolint: line_length_linter.
  Codificación = c("____XXYY", "____XX00 MMMMMMMM", "____XX01", "____XX00 dddddddd", "____00YY MMMMMMMM dddddddd", "____ffff MMMMMMMM"), # nolint: line_length_linter, line_length_linter.
  Parámetros = c(
    "XX = Registro destino, YY = Registro fuente",
    "XX00 = Registro destino y M = Dirección de memoria",
    "XX01 = Registro destino y direccion en registro [BL]",
    "XX10 = Registro destino y d = Dato inmediato",
    "YY = Registro fuente, `M` = Dirección de memoria,  `d` = Dato Inmediato",
    "ffff = funcionalidad, M = Dirección de memoria"
  ),
  stringsAsFactors = FALSE
)

# Mostrar la tabla en formato adecuado según el tipo de salida
if (knitr::is_latex_output()) {
  kable(formatoampliado, format = "latex", booktabs = TRUE, align = "l", col.names = c("Tipo", "Operación", "Codificación", "Parámetros"), # nolint: line_length_linter.
        caption = "Tabla de codificación de instrucciones ampliado") %>%
    kable_styling(latex_options = c("hold_position", "scale_down")) %>%
    column_spec(1, width = "4cm") %>%
    column_spec(2, width = "5cm") %>%
    column_spec(3, width = "5cm") %>%
    column_spec(4, width = "6cm") %>%
    row_spec(4, extra_latex_after = "\\midrule") %>%
    footnote(
      general = "d = dato inmediato, no puede ser destino de la instrucción.", # nolint: line_length_linter.
      general_title = "Nota: ",
      threeparttable = TRUE
    )
} else {
  kable(formatoampliado, format = "html", table.attr = "class='table table-striped'", align = "l", col.names = c("Tipo", "Operación", "Codificación", "Parámetros"), # nolint: line_length_linter.
        caption = "Tabla de codificación de instrucciones ampliado") %>%
    kable_styling(full_width = FALSE, position = "center") %>%
    column_spec(1, width = "20em") %>%
    column_spec(2, width = "25em") %>%
    column_spec(3, width = "25em") %>%
    column_spec(4, width = "30em") %>%
    row_spec(4, extra_css = "border-top: 2px solid #000;") %>%
    footnote(
      general = "d = dato inmediato, no puede ser destino de la instrucción.", # nolint: line_length_linter.
      general_title = "Nota: ",
      threeparttable = TRUE
    )
}
```
