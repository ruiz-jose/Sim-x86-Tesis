% This is the Reed College LaTeX thesis template. Most of the work
% for the document class was done by Sam Noble (SN), as well as this
% template. Later comments etc. by Ben Salzberg (BTS). Additional
% restructuring and APA support by Jess Youngberg (JY).
% Your comments and suggestions are more than welcome; please email
% them to cus@reed.edu
%
% See https://www.reed.edu/cis/help/LaTeX/index.html for help. There are a
% great bunch of help pages there, with notes on
% getting started, bibtex, etc. Go there and read it if you're not
% already familiar with LaTeX.
%
% Any line that starts with a percent symbol is a comment.
% They won't show up in the document, and are useful for notes
% to yourself and explaining commands.
% Commenting also removes a line from the document;
% very handy for troubleshooting problems. -BTS

% As far as I know, this follows the requirements laid out in
% the 2002-2003 Senior Handbook. Ask a librarian to check the
% document before binding. -SN

%%
%% Preamble
%%
% \documentclass{<something>} must begin each LaTeX document
\documentclass[12pt,twoside]{templates/unerthesis}
% Packages are extensions to the basic LaTeX functions. Whatever you
% want to typeset, there is probably a package out there for it.
% Chemistry (chemtex), screenplays, you name it.
% Check out CTAN to see: https://www.ctan.org/
%%
%\ifxetex
%  \usepackage{polyglossia}
%  \setmainlanguage{spanish}
  % Tabla en lugar de cuadro
%  \gappto\captionsspanish{\renewcommand{\tablename}{Tabla}
%          \renewcommand{\listtablename}{Índice de tablas}}
%\else
%  \usepackage[spanish,es-tabla]{babel}
%\fi
%\usepackage[spanish]{babel}
%\usepackage[spanish,provide=*]{babel}


\ifxetex
  \usepackage{polyglossia}
  \setmainlanguage{spanish}
  % Tabla en lugar de cuadro
  \gappto\captionsspanish{\renewcommand{\tablename}{Tabla}  
          \renewcommand{\listtablename}{Índice de tablas}}
\else
  \usepackage[spanish,provide=*]{babel}
\fi





\usepackage{graphicx,latexsym}
\usepackage{amsmath}
\usepackage{amssymb,amsthm}
\usepackage{longtable,booktabs,setspace}
\usepackage{chemarr} %% Useful for one reaction arrow, useless if you're not a chem major
\usepackage[hyphens]{url}
% Added by CII
%\usepackage{hyperref}
\usepackage[colorlinks = true,
            linkcolor = blue,
            urlcolor  = blue,
            citecolor = blue,
            anchorcolor = blue]{hyperref}
\usepackage{lmodern}
\usepackage{float}
\floatplacement{figure}{H}
% End of CII addition
\usepackage{rotating}
\usepackage{placeins} % para fijar la posición de las tablas con \FloatBarrier


\usepackage[]{natbib}

% Next line commented out by CII
%\usepackage{biblatex}
%\usepackage{natbib}
% Comment out the natbib line above and uncomment the following two lines to use the new
% biblatex-chicago style, for Chicago A. Also make some changes at the end where the
% bibliography is included.
%\usepackage{biblatex-chicago}
%\bibliography{thesis}


% Added by CII (Thanks, Hadley!)
% Use ref for internal links
\renewcommand{\hyperref}[2][???]{\autoref{#1}}
\def\chapterautorefname{Chapter}
\def\sectionautorefname{Section}
\def\subsectionautorefname{Subsection}
% End of CII addition

% Added by CII
\usepackage{caption}
\captionsetup{width=5in}
% End of CII addition

% \usepackage{times} % other fonts are available like times, bookman, charter, palatino

% Syntax highlighting #22

% To pass between YAML and LaTeX the dollar signs are added by CII
\title{Herramienta de simulación para dar soporte a la enseñanza de arquitectura de computadoras}
\author{Ruiz Jose Maria}
% The month and year that you submit your FINAL draft TO THE LIBRARY (May or December)
\date{2024}
\division{}
\advisor{Director: Colombani Marcelo Alberto}
\institution{Universidad de Nacional de Entre Rios}
\degree{Maestría en Sistemas de Información}
%If you have two advisors for some reason, you can use the following
% Uncommented out by CII
% End of CII addition

%%% Remember to use the correct department!
\department{}
% if you're writing a thesis in an interdisciplinary major,
% uncomment the line below and change the text as appropriate.
% check the Senior Handbook if unsure.
%\thedivisionof{The Established Interdisciplinary Committee for}
% if you want the approval page to say "Approved for the Committee",
% uncomment the next line
%\approvedforthe{Committee}

% Added by CII
%%% Copied from knitr
%% maxwidth is the original width if it's less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

%Added by @MyKo101, code provided by @GerbrichFerdinands

\setlength\parindent{0pt}


% Added by CII

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\Acknowledgements{

}

\Dedication{

}

\Preface{

}

\Abstract{

}

% End of CII addition
%%
%% End Preamble
%%
%
\let\chaptername\relax
\begin{document}
%\bibliographystyle{apalike}
\bibliographystyle{IEEEtran}

% Everything below added by CII
  \maketitle

\frontmatter % this stuff will be roman-numbered
\pagestyle{empty} % this removes page numbers from the frontmatter



%  \hypersetup{linkcolor=black}
  \setcounter{tocdepth}{1}
  \setlength{\parskip}{0pt}
  \tableofcontents

\setlength\parskip{1em plus 0.1em minus 0.2em}

  \listoftables

  \listoffigures



\mainmatter % here the regular arabic numbering starts
\pagestyle{fancyplain} % turns page numbering back on

\hypertarget{resumen}{%
\chapter*{Resumen}\label{resumen}}
\addcontentsline{toc}{chapter}{Resumen}

Existe un consenso creciente en el uso de herramientas de simulación en la enseñanza para procesos dinámicos complejos, como las operaciones intrínsecas de la computadora, que permiten representar de forma visual e interactiva la organización y arquitectura interna de la computadora, facilitando así la comprensión de su funcionamiento por parte de los alumnos y el desarrollo de los temas por parte del docente. En este contexto, los simuladores juegan una pieza clave en el campo de la Arquitectura de Computadoras, permitiendo conectar fundamentos teóricos con la experiencia práctica, simpliﬁcando abstracciones y haciendo más rica la labor docente.
La arquitectura x86 es ampliamente utilizada en computadoras de escritorio y servidores. Este documento pretende realizar una comparación de los simuladores x86 que más se adecuan en el dictado de la asignatura Arquitectura de Computadoras de la carrera Licenciatura en Sistemas, establecer los criterios de evaluación y evaluar los simuladores seleccionados de acuerdo con estos criterios.

La presente investigación surge en el marco del proyecto de investigación I/D novel PID-UNER 7065: ``Enseñanza/aprendizaje de asignatura Arquitectura de Computadoras con herramientas de simulación de sistemas de cómputos''. El Proyecto es llevado a cabo en la Facultad de Ciencias de la Administración de la Universidad Nacional de Entre Ríos, se vincula directamente con la asignatura Arquitectura en Computadoras que se dicta en segundo año de la carrera Licenciatura en Sistemas perteneciente a la Facultad de Ciencias de la Administración de la Universidad Nacional de Entre Ríos.

Palabras clave: x86, simulador, aprendizaje, enseñanza, arquitectura de computadoras.

\hypertarget{agradecimientos}{%
\chapter*{Agradecimientos}\label{agradecimientos}}
\addcontentsline{toc}{chapter}{Agradecimientos}

Agradecimientos aquí.

\hypertarget{introducciuxf3n}{%
\chapter{Introducción}\label{introducciuxf3n}}

En nuestra vida cotidiana, utilizamos dispositivos como computadoras de escritorio, teléfonos y relojes inteligentes, todos ellos basados en arquitecturas específicas. Comprender su funcionamiento e interacciones nos permite diseñar y desarrollar aplicaciones más eficientes.

Es esencial que los estudiantes de Arquitectura de Computadoras comprendan tanto la estructura como el funcionamiento interno de una computadora, y adquieran experiencia práctica con ellas. Para lograrlo, es fundamental disponer de un laboratorio bien equipado con el hardware adecuado y suficiente tiempo para que los estudiantes se familiaricen con las herramientas prácticas. En este contexto, se han desarrollado numerosos simuladores que facilitan la comprensión de la estructura y el funcionamiento de las computadoras, proporcionando valiosas experiencias de aprendizaje.

Esta tesis, inscrita en la Maestría en Sistemas de Información de la Facultad de Ciencias de la Administración, está directamente vinculada con el proyecto de investigación I/D novel PID-UNER 7065, titulado ``Enseñanza/aprendizaje de Arquitectura de Computadoras con herramientas de simulación de sistemas de cómputo'', desarrollado en la Facultad de Ciencias de la Administración de la Universidad Nacional de Entre Ríos {[}\protect\hyperlink{ref-colombani_pid_2022}{1}{]}.

La asignatura Arquitectura de Computadoras forma parte del plan de estudios de la carrera de Licenciatura en Sistemas, Universidad Nacional de Entre Ríos. Su objetivo es que los estudiantes comprendan la estructura y funcionamiento de las computadoras, y la ejecución lógica de un programa a nivel de instrucciones de máquina.

El primer paso para comprender las computadoras es entender que son máquinas que toman datos del exterior, los procesan y almacenan los resultados en la memoria o los envían a dispositivos de entrada y salida.

El procesamiento se realiza a través del procesador o CPU, y es en este componente donde los estudiantes encuentran mayor complejidad y dificultades para comprender su funcionamiento.

A pesar de que es posible explicar las partes del procesador, su funcionamiento, la interacción de sus componentes y enseñar lenguaje ensamblador mediante prácticas, los estudiantes suelen tener dificultades para lograr una comprensión completa del funcionamiento.

Sin embargo, la utilización de simuladores permite afianzar los conocimientos de los temas vistos en las clases teóricas, a fin de evitar que los estudiantes desvíen su atención hacia el aprendizaje del simulador propiamente dicho, es necesario que estos sean de manejo simple, intuitivo y visualmente atractivo, simplificando su aprendizaje de su uso.

La simulación es un término de uso diario en muchos contextos: medicina, militar, entretenimiento, educación, etc., debido a que permite ayudar a comprender cómo funciona un sistema, responder preguntas como ``qué pasaría si'', con el fin de brindar hipótesis sobre cómo o por qué ocurren ciertos fenómenos.

Para continuar, se define simulación como el proceso de imitar el funcionamiento de un sistema a medida que avanza en el tiempo. Entonces para llevar a cabo una simulación, es necesario desarrollar previamente un modelo conceptual que representa las características o comportamientos del sistema, mientras que la simulación representa la evolución del modelo a medida que avanza en el tiempo {[}\protect\hyperlink{ref-banks_discrete-event_2010}{2}{]}{[}\protect\hyperlink{ref-law_simulation_2015}{3}{]}{[}\protect\hyperlink{ref-robinson_simulation_2014}{4}{]}.

Con los avances en el mundo digital, la simulación se ha convertido en una metodología de solución de problemas indispensable para ingenieros, docentes, diseñadores y gerentes. La complejidad intrínseca de los sistemas informáticos los hace difícil comprender y costosos de desarrollar sin utilizar simulación {[}\protect\hyperlink{ref-law_simulation_2015}{3}{]}.

Muchas veces en el ámbito educativo, resulta difícil transmitir fundamentos teóricos de la organización y arquitectura interna de las computadoras debido a la complejidad de los procesos involucrados. Si sólo incorporamos los medios de enseñanza tradicionales, como ser una pizarra, un libro de texto o diapositivas, los mismos tienen una capacidad limitada para representar estos fundamentos. En consecuencia, es imprescindible un alto nivel de abstracción por parte del estudiante para desarrollar un modelo mental adecuado para capturar la organización y arquitectura interna de las computadoras {[}\protect\hyperlink{ref-lion_simuladores_2005}{5}{]}{[}\protect\hyperlink{ref-contreras_uso_2010}{6}{]}{[}\protect\hyperlink{ref-garcia-garcia_pbbcache_2020}{7}{]}.

Es evidente la necesidad de utilizar nuevas tecnologías como recursos didácticos y medios de transferencia de conocimiento, ya que ayudan a los estudiantes a relacionar conceptos abstractos con realidades concretas. Estas tecnologías permiten situar al estudiante en un contexto que imita aspectos de la realidad, facilitando la detección de problemáticas similares a las que podrían ocurrir en situaciones reales. Este enfoque promueve un mejor entendimiento a través del trabajo exploratorio, la inferencia, el aprendizaje por descubrimiento y el desarrollo de habilidades {[}\protect\hyperlink{ref-nova_tool_2013}{8}{]}{[}\protect\hyperlink{ref-mustafa_evaluating_2010}{9}{]}.

Un simulador de arquitectura es una herramienta que imita el hardware de un sistema, representando sus aspectos arquitectónicos y funciones. Permiten realizar cambios, pruebas y ejecutar programas sin riesgo de dañar componentes ni depender de equipos físicos disponibles {[}\protect\hyperlink{ref-radivojevic_design_2011}{10}{]}.

Algunas herramientas ofrecen una representación en forma visual e interactiva de la organización y arquitectura interna de la computadora, facilitando así la comprensión de su funcionamiento. En este sentido, los simuladores juegan una pieza clave en el campo de la Arquitectura de Computadores, permitiendo conectar fundamentos teóricos con la experiencia práctica, simpliﬁcando abstracciones y facilitando la labor docente {[}\protect\hyperlink{ref-nikolic_survey_2009}{11}{]}{[}\protect\hyperlink{ref-hasan_survey_2012}{12}{]}{[}\protect\hyperlink{ref-hennessy_computer_2012}{13}{]}{[}\protect\hyperlink{ref-stallings_computer_2013}{14}{]}.

El repertorio de instrucciones de la arquitectura x86, ampliamente utilizado en computadoras de escritorio y servidores, comenzó con el procesador Intel 8086 en 1978 como una arquitectura de 16 bits. Evolucionó a una arquitectura de 32 bits con el procesador Intel 80386 en 1985 (i386 o x86-32) y posteriormente a 64 bits con las extensiones de AMD (AMD64) y su adopción por Intel (Intel 64) {[}\protect\hyperlink{ref-intel_64_2016}{15}{]}{[}\protect\hyperlink{ref-amd_developer_2019}{16}{]}.

Un procesador x86-64 mantiene la compatibilidad con los modos x86 existentes de 16 y 32 bits, y permite ejecutar aplicaciones de 16 y 32 bits, como así también de 64 bits. Esta compatibilidad hacia atrás protege las principales inversiones en aplicaciones y sistemas operativos desarrollados para la arquitectura x86 {[}\protect\hyperlink{ref-intel_64_2016}{15}{]}{[}\protect\hyperlink{ref-amd_developer_2019}{16}{]}{[}\protect\hyperlink{ref-abel_ibm_2000}{17}{]}.

Por ello, la enseñanza de la arquitectura x86 es de gran relevancia en la asignatura Arquitecturas de Computadoras debido a los diferentes temas que aborda.

Para brindar esta experiencia, es necesario un laboratorio equipado con el hardware adecuado y tiempo suficiente para que los estudiantes se familiaricen con las herramientas. Por este motivo, se han desarrollado muchos simuladores que facilitan la comprensión del funcionamiento y la estructura del computador, ofreciendo valiosas experiencias de aprendizaje {[}\protect\hyperlink{ref-skrien_cpu_2001}{18}{]}.

\hypertarget{justificaciuxf3n}{%
\section{Justificación}\label{justificaciuxf3n}}

Aunque ya existen simuladores de la arquitectura x86 que apoyan la enseñanza en los cursos de Arquitectura de Computadoras {[}\protect\hyperlink{ref-radivojevic_design_2011}{10}{]}{[}\protect\hyperlink{ref-nikolic_survey_2009}{11}{]}, estos suelen presentar una gran cantidad de contenidos preestablecidos. Si bien estos contenidos son relevantes, ofrecer toda la especificación de la arquitectura x86 desde el principio puede ser abrumador para los estudiantes y dificultar su comprensión. Sin embargo, desde esta tesis se propone un enfoque diferente: desarrollar una herramienta de simulación de la arquitectura x86 para apoyar la enseñanza de los contenidos específicos de la currícula de Arquitectura de Computadoras. Partiendo de una visión global de la estructura y funcionamiento de la computadora (CPU, memoria, módulo de E/S y buses), mostrando los micropasos necesarios para la realización del ciclo básico de una instrucción, ofreciendo un repertorio reducido de instrucciones que se habiliten las instrucciones a medida que se dictan en la asignatura, permitiendo la generación y ejecución de programas escritos en lenguaje ensamblador, ya sea paso a paso por instrucción o completa, gestión básica de interrupciones permitiendo la interacción con el teclado y la pantalla, comunicación con los módulos de entrada y salida e interacciones con los periféricos, y por último, medidas de rendimiento sobre la ejecución de un programa.

Con el objeto de ofrecer al estudiante un simulador bien diseñado, robusto, modular y por tanto flexible y sencillo de modificar o ampliar, se explorará la utilización de técnicas formales de modelización y simulación como las redes de Petri o DEVS (Discrete Event System Specification). Estas técnicas permiten separar conceptualmente las capas de modelización y simulación y ofrecen por ello una separación ortogonal de ambas, facilitando la comprensión y modificación del software. Además, permiten el escalado transparente de las simulaciones, pudiéndose ejecutar en entornos de cómputo paralelo o distribuido sin necesidad de modificar el modelo en sí, lo que aporta grandes ventajas de escalado {[}\protect\hyperlink{ref-peterson_petri_1981}{19}{]}{[}\protect\hyperlink{ref-zeigler_theory_2000}{20}{]}{[}\protect\hyperlink{ref-zeigler_theory_2018}{21}{]}.

\hypertarget{objetivos}{%
\section{Objetivos}\label{objetivos}}

El objetivo principal de esta tesis es construir una herramienta de simulación de la arquitectura x86 para apoyar la enseñanza de arquitectura de computadoras, enfocándose específicamente en los contenidos de la currícula de Arquitectura de Computadoras. Para lograr este objetivo, se plantean los siguientes objetivos específicos:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Estudiar y evaluar diferentes herramientas actuales de simulación destinadas a dar apoyo a la enseñanza de la arquitectura x86.
\item
  Construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras, para ello debe cumplir:

  \begin{itemize}
  \tightlist
  \item
    Una visión global de la estructura y funcionamiento de la computadora.
  \item
    Generación y ejecución de programas en ensamblador.
  \item
    Repertorio de instrucciones x86 reducido y habilitado progresivamente.
  \item
    Simulación visual e interactiva de micropasos de instrucciones.
  \item
    Gestión de interrupciones y comunicación con periféricos.
  \item
    Medidas de rendimiento de ejecución de programas.
  \end{itemize}
\end{enumerate}

\hypertarget{metodologuxeda-de-desarrollo}{%
\section{Metodología de Desarrollo}\label{metodologuxeda-de-desarrollo}}

Teniendo en cuenta los objetivos propuestos en la sección anterior, se pretende alcanzar los mismos a través de los pasos que se describen en esta sección.

\hypertarget{etapas-de-la-investigaciuxf3n}{%
\subsection{Etapas de la Investigación}\label{etapas-de-la-investigaciuxf3n}}

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\tightlist
\item
  Análisis bibliográfico.
  Se realizó una revisión continua de las publicaciones científicas y tecnológicas, libros e informes técnicos relacionados con el objeto de estudio.
\item
  Recopilación de simuladores.
  Se realizó un relevamiento del estado actual y las actualizaciones de los simuladores aplicados a la enseñanza de arquitectura de computadoras.
\item
  Estudio de los simuladores.
  En base a la documentación relevada de los simuladores se estudió en profundidad al menos 5 simuladores y se elaboró una comparativa de los simuladores seleccionados en cuanto a los contenidos que se imparten en la asignatura.
\item
  Construir el simulador.
  A través de métodos y técnicas de ingeniería de software se construyó un simulador de la arquitectura x86 donde abarque los aspectos más relevantes de la asignatura Arquitectura de Computadoras, permitiendo desarrollar los contenidos en una plataforma unificada, evitando así la pérdida de tiempo y dificultad que supone para el estudiante habituarse a diferentes entornos. Se utilizarán para ello técnicas formales de modelización y simulación, que facilitan un desarrollo modular y enfocan el esfuerzo en la definición del modelo de la arquitectura x86 más que en el protocolo de simulación, permitiendo además el escalado a entornos de ejecución paralelos o distribuidos sin necesidad de modificar el modelo de la arquitectura simulada.
\end{enumerate}

\hypertarget{organizaciuxf3n-del-documento}{%
\section{Organización del Documento}\label{organizaciuxf3n-del-documento}}

El resto de este documento se organiza de la siguiente manera: el capítulo 2 define formalmente las características y el set de instrucciones de la arquitectura. Luego, el capítulo 3 repasa y motiva el interesante rol que la simulación desde un punto de vista didáctico puede desempeñar para el dictado de la asignatura donde se abordan estos tópicos. El capítulo 4 comparativo de los simuladores estudiados según criterios preestablecidos. Finalmente, el capítulo 5 construcción de un simulador como soporte para el uso de la enseñanza y aprendizaje de arquitectura de computadora.

\hypertarget{estado-del-arte}{%
\chapter{Estado del arte}\label{estado-del-arte}}

En este capítulo se examina el estado del arte en la arquitectura de computadoras, enfocándose en la arquitectura x86 y el uso de herramientas de simulación en el ámbito educativo. Este análisis es clave para comprender el contexto y la relevancia de los temas abordados en esta tesis.

A continuación, se abordará el papel fundamental que desempeñan las herramientas de simulación en la enseñanza de la arquitectura de computadoras. Estas herramientas facilitan la comprensión de conceptos complejos y permiten a los estudiantes interactuar con sistemas simulados, proporcionando una experiencia práctica valiosa que de otro modo sería difícil de obtener. Se examinarán las herramientas de simulación más destacadas y su aplicación en entornos educativos, evaluando sus beneficios y limitaciones.

Finalmente, se explorarán las tendencias actuales y futuras en la enseñanza de la arquitectura de computadoras, destacando las innovaciones tecnológicas y metodológicas que están revolucionando las prácticas educativas en este campo. Se analizarán enfoques pedagógicos innovadores y estrategias de enseñanza que aprovechan las herramientas digitales y la simulación para mejorar la comprensión y el rendimiento de los estudiantes.

\hypertarget{arquitectura-de-computadoras}{%
\section{Arquitectura de computadoras}\label{arquitectura-de-computadoras}}

La arquitectura de computadoras se ocupa del estudio y diseño de los componentes de hardware y software de una computadora y su interacción. Este campo abarca desde el diseño de circuitos hasta la integración de sistemas completos, siendo crucial para el desarrollo de tecnologías eficientes y avanzadas. Estudiar arquitectura de computadoras permite comprender los sistemas informáticos desde su nivel más básico, ofreciendo una visión holística de su funcionamiento y estructura. Además, está estrechamente relacionada con la programación y el desarrollo de software, lo que permite optimizar el rendimiento y la eficiencia energética {[}\protect\hyperlink{ref-stallings_computer_2013}{14}{]}{[}\protect\hyperlink{ref-hennessy_computer_2012}{13}{]}.

La arquitectura de computadoras se ocupa del estudio y diseño de los componentes de hardware y software de una computadora y su interacción. Este campo abarca desde el diseño de circuitos hasta la integración de sistemas completos, siendo crucial para el desarrollo de tecnologías eficientes y avanzadas. Estudiar arquitectura de computadoras permite comprender los sistemas informáticos desde su nivel más básico, ofreciendo una visión holística de su funcionamiento y estructura. Además, está estrechamente relacionada con la programación y el desarrollo de software, lo que permite optimizar el rendimiento y la eficiencia energética. También brinda una base sólida para comprender y aprovechar nuevas tendencias tecnológicas, como la computación en la nube, la inteligencia artificial y el internet de las cosas, preparándonos para contribuir a la innovación tecnológica {[}\protect\hyperlink{ref-stallings_computer_2013}{14}{]}{[}\protect\hyperlink{ref-hennessy_computer_2012}{13}{]}.

En resumen, estudiar arquitectura de computadoras nos proporciona un conocimiento profundo de los sistemas informáticos, nos capacita para diseñar sistemas eficientes y escalables, y nos prepara para aprovechar las últimas tendencias tecnológicas. Es una disciplina esencial para aquellos que desean seguir una carrera en el campo de la informática y la tecnología, y contribuir al avance de la sociedad digital en la que vivimos.

Otro motivo relevante para estudiar arquitectura de computadoras es la capacidad de contribuir al desarrollo de nuevas tecnologías. La innovación en esta área ha sido constante, desde la miniaturización de componentes hasta el diseño de arquitecturas avanzadas como las basadas en computación cuántica. Al obtener conocimientos en arquitectura, podemos ser parte de esta evolución tecnológica y contribuir a la creación de sistemas más poderosos y eficientes.

Por último, el estudio de la arquitectura de computadoras nos proporciona una base sólida para comprender otros campos relacionados, como la seguridad informática y los sistemas embebidos. Estos conocimientos son cada vez más demandados en la industria, lo que abre oportunidades laborales en empresas de desarrollo de software, fabricantes de hardware, centros de investigación y muchas otras áreas relacionadas con la tecnología.

En conclusión, estudiar arquitectura de computadoras es fundamental para comprender el funcionamiento de los sistemas informáticos, resolver problemas de rendimiento y eficiencia, contribuir a la innovación tecnológica y acceder a una amplia gama de oportunidades laborales. Es una disciplina emocionante que impulsa la evolución de la tecnología y nos permite ser parte activa de este cambio.

\hypertarget{arquitectura-x86}{%
\subsection{Arquitectura x86}\label{arquitectura-x86}}

La arquitectura x86, una de las más influyentes y ampliamente utilizadas en el ámbito de las computadoras de escritorio y servidores, comenzó su desarrollo en 1978 con el lanzamiento del procesador Intel 8086, que introdujo una arquitectura de 16 bits. La arquitectura x86 evolucionó significativamente con el Intel 80386 en 1985, marcando el inicio de la era de 32 bits. En 2003, AMD lanzó la arquitectura AMD64, extendiendo x86 a 64 bits, lo que permitió un mayor acceso a la memoria y un mejor rendimiento en aplicaciones intensivas. Intel adoptó estas innovaciones, consolidando la arquitectura x86 como una de las más versátiles y potentes del mercado {[}\protect\hyperlink{ref-intel_64_2016}{15}{]}{[}\protect\hyperlink{ref-amd_developer_2019}{16}{]}{[}\protect\hyperlink{ref-abel_ibm_2000}{17}{]}.

\hypertarget{contextualizaciuxf3n-histuxf3rica-y-evoluciuxf3n-de-la-arquitectura-x86}{%
\subsubsection{Contextualización Histórica y Evolución de la Arquitectura x86}\label{contextualizaciuxf3n-histuxf3rica-y-evoluciuxf3n-de-la-arquitectura-x86}}

La retrocompatibilidad de la arquitectura x86 ha sido un factor determinante en su éxito, permitiendo que aplicaciones de 16, 32 y 64 bits se ejecuten en el mismo sistema. Esta característica ha asegurado la continuidad y protección de las inversiones en software y sistemas operativos desarrollados para x86.

\begin{longtable}[]{@{}lrrl@{}}
\caption{\label{tab:tabla-procesadores}Hitos procesadores x86}\tabularnewline
\toprule
Procesador & Año.de.Lanzamiento & Número.de.Bits & Nuevas.Características\tabularnewline
\midrule
\endfirsthead
\toprule
Procesador & Año.de.Lanzamiento & Número.de.Bits & Nuevas.Características\tabularnewline
\midrule
\endhead
Intel 8086 & 1978 & 16 & Arquitectura inicial\tabularnewline
Intel 80386 & 1985 & 32 & Memoria virtual\tabularnewline
AMD64 & 2003 & 64 & Extensiones de 64 bits\tabularnewline
\bottomrule
\end{longtable}

La evolución de la arquitectura x86 ha estado marcada por hitos importantes que han impulsado la informática hacia nuevas alturas. Tras el Intel 8086, el lanzamiento del Intel 80286 en 1982 introdujo modos de operación adicionales que mejoraron la eficiencia y el manejo de memoria. En 1989, el Intel 80486 incorporó una unidad de punto flotante integrada y una mejor caché, aumentando significativamente el rendimiento.

La serie Pentium, iniciada en 1993, llevó la arquitectura x86 a nuevos niveles de rendimiento y eficiencia, con características avanzadas como la ejecución superescalar y la predicción de saltos. El Pentium Pro en 1995 mejoró la arquitectura con ejecución fuera de orden y una caché L2 integrada.

En la década de 2000, la arquitectura x86 se adaptó a las demandas de la computación moderna con la introducción del Intel Core, optimizando el rendimiento y la eficiencia energética. AMD también fue crucial con su serie Athlon y la introducción de AMD64, llevando la arquitectura x86 a 64 bits, permitiendo un mayor acceso a la memoria y mejorando el rendimiento en aplicaciones intensivas.

La arquitectura x86 ha tenido un impacto profundo en el desarrollo de software. Los sistemas operativos populares como Windows y Linux están optimizados para x86, lo que ha influido en el desarrollo y la optimización de aplicaciones para esta arquitectura.
- Influencia en el Desarrollo de Software: Optimización del Rendimiento: Los desarrolladores de software han trabajado estrechamente con las características de la arquitectura x86 para optimizar el rendimiento de sus aplicaciones. Esto incluye el uso de instrucciones específicas de x86 y la optimización para cachés y pipelines.
- Compatibilidad y Soporte: La compatibilidad hacia atrás de x86 ha permitido la continuidad de aplicaciones y sistemas operativos, protegiendo las inversiones en software y facilitando las actualizaciones.
- Ecosistema de Desarrollo: Un amplio ecosistema de herramientas de desarrollo, bibliotecas y frameworks ha sido construido alrededor de la arquitectura x86, facilitando el desarrollo de aplicaciones de alto rendimiento y su depuración.

\begin{longtable}[]{@{}rll@{}}
\caption{\label{tab:tabla-evolucion-x86}Línea de Tiempo de la Evolución de la Arquitectura x86}\tabularnewline
\toprule
Año & Procesador & Innovación\_Principal\tabularnewline
\midrule
\endfirsthead
\toprule
Año & Procesador & Innovación\_Principal\tabularnewline
\midrule
\endhead
1978 & Intel 8086 & Introducción de la arquitectura x86, 16 bits\tabularnewline
1982 & Intel 80286 & Modos de operación adicionales\tabularnewline
1985 & Intel 80386 & Arquitectura de 32 bits, memoria virtual\tabularnewline
1989 & Intel 80486 & Unidad de punto flotante integrada, mejor caché\tabularnewline
1993 & Intel Pentium & Ejecución superescalar, predicción de saltos\tabularnewline
1995 & Intel Pentium Pro & Ejecución fuera de orden, caché L2 integrada\tabularnewline
2003 & AMD64 & Extensiones a 64 bits, mayor acceso a memoria\tabularnewline
2006 & Intel Core & Optimización de rendimiento y eficiencia energética\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{comparaciuxf3n-con-otras-arquitecturas}{%
\subsubsection{Comparación con Otras Arquitecturas}\label{comparaciuxf3n-con-otras-arquitecturas}}

La arquitectura x86 ha dominado el mercado de las computadoras de escritorio y servidores durante décadas, pero existen otras arquitecturas importantes que también han tenido un impacto significativo en la informática. Comparar x86 con arquitecturas como ARM {[}\protect\hyperlink{ref-patterson2016computer}{22}{]}, MIPS {[}\protect\hyperlink{ref-hennessy_computer_2012}{13}{]} y RISC-V {[}\protect\hyperlink{ref-waterman2014risc}{23}{]} nos permite entender mejor sus ventajas y desventajas.

\begin{longtable}[]{@{}lllll@{}}
\caption{\label{tab:tabla-comparacion-cpu}Comparación de Arquitecturas}\tabularnewline
\toprule
\begin{minipage}[b]{0.17\columnwidth}\raggedright
Característica\strut
\end{minipage} & \begin{minipage}[b]{0.18\columnwidth}\raggedright
x86\strut
\end{minipage} & \begin{minipage}[b]{0.16\columnwidth}\raggedright
ARM\strut
\end{minipage} & \begin{minipage}[b]{0.15\columnwidth}\raggedright
MIPS\strut
\end{minipage} & \begin{minipage}[b]{0.20\columnwidth}\raggedright
RISC.V\strut
\end{minipage}\tabularnewline
\midrule
\endfirsthead
\toprule
\begin{minipage}[b]{0.17\columnwidth}\raggedright
Característica\strut
\end{minipage} & \begin{minipage}[b]{0.18\columnwidth}\raggedright
x86\strut
\end{minipage} & \begin{minipage}[b]{0.16\columnwidth}\raggedright
ARM\strut
\end{minipage} & \begin{minipage}[b]{0.15\columnwidth}\raggedright
MIPS\strut
\end{minipage} & \begin{minipage}[b]{0.20\columnwidth}\raggedright
RISC.V\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.17\columnwidth}\raggedright
Eficiencia Energética\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
Moderada\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
Alta\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
Moderada\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
Alta\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright
Complejidad ISA\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
Alta\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
Baja\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
Moderada\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
Baja\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright
Rendimiento\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
Alto\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
Moderado\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
Moderado\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
Variable\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright
Compatibilidad\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
Alta (hacia atrás)\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
Moderada\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
Moderada\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
Alta\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright
Áreas de Aplicación\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
Escritorio, servidores\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
Dispositivos móviles\strut
\end{minipage} & \begin{minipage}[t]{0.15\columnwidth}\raggedright
Sistemas embebidos\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
Investigación, embebidos\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

La arquitectura ARM, conocida por su eficiencia energética, ha ganado popularidad en dispositivos móviles y sistemas embebidos. MIPS, aunque menos prominente en la actualidad, se ha utilizado en sistemas embebidos y en educación. RISC-V, una arquitectura abierta y libre, ha surgido como una alternativa flexible y eficiente, especialmente en investigación y aplicaciones embebidas {[}\protect\hyperlink{ref-patterson_computer_2017}{24}{]}.

\hypertarget{repertorio-de-instrucciones}{%
\subsection{Repertorio de instrucciones}\label{repertorio-de-instrucciones}}

El repertorio de instrucciones, conocido como ISA (Instruction Set Architecture), es fundamental para la interacción entre el software y el hardware de una computadora {[}\protect\hyperlink{ref-stallings_computer_2013}{14}{]}.

\hypertarget{filosofuxedas-cisc-y-risc}{%
\subsubsection{Filosofías CISC y RISC}\label{filosofuxedas-cisc-y-risc}}

La arquitectura x86 sigue la filosofía CISC (Complex Instruction Set Computer), la cual se caracteriza por tener un repertorio de instrucciones amplio y complejo. Esta filosofía busca reducir la cantidad de instrucciones por programa, a costa de aumentar la complejidad de cada instrucción individual. Esto contrasta con la filosofía RISC (Reduced Instruction Set Computer), que utiliza un repertorio de instrucciones más simple y optimiza el uso de registros y operaciones rápidas, aumentando el número de instrucciones necesarias por programa pero simplificando el diseño del hardware.

\hypertarget{instrucciones-x86}{%
\subsubsection{Instrucciones x86}\label{instrucciones-x86}}

El repertorio de instrucciones x86 incluye una variedad de instrucciones para realizar operaciones aritméticas, lógicas, de control y de manejo de memoria. Algunos ejemplos son:

\begin{itemize}
\tightlist
\item
  \texttt{MOV}: Mueve datos de una ubicación a otra.
\item
  \texttt{ADD}: Suma dos valores.
\item
  \texttt{SUB}: Resta un valor de otro.
\item
  \texttt{JMP}: Salta a una dirección específica.
\end{itemize}

Además de estas, existen muchas otras instrucciones que permiten manipular registros, gestionar interrupciones y ejecutar operaciones en punto flotante, entre otras. La versatilidad y profundidad del ISA x86 la han convertido en una de las arquitecturas más utilizadas y estudiadas en el campo de la informática.

\hypertarget{lenguaje-ensamblador}{%
\section{Lenguaje ensamblador}\label{lenguaje-ensamblador}}

Un procesador puede interpretar y ejecutar solo instrucciones máquina. Estas instrucciones son simplemente secuencias de números binarios almacenados en la computadora y son leídas por el procesador e interpretadas por él. Si un programador quisiera programar directamente en el lenguaje máquina, necesita introducir los programas como datos binarios. Esto requeriría escribir las sentencias que necesita realizar el procesador directamente en binarios, por lo tanto, conocer la secuencia de ceros y unos para cada operación escribiéndose ordenadamente, además de respetar la estructura de memoria y direccionamientos del procesador. Esto sin duda es un trabajo complejo, difícil, pesado y muy susceptible a errores. Adicionalmente, una vez que se requiera realizar modificaciones, su lectura implica ir traduciendo estas secuencias de ceros y unos a su correspondiente instrucción, lo que es doblemente dificultoso {[}\protect\hyperlink{ref-irvine2011assembly}{25}{]}.

Para facilitar la programación de bajo nivel, se creó el lenguaje ensamblador, que es un lenguaje de programación de bajo nivel que permite a los programadores escribir instrucciones comprensibles por el procesador. A diferencia del lenguaje máquina, que utiliza secuencias de números binarios, el ensamblador emplea mnemónicos simbólicos que hacen que el código sea más legible y manejable para los humanos. Cada arquitectura de procesador tiene su propio lenguaje ensamblador que usualmente es definida por el fabricante de hardware, por lo tanto es específica de cierta arquitectura de la computadora física. Un programa llamado ensamblador es usado para traducir sentencias del lenguaje ensamblador al código de máquina de la computadora. El ensamblador realiza una traducción casi directa uno a uno desde las sentencias mnemónicas a las instrucciones y datos de máquina. Esto está en contraste con los lenguajes de alto nivel, en los cuales una sola declaración generalmente da lugar a muchas instrucciones de máquina {[}\protect\hyperlink{ref-stallings_computer_2013}{14}{]}.

El código fuente generado en mnemotécnicos debe ser traducido a lenguaje máquina para poder ser ejecutado por la computadora. Este proceso lo realizan programas denominados ensambladores. Dentro del contexto de la arquitectura x86, existen diversos lenguajes ensambladores como TASM (Turbo Assembler) {[}\protect\hyperlink{ref-tasm}{26}{]}, MASM (Microsoft Macro Assembler) {[}\protect\hyperlink{ref-masm}{27}{]} y NASM (Netwide Assembler) {[}\protect\hyperlink{ref-nasm}{28}{]}, cada uno con características y beneficios únicos que se adaptan a distintas necesidades y preferencias de los programadores. Estos ensambladores convierten el código simbólico en código máquina, permitiendo su ejecución en el hardware específico de la arquitectura x86 {[}\protect\hyperlink{ref-hyde2010art}{29}{]}.

\hypertarget{simulaciuxf3n}{%
\section{Simulación}\label{simulaciuxf3n}}

La simulación es una herramienta esencial en diversos campos, incluyendo la medicina, el ámbito militar, el entretenimiento y la educación.Facilita la comprensión del funcionamiento de sistemas, la generación de hipótesis, la realización de análisis predictivos y la respuesta a preguntas del tipo ``¿qué pasaría si?''.

Según Banks {[}\protect\hyperlink{ref-banks_discrete-event_2010}{2}{]}, la simulación se define como el proceso de imitar el comportamiento de un sistema a lo largo del tiempo, lo cual requiere desarrollar primero un modelo conceptual que capture las características y comportamientos del sistema real. La simulación, entonces, representa la evolución de este modelo conforme el tiempo avanza {[}\protect\hyperlink{ref-banks_discrete-event_2010}{2}{]}{[}\protect\hyperlink{ref-robinson_simulation_2014}{4}{]}.

La capacidad de replicar y analizar sistemas complejos sin intervenir directamente en ellos convierte la simulación en una metodología indispensable para ingenieros, diseñadores y gerentes en el mundo digital actual. La simulación permite evaluar el rendimiento de sistemas, predecir su comportamiento en diferentes escenarios y optimizar su diseño antes de implementarlos en la realidad. Con los avances en el mundo digital, la simulación se ha convertido en una metodología indispensable para ingenieros, docentes, diseñadores y gerentes. La complejidad intrínseca de los sistemas informáticos los hace difíciles de comprender y costosos de desarrollar sin utilizar simulación. {[}\protect\hyperlink{ref-law_simulation_2015}{3}{]}.

\hypertarget{aplicaciones-de-la-simulaciuxf3n-en-la-industria}{%
\subsection{Aplicaciones de la Simulación en la Industria}\label{aplicaciones-de-la-simulaciuxf3n-en-la-industria}}

En la industria automotriz, la simulación es fundamental para el diseño y prueba de sistemas de seguridad, como airbags y frenos. Mediante un modelo virtual del automóvil y sus componentes, es posible realizar pruebas de colisión y evaluar el rendimiento de los sistemas de seguridad sin recurrir a costosas pruebas físicas. Además, la simulación permite optimizar el diseño de motores, analizar el flujo aerodinámico y prever el comportamiento de los materiales en condiciones extremas. En el campo de la aviación, la simulación se utiliza para entrenar pilotos en simuladores de vuelo que replican condiciones reales sin riesgos. También se emplea en el diseño de aeronaves para evaluar la aerodinámica y el rendimiento de nuevos diseños bajo diversas condiciones de vuelo. Estos ejemplos ilustran cómo la simulación puede reducir costos, mejorar la seguridad y acelerar el desarrollo de productos complejos.

\hypertarget{simulaciuxf3n-en-la-educaciuxf3n}{%
\subsection{Simulación en la Educación}\label{simulaciuxf3n-en-la-educaciuxf3n}}

En el ámbito educativo, la simulación es una herramienta poderosa para enseñar conceptos complejos y fomentar el aprendizaje activo. Los simuladores permiten a los estudiantes interactuar con sistemas virtuales y experimentar con escenarios realistas, facilitando la comprensión de conceptos abstractos y la aplicación de conocimientos teóricos en situaciones prácticas.

En la enseñanza de la arquitectura de computadoras, los simuladores son especialmente útiles para ilustrar el funcionamiento interno de los procesadores, la ejecución de instrucciones y el manejo de la memoria. Los estudiantes pueden experimentar con diferentes configuraciones y parámetros, observar el impacto en el rendimiento y comprender cómo se aplican los conceptos teóricos en la práctica. La simulación también permite a los estudiantes explorar escenarios hipotéticos y evaluar el comportamiento de sistemas complejos sin necesidad de hardware físico. En resumen, la simulación en la educación es una herramienta valiosa para mejorar la comprensión de los estudiantes, fomentar la experimentación y promover el aprendizaje activo {[}\protect\hyperlink{ref-skrien_cpu_2001}{18}{]}{[}\protect\hyperlink{ref-garcia-garcia_pbbcache_2020}{7}{]}{[}\protect\hyperlink{ref-nova_tool_2013}{8}{]}.

Para superar estas limitaciones, se han desarrollado numerosos simuladores que ofrecen experiencias de aprendizaje valiosas al replicar el funcionamiento y la estructura de las computadoras. Simuladores como SimpleScalar, SPIM y GEM5 permiten a los estudiantes experimentar con arquitecturas complejas y técnicas avanzadas como el pipelining y la ejecución fuera de orden. Estas herramientas facilitan la comprensión de los conceptos teóricos a través de la interacción práctica, proporcionando un entorno seguro y accesible para la exploración y el aprendizaje {[}\protect\hyperlink{ref-skrien_cpu_2001}{18}{]}.

Utilizando simuladores como SimpleScalar, los estudiantes pueden visualizar cómo las instrucciones se ejecutan en diferentes etapas del pipeline, y cómo se manejan las dependencias de datos y los riesgos de control. El pipelining es una técnica utilizada en las CPUs modernas para mejorar el rendimiento. Al simular el pipelining, los estudiantes pueden comprender cómo se dividen las instrucciones en etapas y cómo se gestionan los conflictos para evitar cuellos de botella. Además, los simuladores permiten a los estudiantes experimentar con diferentes configuraciones y parámetros para evaluar su impacto en el rendimiento y la eficiencia de la CPU.

\hypertarget{aporte-pedaguxf3gico}{%
\subsubsection{Aporte pedagógico}\label{aporte-pedaguxf3gico}}

En el ámbito educativo, transmitir los fundamentos teóricos de la organización y arquitectura interna de las computadoras puede ser un desafío debido a la complejidad de los procesos involucrados. Los métodos tradicionales de enseñanza, como el uso de pizarras, libros de texto y diapositivas, a menudo tienen una capacidad limitada para representar estos conceptos de manera efectiva. Esto requiere que los estudiantes tengan un alto nivel de abstracción para desarrollar un modelo mental adecuado para capturar la organización y arquitectura interna de las computadoras {[}\protect\hyperlink{ref-lion_simuladores_2005}{5}{]}{[}\protect\hyperlink{ref-contreras_uso_2010}{6}{]}.

La integración de nuevas tecnologías como recurso didáctico es crucial para facilitar el aprendizaje. Las herramientas de simulación permiten a los estudiantes relacionar conceptos abstractos con situaciones reales, situándose en un contexto que imita aspectos de la realidad. Este enfoque pedagógico facilita la detección de problemáticas y el desarrollo de habilidades a través del trabajo exploratorio, la inferencia y el aprendizaje por descubrimiento. Simuladores como Simulink, Proteus y Logisim juegan un papel esencial en la enseñanza de la arquitectura de computadoras, proporcionando una representación visual e interactiva que enriquece la comprensión teórica y práctica de los estudiantes {[}\protect\hyperlink{ref-garcia-garcia_pbbcache_2020}{7}{]}{[}\protect\hyperlink{ref-nova_tool_2013}{8}{]}.

El uso de herramientas de simulación en la enseñanza para procesos dinámicos complejos, como las operaciones intrínsecas de la computadora, que permiten representar de forma visual e interactiva la organización y arquitectura interna de la computadora, facilitando así la comprensión de su funcionamiento por parte de los alumnos y el desarrollo de los temas por parte del docente. En este contexto, los simuladores juegan una pieza clave en el campo de la Arquitectura de Computadoras, permitiendo conectar fundamentos teóricos con la experiencia práctica, implicando abstracciones y haciendo más rica la labor docente.

\hypertarget{el-formalismo-devs-discrete-event-system-specification}{%
\subsection{El Formalismo DEVS (Discrete Event System Specification)}\label{el-formalismo-devs-discrete-event-system-specification}}

DEVS, la abreviación de Discrete Event System Specification, es un formalismo modular y jerárquico para el modelado y análisis de sistemas que pueden ser representados como sistemas de eventos discretos, sistemas de estado continuo o sistemas híbridos. Este formalismo, desarrollado por Bernard P. Zeigler en los años 70, extiende el concepto de las máquinas de Moore al proporcionar una estructura para modelar sistemas complejos mediante la utilización de eventos cronometrados {[}\protect\hyperlink{ref-zeigler_theory_2000}{20}{]}.

\hypertarget{descripciuxf3n-del-formalismo-devs}{%
\subsubsection{Descripción del Formalismo DEVS}\label{descripciuxf3n-del-formalismo-devs}}

El formalismo DEVS define el comportamiento de un sistema real utilizando eventos de entrada y salida, y transiciones entre estados concretos. Un sistema en DEVS está compuesto por modelos atómicos y acoplados. Los modelos atómicos representan las unidades básicas de comportamiento, mientras que los modelos acoplados consisten en combinaciones de modelos atómicos y/o otros modelos acoplados. Esta estructura jerárquica facilita la gestión y análisis de sistemas complejos, permitiendo la prueba de subsistemas de manera aislada antes de integrarlos en el sistema completo.
Bajo un punto de vista general, un modelo DEVS está caracterizado por generar eventos de salida Y , en relación con el estado en el que se encuentre S y las entradas recibidas X, cada cierto tiempo.

\hypertarget{aplicaciones-del-formalismo-devs}{%
\subsubsection{Aplicaciones del Formalismo DEVS}\label{aplicaciones-del-formalismo-devs}}

El formalismo DEVS es aplicable a una amplia gama de sistemas, desde redes de comunicación hasta procesos de manufactura. Por ejemplo, en una red de comunicación, un modelo DEVS puede simular el enrutamiento de paquetes de datos y la gestión de congestiones. En la manufactura, un modelo DEVS puede representar el flujo de materiales y el control de calidad en una línea de producción, ayudando a identificar cuellos de botella y optimizar procesos.

\hypertarget{ejemplo-de-modelo-devs}{%
\subsubsection{Ejemplo de Modelo DEVS}\label{ejemplo-de-modelo-devs}}

Consideremos un sistema de colas en un banco, donde los clientes llegan, esperan en la fila y son atendidos por cajeros. Un modelo DEVS puede representar los eventos de llegada de clientes, la asignación a los cajeros y el tiempo de servicio, permitiendo evaluar el tiempo de espera y la utilización de los recursos. Este ejemplo ilustra cómo DEVS puede ser utilizado para mejorar la eficiencia operativa y la satisfacción del cliente mediante la optimización del flujo de trabajo y la asignación de recursos.

\hypertarget{comparativa-de-simuladores}{%
\chapter{Comparativa de simuladores}\label{comparativa-de-simuladores}}

En este capítulo, se analizan y comparan varios simuladores x86 que podrían integrarse en la asignatura Arquitectura de Computadoras de la Licenciatura en Sistemas.

La selección y evaluación de estos simuladores se ha basado en criterios específicos diseñados para medir su efectividad en un entorno educativo, con el objetivo de identificar las herramientas que mejor apoyen el proceso de enseñanza y aprendizaje. Los criterios de evaluación incluyen aspectos como usabilidad, editor de código, documentación, ejecución de simulación, nivel de especificación de la arquitectura x86, características del producto y cobertura de los contenidos curriculares.

Los resultados de esta comparativa se publicaron en el XVII Congreso de Tecnología en Educación y Educación en Tecnología en 2022, bajo el título `Herramientas de software para dar soporte en la enseñanza y aprendizaje de la arquitectura x86' {[}\protect\hyperlink{ref-colombani_herramientas_2022}{30}{]}.

\hypertarget{estudios-similares}{%
\section{Estudios similares}\label{estudios-similares}}

Cabe destacar que existen antecedentes de estudios comparativos que evalúan diferentes simuladores aplicados a la enseñanza de los cursos de arquitectura de computadoras:
- ``A survey and evaluation of simulators suitable for teaching courses in computer architecture and organization'', 2009 {[}\protect\hyperlink{ref-nikolic_survey_2009}{11}{]}: Otros estudios evalúan diferentes simuladores para abordar diferentes temas en el dictado de los cursos de Arquitectura de Computadoras, en general estos estudios evalúan simuladores en términos de dos categorías predefinidas: una referida a las características de la simulación, como ser granularidad, usabilidad, disponibilidad, presentación visual, flujo de simulación, etc., y otra sobre la cobertura de los contenidos preestablecidos en las currículas.
- ``Survey and evaluation of simulators suitable for teaching for computer architecture and organization Supporting undergraduate students at Sir Syed University of Engineering \& Technology'', 2012 {[}\protect\hyperlink{ref-hasan_survey_2012}{12}{]}: Evalúa aspectos como usabilidad, disponibilidad, fundamentos de arquitectura informática, jerarquía de sistemas de memoria, comunicación e interfaz y diseño de sistemas de procesadores.

Este trabajo se diferencia al proponer un enfoque diferente: evaluar los simuladores x86 bajo criterios de evaluación basados en características de simulación y en contenidos específicos de la asignatura Arquitectura de Computadoras de la carrera de Licenciatura en Sistemas de la Universidad Nacional de Entre Ríos

\hypertarget{simuladores-bajo-anuxe1lisis}{%
\section{Simuladores bajo análisis}\label{simuladores-bajo-anuxe1lisis}}

Un simulador de arquitectura es un software que imita una situación del mundo real y, en este contexto, puede imitar el hardware de un sistema de cómputo. Estos simuladores se enfocan principalmente en representar los aspectos arquitectónicos y funcionales del hardware. El uso de simuladores permite realizar cambios, pruebas y ejecución de programas sin temor a dañar ningún componente o por falta de la computadora. {[}\protect\hyperlink{ref-radivojevic_design_2011}{10}{]}.

Algunos programas ofrecen una representación visual e interactiva de la organización y arquitectura interna de la computadora, facilitando así la comprensión de su funcionamiento. Entre estos se encuentran los simuladores Assembly debugger (x86), Simple 8-bit Assembler Simulator, Microprocessor Simulator, Simulador de ensamblador de 16 bits y Emu8086. En este sentido, los simuladores juegan un papel clave en el campo de la Arquitectura de Computadoras, permitiendo conectar fundamentos teóricos con la experiencia práctica, simplificando abstracciones y facilitando la labor docente {[}\protect\hyperlink{ref-nikolic_survey_2009}{11}{]}{[}\protect\hyperlink{ref-hasan_survey_2012}{12}{]}{[}\protect\hyperlink{ref-hennessy_computer_2012}{13}{]}{[}\protect\hyperlink{ref-stallings_computer_2013}{14}{]}{[}\protect\hyperlink{ref-behrooz_computer_2005}{31}{]}.

\hypertarget{criterios-de-evaluaciuxf3n}{%
\section{Criterios de evaluación}\label{criterios-de-evaluaciuxf3n}}

Los criterios de evaluación se han definido cuidadosamente para asegurar una valoración integral de los simuladores. Estos criterios incluyen:

\begin{itemize}
\tightlist
\item
  \textbf{Usabilidad}: Se refiere a la capacidad ser usado del producto.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Indicadores}:

    \begin{itemize}
    \tightlist
    \item
      Facilidad de aprendizaje: tiempo requerido para familiarizarse con la herramienta.
    \item
      Interfaz de usuario: claridad y organización.
    \item
      Documentación y ayuda: disponibilidad y accesibilidad de tutoriales y guías.
    \end{itemize}
  \item
    \textbf{Escala}: difícil-media-fácil.
  \end{itemize}
\item
  \textbf{Editor}: Funcionalidades que ofrece el editor para escribir y depuración de código en lenguaje ensamblador.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Indicadores}:

    \begin{itemize}
    \tightlist
    \item
      Capacidad de edición: funcionalidades como resaltado de sintaxis, puntos de interrupción (breakpoints).
    \item
      Errores de sintaxis: detección y aviso de errores.
    \item
      Almacenamiento: opciones para guardar y cargar programas.
    \end{itemize}
  \item
    \textbf{Escala}: baja-media-alta.
  \end{itemize}
\item
  \textbf{Documentación}: Disponibilidad de la documentacion para dar soporte al aprendizaje.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Indicadores}:

    \begin{itemize}
    \tightlist
    \item
      Manual de usuario: disponibilidad y calidad.
    \item
      Tutoriales: existencia y utilidad de tutoriales de aprendizaje.
    \item
      Repertorio de instrucciones: exhaustividad y claridad en la explicación de instrucciones.
    \end{itemize}
  \item
    \textbf{Escala}: mínima-media-completa.
  \end{itemize}
\item
  \textbf{Ejecución de simulación}: Facilidad para controlar y observar el flujo de ejecución de sus programas.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Indicadores}:

    \begin{itemize}
    \tightlist
    \item
      Control de la simulación: opciones para pausar, reanudar, y retroceder la ejecución.
    \item
      Visualización: claridad en la representación del flujo de ejecución.
    \item
      Configurabilidad: opciones para ajustar la velocidad del reloj de la CPU y otros parámetros.
    \end{itemize}
  \item
    \textbf{Escala}: baja-media-alta.
  \end{itemize}
\item
  \textbf{Nivel de especificación de la Organización y Arquitectura del sistema simulado}: Precisión con la que el simulador representa la arquitectura x86. Nivel de implementación del set de instrucciones, memoria, módulos de E/S, etc.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Indicadores}:

    \begin{itemize}
    \tightlist
    \item
      Precisión de la arquitectura: fidelidad en la representación de la arquitectura x86.
    \item
      Implementación del set de instrucciones: completitud y exactitud.
    \item
      Soporte de módulos: inclusión y funcionalidad de memoria, módulos de E/S, etc.
    \end{itemize}
  \item
    \textbf{Escala}: mínima-media-completa.
  \end{itemize}
\item
  \textbf{Características del desarrollo del producto software}: se basa en las características propias del producto software.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Indicadores}:

    \begin{itemize}
    \tightlist
    \item
      Tipo de licencia: open source o privativa.
    \item
      Actualizaciones: frecuencia y fecha de la última versión.
    \item
      Plataforma: si es una aplicación web o de escritorio.
    \end{itemize}
  \item
    \textbf{Escala}: mala-buena-muy buena.
  \end{itemize}
\item
  \textbf{Cobertura de los contenidos preestablecidos en la currícula}: Cobertura de los tópicos de la asignatura Arquitectura de Computadoras.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Indicadores}:

    \begin{itemize}
    \tightlist
    \item
      Correspondencia con el currículum: alineación con los tópicos de la asignatura Arquitectura de Computadoras.
    \item
      Profundidad de los temas: nivel de detalle en la cobertura de los contenidos curriculares.
    \end{itemize}
  \item
    \textbf{Escala}: baja-media-alta.
  \end{itemize}
\end{itemize}

\hypertarget{selecciuxf3n-de-simuladores}{%
\section{Selección de simuladores}\label{selecciuxf3n-de-simuladores}}

A partir de una exhaustiva exploración en internet sobre herramientas de simulación de la arquitectura x86 utilizadas para la enseñanza, se identificaron los siguientes simuladores: Assembly debugger (x86), Simple 8-bit Assembler Simulator, Microprocessor Simulator, Simulador de ensamblador de 16 bits, Emu8086, VonSim, Orga1 y Qsim.

La selección se basa en una evaluación preliminar que considera se seleccionaron tres considerando el tiempo de evaluación de cada uno y la cantidad de criterios cumplidos por cada simulador, buscando aquellos que ofrecen un balance adecuado entre funcionalidad, usabilidad, documentación y alineación con los contenidos curriculares de la asignatura Arquitectura de Computadoras. De estos simuladores, se seleccionaron tres que, a priori, contemplaban la mayor cantidad de criterios a evaluar: Emu8086, VonSim y Simple 8-bit Assembler Simulator.

\hypertarget{participantes-en-la-evaluaciuxf3n}{%
\section{Participantes en la evaluación}\label{participantes-en-la-evaluaciuxf3n}}

La evaluación de los simuladores aplicando los criterios preestablecidos fue llevada a cabo por 3 docentes de la asignatura arquitectura de computadoras {[}Marcelo A. Colombani, José M. Ruiz, Amalia G. Delduca{]}, quienes aportaron su experiencia en el uso de simuladores y su aplicabilidad en la enseñanza de arquitectura de computadoras. Además, se contó con la colaboración de 1 asesor externo {[}Marcelo A. Falappa{]}, quienes ofrecieron una visión externa y validaron el proceso de evaluación y los resultados obtenidos.

\hypertarget{anuxe1lisis-comparativo}{%
\section{Análisis comparativo}\label{anuxe1lisis-comparativo}}

A continuación, se presenta un análisis detallado de los simuladores seleccionados basado en los criterios de evaluación definidos:

\hypertarget{simple-8-bit-assembler-simulator}{%
\subsection{Simple 8-bit Assembler Simulator}\label{simple-8-bit-assembler-simulator}}

\begin{itemize}
\tightlist
\item
  \textbf{Usabilidad}: Nivel medio. Presenta todos los componentes en una sola pantalla, lo cual puede ser abrumador para usuarios principiantes.
\item
  \textbf{Editor}: Nivel bajo. Incluye aviso de errores de sintaxis al ensamblar, sin resaltado de sintaxis ni breakpoints. No permite guardar o cargar programas.
\item
  \textbf{Documentación}: Nivel mínimo. Consta solo de un manual de instrucciones implementadas.
\item
  \textbf{Ejecución de simulación}: Nivel medio. Permite configurar la velocidad del reloj de CPU y ofrece controles básicos de simulación.
\item
  \textbf{Nivel de especificación}: Nivel mínimo. Simplifica la arquitectura x86 en un CPU de 8 bits, con memoria de 256 bytes y sin soporte para IN y OUT.
\item
  \textbf{Desarrollo del producto}: Nivel bueno. Licencia MIT, última versión en 2015, desarrollado sobre plataforma web.
\item
  \textbf{Cobertura de contenidos}: Nivel bajo. No implementa memoria independiente para módulos de entrada y salida, rutinas de tratamiento de interrupciones ni ciclo de instrucción.
\end{itemize}

\hypertarget{vonsim}{%
\subsection{VonSim}\label{vonsim}}

\begin{itemize}
\tightlist
\item
  \textbf{Usabilidad}: Nivel medio. Presenta componentes mediante solapas, lo cual puede ser abrumador para usuarios iniciales.
\item
  \textbf{Editor}: Nivel medio. Incluye aviso de errores de sintaxis, resaltado de sintaxis y breakpoints mediante interrupción por software.
\item
  \textbf{Documentación}: Nivel medio. Posee manual de uso y tutorial interactivo.
\item
  \textbf{Ejecución de simulación}: Nivel medio. Permite configurar la velocidad del reloj de CPU y ofrece controles básicos de simulación.
\item
  \textbf{Nivel de especificación}: Nivel medio. Representa una simplificación del procesador 8088 con arquitectura de 16 bits y memoria direccionable de 16 KiB.
\item
  \textbf{Desarrollo del producto}: Nivel muy bueno. Licencia GNU Affero General Public License v3.0, última versión en 2020, desarrollado sobre plataforma web con extensa evidencia de uso académico.
\item
  \textbf{Cobertura de contenidos}: Nivel medio. Implementa dispositivos internos y externos, pero no desarrolla contenidos visuales para ciclo de instrucción y medidas de rendimiento.
\end{itemize}

\hypertarget{emu8086}{%
\subsection{Emu8086}\label{emu8086}}

\begin{itemize}
\tightlist
\item
  \textbf{Usabilidad}: Nivel fácil. Presenta inicialmente el editor y permite activar componentes del simulador a medida que se cargan programas.
\item
  \textbf{Editor}: Nivel alto. Incluye aviso de errores de sintaxis, resaltado de sintaxis y opciones de breakpoints. Permite guardar y cargar programas.
\item
  \textbf{Documentación}: Nivel completo. Incluye manual de instrucciones, tutorial de aprendizaje y manual de uso.
\item
  \textbf{Ejecución de simulación}: Nivel alto. Permite configurar la velocidad del reloj de CPU y ofrece controles avanzados de simulación, incluyendo ``step back''.
\item
  \textbf{Nivel de especificación}: Nivel completo. Representa detalladamente la arquitectura del procesador 8086 con memoria direccionable de 1 MiB y soporte para interrupciones por software y hardware.
\item
  \textbf{Desarrollo del producto}: Nivel bueno. Licencia privativa, última versión en 2023, desarrollado sobre plataforma de escritorio.
\item
  \textbf{Cobertura de contenidos}: Nivel alto. Soporta todos los modos de direccionamiento y permite emular el booteo de una IBM PC desde el floppy disk, entre otros.
\end{itemize}

\begin{longtable}[]{@{}llll@{}}
\caption{\label{tab:tabla-comparativa-criterios}Comparativa según criterios de evaluación preestablecidos}\tabularnewline
\toprule
Criterio.de.Evaluacion & Simple.8.bit.Assembler.Simulator & VonSim & Emu8086\tabularnewline
\midrule
\endfirsthead
\toprule
Criterio.de.Evaluacion & Simple.8.bit.Assembler.Simulator & VonSim & Emu8086\tabularnewline
\midrule
\endhead
Usabilidad & Medio & Medio & Fácil\tabularnewline
Editor & Bajo & Medio & Alto\tabularnewline
Documentación & Mínima & Media & Completa\tabularnewline
Ejecución de simulación & Medio & Medio & Alta\tabularnewline
Nivel de especificación x86 & Mínima & Media & Completa\tabularnewline
Características del producto & Buena & Muy buena & Buena\tabularnewline
Cobertura de contenidos & Baja & Media & Alta\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{resultados}{%
\section{Resultados}\label{resultados}}

La asignatura promueve el uso de simuladores para apoyar la enseñanza y el aprendizaje, permitiendo aplicar los contenidos desarrollados en máquinas reales. Emu8086 es la herramienta más adecuada para esta finalidad, ya que facilita la implementación de programas en hardware real. Sin embargo, su dependencia de MS-DOS complica su ejecución en sistemas operativos actuales, requiriendo el uso de emuladores de MS-DOS, lo que añade complejidad al proceso de enseñanza y aprendizaje.

Desde 2018, la asignatura utiliza la versión 4.08 de Emu8086. La herramienta tiene un periodo de evaluación gratuito de 14 días, después del cual se debe adquirir una licencia. Esto es un inconveniente, ya que se busca que los estudiantes puedan acceder a las herramientas de forma libre y gratuita.

Utilizar lenguaje NASM (Netwide Assembler) garantiza soporte tanto para Linux como Windows a través de herramientas libres como GCC (GNU Compiler Collection), generando programas para la arquitectura x86 de 16, 32 y 64 bits.

Emu8086 destaca por su interfaz dinámica, que muestra componentes como la pila, flags, teclado y pantalla solo cuando son necesarios, a diferencia de otros simuladores que presentan todos sus componentes desde el inicio.

En el criterio de evaluación dos, Emu8086 se destaca por su editor, que incluye puntos de ruptura para detener la ejecución del programa en un punto específico y retroceder a la intruccion anterior. Además, permite guardar y recuperar programas directamente desde el editor.

En el criterio de evaluación tres, Emu8086 se destaca por ofrecer tres tipos de documentación: un repertorio de instrucciones con ejemplos para cada tipo de instrucción, un manual que explica las partes de la herramienta y un tutorial para aprender a programar en ensamblador.

En el criterio de evaluación cuatro, Emu8086 se destaca por ofrecer una mayor cantidad de controladores para gestionar el flujo de ejecución, como la capacidad de retroceder la ejecución de una instrucción y recargar el programa actual.

En el criterio de evaluación cinco el emu8086 se destaca del resto debido a que ofrece una mayor especificidad de la arquitectura x86, además implementa interrupciones del sistema operativo MS-DOS, a través del cual se pueden ejecutar los programas en una máquina real.

En el criterio de evaluación seis VonSim se destaca del resto debido a que es licencia libre y posee una comunidad que respalda el proyecto.

En cuanto al último criterio, ninguna de las herramientas evaluadas cubre todos los contenidos que se pretende desarrollar con la ayuda de una herramienta, quedando excluido pasos del ciclo de instrucción y medidas de rendimientos (tiempo de CPU y CPI: ciclo por instrucción).

En resumen:
- Emu8086 se destaca por su alta usabilidad, documentación completa, y precisión en la simulación de la arquitectura para la enseñanza de la arquitectura x86. Sin embargo, su licencia privativa y dependencia de MS-DOS representan desafíos importantes.
- VonSim ofrece una buena solución con licencia libre y una interfaz más amigable, pero su nivel de especificación y cobertura de contenidos es medio, lo cual podría limitar su efectividad en el curso.
- Simple 8-bit Assembler Simulator tiene limitaciones significativas en usabilidad, documentación, y especificación, lo que lo hace menos adecuado para una enseñanza completa de la arquitectura x86.

Del análisis realizado, se concluye que, aunque todos los simuladores evaluados presentan ventajas y desventajas, ninguno de los simuladores analizados parece adecuado para la asignatura sugiere que los simuladores actuales no cumplen completamente con los requisitos de complejidad y cobertura necesarios para la enseñanza exhaustiva de la arquitectura x86. Se recomienda usar Emu8086 mientras se desarrolla un simulador que combine sus mejores características con una licencia libre, con soporte para sistemas operativos modernos y una mayor cobertura de contenidos curriculares para la asignatura..

\hypertarget{publicaciuxf3n}{%
\subsection{Publicación}\label{publicaciuxf3n}}

El resultado de esta comparativa fue publicado en el XVII Congreso de Tecnología en educación y Educación en Tecnología año 2022 bajo el título de ``Herramientas de software para dar soporte en la enseñanza y aprendizaje de la arquitectura x86'' {[}\protect\hyperlink{ref-colombani_herramientas_2022}{30}{]}.

Durante la elaboración de este análisis comparativo establecí contacto con uno de los docentes de la Universidad Nacional de la Plata (UNLP) que habían desarrollado un simulador web VonSim, con el acuerdo de docente se generó una solicitud de incorporación de cambios (pull request) en el repositorio de Github del simulador VonSim y en agosto-2023 salió una nueva versión donde se implementan animaciones de la ejecución de instrucciones y documentación on-line.

\hypertarget{diseuxf1o-y-construcciuxf3n-del-simulador}{%
\chapter{Diseño y construcción del simulador}\label{diseuxf1o-y-construcciuxf3n-del-simulador}}

El objetivo principal de esta tesis es construir una herramienta de simulación de la arquitectura x86 para apoyar la enseñanza de arquitectura de computadoras. Para lograr este objetivo, se plantean los siguientes objetivos específicos:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Estudiar y evaluar diferentes herramientas actuales de simulación destinadas a dar apoyo a la enseñanza de la arquitectura x86.

  Se cumplió el primer objetivo mediante una revisión exhaustiva de las herramientas de simulación actuales destinadas a apoyar la enseñanza de la arquitectura x86.
\item
  Construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras, para ello debe cumplir:

  \begin{itemize}
  \tightlist
  \item
    Una visión global de la estructura y funcionamiento de la computadora.
  \item
    Generación y ejecución de programas en ensamblador.
  \item
    Repertorio de instrucciones x86 reducido y habilitado progresivamente.
  \item
    Simulación visual e interactiva de micropasos de instrucciones.
  \item
    Gestión de interrupciones y comunicación con periféricos.
  \item
    Medidas de rendimiento de ejecución de programas.
  \end{itemize}
\end{enumerate}

Para cumplir con el segundo objetivo, se diseñó y construyó una herramienta de apoyo que cumple con los requisitos previamente mencionados para impartir los contenidos de la asignatura Arquitectura de Computadoras.

Construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras, para ello debe cumplir, se puede adpatar

Para lograr esto, se comenzamos por definir los requisitos de la herramienta.

\hypertarget{requisitos-de-la-herramienta}{%
\section{Requisitos de la herramienta}\label{requisitos-de-la-herramienta}}

Para cumplir con el segundo objetivo específico, la herramienta debe cumplir con los siguientes requisitos:

\begin{itemize}
\item
  \textbf{Visión global de la computadora:} Debe mostrar la estructura completa de la computadora (CPU, bus, memoria y E/S) durante la ejecución de programas, destacando componentes relevantes.
\item
  \textbf{Generación y ejecución de programas en ensamblador:} Permitir tanto la ejecución paso a paso como completa, facilitando la comprensión de cada instrucción.
\item
  \textbf{Repertorio de instrucciones x86 reducido:} Seleccionar un subconjunto esencial de instrucciones x86, habilitándolas progresivamente según avance el contenido de la asignatura.
\item
  \textbf{Simulación visual e interactiva de micropasos:} Utilizar el lenguaje de transferencia entre registros (RTL) para describir el flujo de datos, facilitando la comprensión del ciclo básico de una instrucción. Correr un programa y que se ilumine cada componente durante la ejecución de un programa.
\item
  \textbf{Gestión de interrupciones:} Incorporar un vector de interrupción predefinido para interactuar con el teclado y monitor.
\item
  \textbf{Comunicación con módulos de E/S y periféricos:} Incluir instrucciones IN y OUT, y un módulo de E/S simplificado basado en el modo 2 del Intel 8255.
\item
  \textbf{Medidas de rendimiento:} Proveer información sobre tiempo de ciclo, tiempo de CPU y CPI de un programa.
\end{itemize}

La herramienta debe ofrecer una visión global de la estructura y funcionamiento de la computadora, permitir la generación y ejecución de programas escritos en lenguaje ensamblador, ya sea paso a paso por instrucción o completa, y ofrecer un repertorio de instrucciones x86 reducido donde se habiliten las instrucciones a medida que se desarrolle el contenido en la asignatura.

Además, la herramienta debe simular de manera visual e interactiva los micropasos que conlleva el ciclo básico de una instrucción, permitir la gestión básica de interrupciones permitiendo la interacción con el teclado y la pantalla, permitir la comunicación con los módulos de entrada y salida e interacciones con los periféricos, y ofrecer medidas de rendimiento sobre la ejecución de un programa.

\textbf{Definición de Requisitos:}
- Visión global de la estructura y funcionamiento de la computadora.
- Generación y ejecución de programas en ensamblador.
- Repertorio de instrucciones x86 reducido y habilitado progresivamente.
- Simulación visual e interactiva de micropasos.
- Gestión de interrupciones y comunicación con periféricos.
- Medidas de rendimiento de ejecución de programas.

\textbf{Diseño de la Herramienta:}
- Considerar la facilidad de uso para estudiantes y profesores.
- Utilizar gráficos y diagramas para mejorar la comprensión.

\textbf{Construcción de la Herramienta:}
- Implementar la herramienta siguiendo las especificaciones de diseño.
- Realizar pruebas exhaustivas para asegurar que la herramienta cumple con todos los requisitos.
- Solucionar cualquier problema identificado durante las pruebas antes del lanzamiento.

Para cumplir con el segundo objetivo específico, es esencial diseñar y construir una herramienta de apoyo que sea fácil de usar para estudiantes y profesores, cumpliendo con los requisitos definidos, y realizar pruebas rigurosas para asegurar su funcionalidad y usabilidad.

La herramienta debe ofrecer una visión global de la estructura y funcionamiento de la computadora, permitir la generación y ejecución de programas escritos en lenguaje ensamblador, ya sea paso a paso por instrucción o completa, y ofrecer un repertorio de instrucciones x86 reducido donde se habiliten las instrucciones a medida que se desarrolle el contenido en la asignatura. Además, la herramienta debe simular de manera visual e interactiva los micropasos que conlleva el ciclo básico de una instrucción, permitir la gestión básica de interrupciones permitiendo la interacción con el teclado y la pantalla, permitir la comunicación con los módulos de entrada y salida e interacciones con los periféricos, y ofrecer medidas de rendimiento sobre la ejecución de un programa.

Una vez que se hayan definido los requisitos, se puede comenzar a diseñar la herramienta. Se debe tener en cuenta la facilidad de uso para los estudiantes y profesores. La herramienta debe ser intuitiva y fácil de navegar. Se pueden utilizar gráficos y diagramas para ayudar a los estudiantes a comprender mejor la estructura y funcionamiento de la computadora.

Después de diseñar la herramienta, se debe construir y probar. Se deben realizar pruebas exhaustivas para asegurarse de que la herramienta cumpla con todos los requisitos y sea fácil de usar. Si se encuentran problemas durante las pruebas, se deben solucionar antes de lanzar la herramienta.

En resumen, para cumplir con el segundo objetivo específico, se debe diseñar y construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras. La herramienta debe cumplir con los requisitos mencionados anteriormente y debe ser fácil de usar para los estudiantes y profesores. Para lograr esto, se puede comenzar por definir los requisitos de la herramienta, diseñar la herramienta, construir y probar.

\hypertarget{desarrollo-y-pruebas}{%
\section{Desarrollo y Pruebas}\label{desarrollo-y-pruebas}}

\begin{itemize}
\item
  \textbf{Diseño de la Herramienta:} Comenzar con la definición detallada de los requisitos, seguido de un diseño centrado en la facilidad de uso para estudiantes y profesores. Se utilizarán gráficos y diagramas para mejorar la comprensión.
\item
  \textbf{Construcción de la Herramienta:} Implementar la herramienta siguiendo las especificaciones de diseño, asegurando la integridad y funcionalidad de cada componente.
\item
  \textbf{Pruebas Exhaustivas:} Realizar pruebas rigurosas para asegurar que la herramienta cumple con todos los requisitos. Las pruebas incluirán:

  \begin{itemize}
  \tightlist
  \item
    Validación de la funcionalidad completa de la herramienta.
  \item
    Evaluación de la usabilidad por parte de estudiantes y profesores.
  \item
    Identificación y solución de problemas antes del lanzamiento.
  \end{itemize}
\end{itemize}

\hypertarget{portabilidad}{%
\section{Portabilidad}\label{portabilidad}}

Para asegurar la portabilidad, el simulador se implementará como una aplicación web que puede ejecutarse en cualquier navegador web, garantizando su uso multiplataforma.

\hypertarget{simplicidad}{%
\section{Simplicidad}\label{simplicidad}}

La herramienta será diseñada con una interfaz intuitiva y fácil de navegar, minimizando la curva de aprendizaje para los usuarios.

\hypertarget{mantenibilidad}{%
\section{Mantenibilidad}\label{mantenibilidad}}

El código de la herramienta será modular y bien documentado, facilitando futuras actualizaciones y mantenimiento. Además, se implementarán prácticas de desarrollo sostenibles para asegurar su longevidad.

\hypertarget{escalabilidad}{%
\section{Escalabilidad}\label{escalabilidad}}

Desde la asignatura se incentiva el uso de simuladores para dar apoyo a los proceso de enseñanza y aprendizaje, pero también se incentiva que los contenidos desarrollados puedan volcarse en máquinas reales, en este sentido consideramos que el enfoque planteado por la herramienta emu8086 es el más adecuado para la asignatura, ya que facilita mecanismos para implementar los programas en máquinas reales. Sin embargo presenta el inconveniente que genera ejecutables dependientes del sistema operativo MS-DOS, la mayoría de los sistemas operativos actuales no permiten la ejecución de dichos programas, obligando a la utilización de emuladores de MS-DOS para poder correrlos, siendo esto otro elemento más que se incorpora a los procesos de enseñanza y aprendizaje.
Utilizar lenguaje NASM (Netwide Assembler) garantiza soporte tanto para Linux como Windows a través de herramientas libres como GCC (GNU Compiler Collection), generando programas para la arquitectura x86 de 16, 32 y 64 bits.

\hypertarget{memoria}{%
\section{Memoria}\label{memoria}}

La memoria contiene 256 posiciones y cada una contiene un byte. Por lo tanto, el bus de direcciones y de datos son de 8 bits.

\hypertarget{repertorio-de-instrucciones-propuesto}{%
\section{Repertorio de instrucciones propuesto}\label{repertorio-de-instrucciones-propuesto}}

El repertorio de instrucciones x86 propuesto para facilitar el aprendizaje y la enseñanza de la arquitectura x86 para aquellos que están recién familiarizándose con este conjunto de instrucciones, es un repertorio ficticio basado en la arquitectura x86, para facilitar el aprendizaje se decidió simplificar los conceptos a un repertorio de 8 bits para un mejor entendimiento. Aunque el conjunto de instrucciones real de x86 es mucho más amplio y complejo, este enfoque básico sentará las bases para comprender el formato de instrucciones, los modos de direccionamiento y el ciclo de búsqueda y ejecución.

\hypertarget{repertorio-de-instrucciones-1}{%
\section{Repertorio de instrucciones}\label{repertorio-de-instrucciones-1}}

El repertorio x86 es reducido (8 bits)

\begin{longtable}[]{@{}lll@{}}
\toprule
\begin{minipage}[b]{0.30\columnwidth}\raggedright
Instrucciones\strut
\end{minipage} & \begin{minipage}[b]{0.30\columnwidth}\raggedright
Código operación\strut
\end{minipage} & \begin{minipage}[b]{0.30\columnwidth}\raggedright
Acción\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\textbf{Transferencia de datos}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\textbf{\(\leftarrow\) MOV \{0,1,2\}}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
0. Copiar entre registros 1. Almacenar en memoria 2. Cargar a registro\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\textbf{Procesamiento de datos}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\textbf{+ ADD \{3, 4, 5\}} \textbf{- SUB \{6, 7, 8\}} \textbf{* CMP \{9, 10, 11\}}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\textbf{Operación aritmética}: operando1 \(\leftarrow\) operando1 OPE operando2 ; actualiza el destino \textbf{Comparación}: operando1 - operando2 ;realiza la operación de sustraer pero no actualiza el destino.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\textbf{Control de flujo}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\textbf{\(\uparrow\)~JMP / Jxx / CALL/ RET \{12\}}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
Salto incondicional JMP Saltos condicionales Jxx Llamadas a rutinas CALL y retorno RET\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\textbf{Manejo de pila y E/S}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\textbf{PUSH / POP / OUT / IN \{13\}}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
Poner en la pila PUSH Retirar de la pila POP Enviar un byte al puerto del dispositivo de E/S Recibir un byte del dispositivo de E/S\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\textbf{Manejo de interrupción}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\textbf{INT / IRET \{14\}}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
Llamar a una rutina de tratamiento de interrupción INT Retornar de una rutina de tratamiento de interrupción IRET\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.30\columnwidth}\raggedright
\textbf{Control del CPU}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
\textbf{NOP / HLT \{15\}}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
No opera NOP Detiene el CPU HLT\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{formato-de-la-instrucciuxf3n}{%
\subsection{Formato de la instrucción}\label{formato-de-la-instrucciuxf3n}}

\begin{longtable}[]{@{}lccccl@{}}
\toprule
\begin{minipage}[b]{0.14\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[b]{0.14\columnwidth}\centering
Formato instrucción\strut
\end{minipage} & \begin{minipage}[b]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[b]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[b]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[b]{0.14\columnwidth}\raggedright
Acción\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\textbf{Código op. byte 1}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\textbf{4 bits}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\textbf{2 bits}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\textbf{2 bits}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\textbf{MOV}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\textbf{0}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{rd}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{rf}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
\textbf{Registro a registro}: Copiar entre registros: rd \(\leftarrow\) rf\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\textbf{1}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{\{0,1,2,3\}}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{rf / \{0,1, 2\}}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
** Registro/valor a memoria**: \emph{mem \(\leftarrow\) rf mem\[BL\] \(\leftarrow\) rf mem\[Dir + BL\] \(\leftarrow\) rf 3.0 mem \(\leftarrow\) valor 1 mem\[BL\] \(\leftarrow\) valor 3.2 mem\[Dir + BL\] \(\leftarrow\) valor}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\textbf{2}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{rd}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{\{0,1,2,3\}}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
** Memoria/valor a registro**: \emph{0. rd \(\leftarrow\) mem rd \(\leftarrow\) mem\[BL\] rd \(\leftarrow\) mem\[Dir + BL\] rd \(\leftarrow\) valor}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\textbf{ADD / SUB / CMP}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\textbf{\{3..11\}}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{rd}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{rf}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
Todas las instrucciones de procesamiento de datos tienen los mismos modos de direccionamiento que la instrucción MOV. Operación aritmética: \textbf{operando1 \(\leftarrow\) operando1 OPE operando2} ; actualiza el destino Comparación: \textbf{operando1 - \emph{operando2}} ;realiza la operación de sustraer pero no actualiza el destino. Operando2 puede ser registro/memoria/valor inmediato Operando1 puede ser registro o memoria\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{rr}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{rd}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
`\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\textbf{JMP/ Jxx / CALL / RET}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\textbf{12}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{\{0,1,2,3, 4,5,6,7,8,9,10,11,12,13,14\}}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
\textbf{saltos/rutinas \emph{RE: el registro de estado contiene los siguientes flags o banderas: Z =cero C = acarreo (Carry) S = signo (sign) O = desbordamiento (Overflow) Incondicional: Sin condicional} 0. JMP: IP \(\uparrow\) IP + desp \emph{Condicional: Si se cumple la condición salta} 1. JZ/JE: Z == 1 2. JNZ/JNE: Z == 0 3. JC: Si C == 1 4. JNC: Si C == 0 5. JS: Si S == 1 6. JNS: Si S == 0 7. JO: Si O == 1 8. JNO: Si O == 0 9. JGE: Si S == O \{ (con signo)\} 10. JLE: Si Z == 1 o S \textless{}\textgreater{} O \{ (con signo)\} 11. JAE: Si C == 1 \{ (sin signo)\} 12. JBE: Si C == 1 o Z == 1 \{ (sin signo)\} }Saltar a IP \(\uparrow\) IP + \emph{desp} Above/Below\emph{: se refiere a valores sin signo.} **Great/Less\emph{: se refiere a valores con signo. Rutinas:} 13. CALL: \emph{Memoria\[SP\] \(\uparrow\) IP SP\(\uparrow\) SP - 1 Memoria\[SP\] \(\uparrow\) RE SP\(\uparrow\) SP - 1 IP \(\uparrow\) \[dirección\]} 14. RET: \emph{SP \(\uparrow\) SP + 1 RE \(\uparrow\) Memoria\[SP\] SP \(\uparrow\) SP +1 IP \(\uparrow\) Memoria\[SP\]}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\textbf{PUSH / POP / OUT / IN}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\textbf{13}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{\{0,1, 2, 3\}}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{rf/rd}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
**Pila y E/S \emph{0.} PUSH \emph{rf: Memoria\[SP\] \(\uparrow\) rf SP \(\uparrow\) SP - 1 1.} POP \emph{rd: SP \(\uparrow\) SP + 1 rd \(\uparrow\) Memoria\[SP\] 2.} E/S\[puerto\] \(\uparrow\) DL \emph{3.} DL \(\uparrow\)E/S\[puerto\]\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\textbf{INT / IRET}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\textbf{14}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{ID\_INT / -}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
**Interrupción \emph{0.} INT Nro\_INT\emph{: Memoria\[SP\] \(\uparrow\) IP SP \(\uparrow\) SP - 1 Memoria\[SP\] \(\uparrow\) RE SP \(\uparrow\) SP - 1 IP \(\uparrow\) \[dirección\] IP \(\uparrow\) Vector\_Interrupción\[ID\_INT\] STI (Setear flag interrupción)} \emph{1.} IRET\emph{: SP \(\uparrow\) SP + 1 RE \(\uparrow\) Memoria\[SP\] SP \(\uparrow\) SP +1 IP \(\uparrow\) Memoria\[SP\] CLI (restablecer flag interrupción)}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
\textbf{NOP / HLT}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\textbf{15}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\emph{-}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\centering
**\{0,1\}\strut
\end{minipage} & \begin{minipage}[t]{0.14\columnwidth}\raggedright
** Control \emph{0.} NOP\emph{: IP \(\uparrow\) IP + 1 1.} HLT\emph{: Detiene el CPU}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{registros-banco-de-registros}{%
\subsection{Registros (Banco de Registros)}\label{registros-banco-de-registros}}

\begin{longtable}[]{@{}ccc@{}}
\toprule
Números de registros (r) & &\tabularnewline
\midrule
\endhead
\textbf{registro} & \textbf{binario} & \textbf{decimal}\tabularnewline
AL & 00 & 0\tabularnewline
BL & 01 & 1\tabularnewline
CL & 10 & 2\tabularnewline
DL & 11 & 3\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{modos-de-direccionamientos}{%
\subsection{Modos de direccionamientos}\label{modos-de-direccionamientos}}

Los siguientes tipos de direccionamiento son utilizados en las instrucciones de esta CPU para referenciar a los operandos involucrados en la instrucción:

\begin{itemize}
\tightlist
\item
  Registro a registro: los operandos de la instrucción son registros.\\
\item
  Directo: en la instrucción se indica la dirección de memoria en la que está contenido el operando.\\
\item
  Indirecto: dirección de memoria donde está el operando viene determinada por el contenido del registro BL\\
\item
  Inmediato: el operando fuente de la instrucción es un valor contenido en la misma instrucción.
\end{itemize}

La mayoría de las instrucciones básicas tienen solo las siguientes formas:

\begin{itemize}
\tightlist
\item
  \textbf{MOV \emph{reg, reg}}\\
\item
  \textbf{MOV \emph{reg, mem}}\\
\item
  \textbf{MOV \emph{reg, inm}}\\
\item
  \textbf{MOV \emph{mem, reg}}\\
\item
  \textbf{MOV \emph{mem, inm}}
\end{itemize}

\hypertarget{transferencia-mov-copiar}{%
\subsection{Transferencia MOV (COPIAR)}\label{transferencia-mov-copiar}}

MOV d, f

Tipo de operandos d y f: pueden ser registros, dirección de memoria, dirección indirecta por registro (BL) o valor. El operando valor no puede ser destino.

rf: registro fuente
rd: registro destino

Los 4 primeros bits de la instrucción se descompone en:
Código operación 3 bis y 1 bit se corresponde al tipo de destino, si es cero representa registro y si es 1 representa memoria.

Formato instrucción MOV Ejemplo Acción Direccionamiento

\hypertarget{ciclo-de-la-instrucciuxf3n-etapas-de-captaciuxf3n-y-ejecuciuxf3n}{%
\subsection{Ciclo de la instrucción (Etapas de captación y ejecución)}\label{ciclo-de-la-instrucciuxf3n-etapas-de-captaciuxf3n-y-ejecuciuxf3n}}

\hypertarget{captaciuxf3n}{%
\subsubsection{Captación}\label{captaciuxf3n}}

\begin{verbatim}
1.  MAR = IP 
2.  MDR = read(Memoria[MAR])
    IP = IP + 1
3.  IR  = MDR
\end{verbatim}

\hypertarget{ejecuciuxf3n}{%
\subsubsection{Ejecución}\label{ejecuciuxf3n}}

Instrucciones Operación Nemónico Acción
Transferencia de datos Mover MOV od, of Copiar: operando-destino (od) operando-fuente (of)

Procesamiento de datos + Sumar\\
- Restar
Comparar ADD od, of
SUB od, of
CMP od, of od = od + of\\
od od - of\\
od - of

Control de flujo Salto incondicional
Salto condicional
Detener JMP d
Jxx d
HLT Salto incondicional a dirección destino (d).
Saltos condicionales en base a las banderas (flags) a d.
Detiene el CPU.

\hypertarget{formato-de-instrucciones-y-modos-de-direccionamiento}{%
\subsubsection{Formato de Instrucciones y modos de direccionamiento}\label{formato-de-instrucciones-y-modos-de-direccionamiento}}

El formato de las instrucciones propuesto para la enseñanza de la arquitectura es una simplificación de la arquitectura x86, siendo este último un set CISC (conjunto de repertorio de instrucciones complejas) las instrucciones tienen diferente tamaño para poder aplicar estos conceptos a la enseñanza se representa un repertorio de instrucciones simplificado, podemos clasificar las instrucciones según los modos de direccionamientos que indica de donde proviene un operando:
Operando tipo
r Registros del CPU
{[}d{]} Contenido de la dirección de memoria
i Valor inmediato
{[}r{]} Contenido de la dirección de memoria dada por el registro

\hypertarget{procesador-vonsim8}{%
\section{\texorpdfstring{Procesador \texttt{VonSim8}}{Procesador VonSim8}}\label{procesador-vonsim8}}

\texttt{VonSim8} es un procesador diseñado e implementado sobre la herramienta \emph{Logisim}.
Este cuenta con las siguientes características:

\begin{longtable}[]{@{}ll@{}}
\toprule
Arquitectura CPU & \textbf{Características}\tabularnewline
\midrule
\endhead
& - Arquitectura \emph{von Neumann}, memoria de datos e instrucciones compartida.\tabularnewline
& - 8 registros de propósito general, \texttt{R0} a \texttt{R7}.\tabularnewline
& - 1 registro de propósito específico \texttt{IP}.\tabularnewline
& - Tamaño de palabra de 8 bits e instrucciones de 16 bits.\tabularnewline
& - Memoria de 256 palabras de 8 bits.\tabularnewline
& - Bus de 8 bits.\tabularnewline
& - Diseño microprogramado.\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{instrucciones}{%
\section{Instrucciones}\label{instrucciones}}

Las instrucciones están codificadas en 16 bits. Los primeros 5 bits identifican el \texttt{opcode} de la instrucción, el resto de los bits indican los parámetros. Existen 4 posibles codificaciones de parámetros.

\begin{longtable}[]{@{}lll@{}}
\toprule
Caso & Codificación & Parámetros\tabularnewline
\midrule
\endhead
A & \texttt{OOOO\ XXYY-\/-\/-\/-\/-} & \texttt{XX} = Registro X, \texttt{YY} = Registro Y o inmediato\tabularnewline
B & \texttt{OOOO\ XX-\/-\/-\/-\/-\/-\/-\/-} & \texttt{XX} = Registro X\tabularnewline
C & \texttt{OOOO\ -\/-\/-MMMMMMMM} & \texttt{MMMMMMMM} = Dirección de memoria o Inmediato\tabularnewline
D & \texttt{OOOO\ XXMMMMMMMM} & \texttt{XXX} = Registro X, \texttt{MMMMMMMM} = Dir. de memoria o Imm.\tabularnewline
\bottomrule
\end{longtable}

Considerando:

\begin{itemize}
\tightlist
\item
  \texttt{Rx} o \texttt{Ry}: Índices de registros, número entre \texttt{0} y \texttt{7}.
\item
  \texttt{M}: Dirección de memoria o valor inmediato, número de 8 bits.
\item
  \texttt{t}: Valor inmediato de desplazamiento, número entre \texttt{0} y \texttt{7}. Se codifica como \texttt{YYY}.
\item
  En la columna de codificación, los bits indicados con \texttt{-} son reservados y deben valer cero.
\item
  Las instrucciones de \texttt{opcode}: 9, 10, 11, 12, 13, 14, 15, 28, 29 y 30 son instrucciones reservadas.
\end{itemize}

Las instrucciones soportadas por la arquitectura son las siguientes:

\begin{longtable}[]{@{}lll@{}}
\toprule
Instrucción & Acción & Codificación\tabularnewline
\midrule
\endhead
\texttt{ADD\ \ Rx,\ Ry} & \texttt{Rx} \(\leftarrow\) \texttt{Rx\ +\ Ry} & \texttt{00001\ XXXYYY-\/-\/-\/-\/-}\tabularnewline
\texttt{SUB\ \ Rx,\ Ry} & \texttt{Rx} \(\leftarrow\) \texttt{Rx\ -\ Ry} & \texttt{00011\ XXXYYY-\/-\/-\/-\/-}\tabularnewline
\texttt{CMP\ \ Rx,\ Ry} & Modifica \emph{flags} de \texttt{Rx\ -\ Ry} & \texttt{00111\ XXXYYY-\/-\/-\/-\/-}\tabularnewline
\texttt{MOV\ \ Rx,\ Ry} & \texttt{Rx} \(\leftarrow\) \texttt{Ry} & \texttt{01000\ XXXYYY-\/-\/-\/-\/-}\tabularnewline
\texttt{MOV\ \ {[}M{]},\ Rx} & \texttt{Mem{[}M{]}} \(\leftarrow\) \texttt{Rx} & \texttt{10000\ XXXMMMMMMMM}\tabularnewline
\texttt{MOV\ Rx,\ {[}M{]}} & \texttt{Rx} \(\leftarrow\) \texttt{Mem{[}M{]}} & \texttt{10001\ XXXMMMMMMMM}\tabularnewline
\texttt{MOV\ \ {[}Rx{]},\ Ry} & \texttt{Mem{[}Rx{]}} \(\leftarrow\) \texttt{Ry} & \texttt{10010\ XXXYYY-\/-\/-\/-\/-}\tabularnewline
\texttt{MOV\ Rx,\ {[}Ry{]}} & \texttt{Rx} \(\leftarrow\) \texttt{Mem{[}Ry{]}} & \texttt{10011\ XXXYYY-\/-\/-\/-\/-}\tabularnewline
\texttt{JMP\ M} & \texttt{PC} \(\leftarrow\) \texttt{M} & \texttt{10100\ -\/-\/-MMMMMMMM}\tabularnewline
\texttt{JC\ M} & Si \texttt{flag\ C=1} entonces \texttt{PC} \(\leftarrow\) \texttt{M} & \texttt{10101\ -\/-\/-MMMMMMMM}\tabularnewline
\texttt{JZ\ M} & Si \texttt{flag\ Z=1} entonces \texttt{PC} \(\leftarrow\) \texttt{M} & \texttt{10110\ -\/-\/-MMMMMMMM}\tabularnewline
\bottomrule
\end{longtable}

Las instrucciones soportadas por la arquitectura son las siguientes:

\hypertarget{assembler}{%
\section{Assembler}\label{assembler}}

\begin{longtable}[]{@{}lll@{}}
\toprule
\# & Mnemonics & Action\tabularnewline
\midrule
\endhead
0 & \texttt{MOV\ Rx,\ Ry} & \texttt{Ra\ =\ Rb}\tabularnewline
1 & \texttt{ADD\ Rx,\ Ry} & \texttt{Ra\ +=\ Rb}\tabularnewline
2 & \texttt{SUB\ Rx,\ Ry} & \texttt{Ra\ -=\ Rb}\tabularnewline
3 & \texttt{CMP\ Rx,\ Ry} & \texttt{Ra\ -=\ Rb}\tabularnewline
4 & \texttt{MOV\ Rx,\ {[}Rb{]}} & \texttt{Ra\ =\ Mem{[}Rb{]}}\tabularnewline
5 & \texttt{MOV\ {[}Rb{]},\ Rx} & \texttt{Mem{[}Rb{]}\ =\ Ra}\tabularnewline
7 & \texttt{INP\ Ra} & \texttt{Ra\ =\ Inp}\tabularnewline
8 & \texttt{JEQ\ Ra,\ value\textbackslash{}\textbar{}label} & \texttt{PC\ =\ value\textbackslash{}\textbar{}label,\ Ra\ ==\ 0}\tabularnewline
9 & \texttt{JNE\ Ra,\ value\textbackslash{}\textbar{}label} & \texttt{PC\ =\ value\textbackslash{}\textbar{}label,\ Ra\ !=\ 0}\tabularnewline
a & \texttt{JGT\ Ra,\ value\textbackslash{}\textbar{}label} & \texttt{PC\ =\ value\textbackslash{}\textbar{}label,\ Ra\ \textgreater{}\ 0}\tabularnewline
b & \texttt{JLT\ Ra,\ value\textbackslash{}\textbar{}label} & \texttt{PC\ =\ value\textbackslash{}\textbar{}label,\ Ra\ \textless{}\ 0}\tabularnewline
c & \texttt{MOV\ Ra,\ value\textbackslash{}\textbar{}label} & \texttt{Ra\ =\ Mem{[}value\textbackslash{}\textbar{}label{]}}\tabularnewline
d & \texttt{MOV\ value\textbackslash{}\textbar{}label,\ Ra} & \texttt{Mem{[}value\textbackslash{}\textbar{}label{]}\ =\ Ra}\tabularnewline
e & \texttt{MOV\ Ra,\ value\textbackslash{}\textbar{}label} & \texttt{Ra\ =\ value\textbackslash{}\textbar{}label}\tabularnewline
f & \texttt{JMP\ value\textbackslash{}\textbar{}label} & \texttt{PC\ =\ value\textbackslash{}\textbar{}label}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{registros}{%
\section{Registros}\label{registros}}

\begin{longtable}[]{@{}lll@{}}
\toprule
\#\# & Name & Description\tabularnewline
\midrule
\endhead
00 & R0 & User data\tabularnewline
01 & R1 & User data\tabularnewline
10 & R2 & User data (output pins A0-A7)\tabularnewline
11 & R3 & User data (output pins B0-B7)\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{componentes}{%
\section{Componentes}\label{componentes}}

La arquitectura está compuesta por 6 componentes interconectados. El circuito identificado como \texttt{microOrgaSmall} los integra en un \texttt{dataPath} sobre el lado izquierdo del mismo. El lado derecho presenta la visualización del estado de los registros.

Los componentes de la arquitectura son: \texttt{Registers} (Banco de Registros), \texttt{PC} (Contador de Programa), \texttt{ALU} (Unidad Aritmético Lógica), \texttt{Memory} (Memoria), \texttt{Decode} (Decodificador de Instrucciones) y \texttt{ControlUnit} (Unidad de Control).

Cada uno de estos componentes es controlado por medio del conjunto de entradas y salidas descritas a continuación:

\hypertarget{ejecuciuxf3n-de-instrucciones}{%
\section{Ejecución de Instrucciones}\label{ejecuciuxf3n-de-instrucciones}}

Las instrucciones en \texttt{OrgaSmall} se ejecutan en varios ciclos de reloj, donde cada ciclo implica una acción específica. A continuación, se describe la secuencia de acciones para la ejecución de las instrucciones de la arquitectura.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Ciclo de Búsqueda}:

  \begin{itemize}
  \tightlist
  \item
    \texttt{PC} envía la dirección actual al bus.
  \item
    \texttt{Memory} coloca la instrucción en el bus de datos.
  \item
    \texttt{Decode} carga la instrucción en sus registros internos.
  \item
    \texttt{PC} incrementa su valor.
  \end{itemize}
\item
  \textbf{Ciclo de Decodificación}:

  \begin{itemize}
  \tightlist
  \item
    \texttt{Decode} divide la instrucción en \texttt{opcode}, registros e inmediato.
  \item
    \texttt{ControlUnit} interpreta el \texttt{opcode} y emite señales correspondientes.
  \end{itemize}
\item
  \textbf{Ciclo de Ejecución}:

  \begin{itemize}
  \tightlist
  \item
    \texttt{ControlUnit} habilita y controla los componentes para ejecutar la instrucción.
  \item
    \texttt{ALU} realiza la operación aritmética o lógica.
  \item
    \texttt{Registers} y \texttt{Memory} realizan operaciones de lectura/escritura según sea necesario.
  \end{itemize}
\end{enumerate}

Este flujo se repite para cada instrucción, permitiendo la ejecución de programas complejos en la arquitectura \texttt{OrgaSmall}.

\hypertarget{bibliografuxeda}{%
\chapter*{Bibliografía}\label{bibliografuxeda}}
\addcontentsline{toc}{chapter}{Bibliografía}

\hypertarget{refs}{}
\leavevmode\hypertarget{ref-colombani_pid_2022}{}%
{[}1{]} M. A. Colombani, M. A. Falappa, A. G. Delduca, and J. M. Ruiz, ``PID novel 7065: Enseñanza/aprendizaje de asignatura Arquitectura de Computadoras con herramientas de simulación de sistemas de cómputos.'' Feb. 2022. Accessed: Jul. 10, 2024. Available: \href{https://proyectos.uner.edu.ar/aplicacion.php?ah=st668e6d47663eb\&ai=gestion_extinv\%7C\%7C23000105}{https://proyectos.uner.edu.ar/aplicacion.php?ah=st668e6d47663eb\&ai=gestion\_extinv\textbar{}\textbar{}23000105}

\leavevmode\hypertarget{ref-banks_discrete-event_2010}{}%
{[}2{]} J. Banks, J. S. Carson, B. L. Nelson, and D. M. Nicol, \emph{Discrete-event system simulation}, 5th ed. Prentice Hall, 2010.

\leavevmode\hypertarget{ref-law_simulation_2015}{}%
{[}3{]} A. M. Law, \emph{Simulation Modeling \& Analysis}, 5th ed. New York, NY, USA: McGraw-Hill, 2015.

\leavevmode\hypertarget{ref-robinson_simulation_2014}{}%
{[}4{]} S. Robinson, \emph{Simulation: The Practice of Model Development and Use}, 2nd edition. 2014.

\leavevmode\hypertarget{ref-lion_simuladores_2005}{}%
{[}5{]} C. Lion, ``Los simuladores. Su potencial para la enseñanza universitaria,'' \emph{Cuadernos de Investigación Educativa}, vol. 2, no. 12, pp. 53--66, 2005.

\leavevmode\hypertarget{ref-contreras_uso_2010}{}%
{[}6{]} G. Contreras, R. G. Torres, and M. S. R. Montoya, ``Uso de simuladores como recurso digital para la transferencia de conocimiento,'' \emph{Apertura: Revista de Innovación Educativa}, vol. 2, no. 1, pp. 86--100, 2010.

\leavevmode\hypertarget{ref-garcia-garcia_pbbcache_2020}{}%
{[}7{]} A. Garcia-Garcia, J. C. Saez, J. L. Risco-Martin, and M. Prieto-Matias, ``PBBCache: An open-source parallel simulator for rapid prototyping and evaluation of cache-partitioning and cache-clustering policies,'' \emph{Journal of Computational Science}, vol. 42, p. 101102, 2020.

\leavevmode\hypertarget{ref-nova_tool_2013}{}%
{[}8{]} B. Nova, J. C. Ferreira, and A. Araújo, ``Tool to support computer architecture teaching and learning,'' in \emph{Engineering Education (CISPEE), 2013 1st International Conference of the Portuguese Society for}, IEEE, 2013, pp. 1--8.

\leavevmode\hypertarget{ref-mustafa_evaluating_2010}{}%
{[}9{]} B. Mustafa, ``Evaluating A System Simulator For Computer Architecture Teaching And Learning Support,'' \emph{Innovation in Teaching and Learning in Information and Computer Sciences}, vol. 9, no. 1, pp. 100--104, 2010, doi: \href{https://doi.org/10.11120/ital.2010.09010100}{10.11120/ital.2010.09010100}.

\leavevmode\hypertarget{ref-radivojevic_design_2011}{}%
{[}10{]} Z. Radivojevic, M. Cvetanovic, and J. Ðordevic, ``Design of the simulator for teaching computer architecture and organization,'' in \emph{2011 Second Eastern European Regional Conference on the Engineering of Computer Based Systems}, IEEE, 2011, pp. 124--130.

\leavevmode\hypertarget{ref-nikolic_survey_2009}{}%
{[}11{]} B. Nikolic, Z. Radivojevic, J. Djordjevic, and V. Milutinovic, ``A Survey and Evaluation of Simulators Suitable for Teaching Courses in Computer Architecture and Organization,'' \emph{IEEE Transactions on Education}, vol. 52, no. 4, pp. 449--458, Nov. 2009, doi: \href{https://doi.org/10.1109/TE.2008.930097}{10.1109/TE.2008.930097}.

\leavevmode\hypertarget{ref-hasan_survey_2012}{}%
{[}12{]} R. Hasan and S. Mahmood, ``Survey and evaluation of simulators suitable for teaching for computer architecture and organization Supporting undergraduate students at Sir Syed University of Engineering \& Technology,'' in \emph{Control (CONTROL), 2012 UKACC International Conference on}, IEEE, 2012, pp. 1043--1045.

\leavevmode\hypertarget{ref-hennessy_computer_2012}{}%
{[}13{]} J. L. Hennessy and D. A. Patterson, \emph{Computer architecture: A quantitative approach}, Fifth Edition. Elsevier, 2012.

\leavevmode\hypertarget{ref-stallings_computer_2013}{}%
{[}14{]} W. Stallings, \emph{Computer organization and architecture: Designing for performance}, Eleventh Edition. Pearson, 2013.

\leavevmode\hypertarget{ref-intel_64_2016}{}%
{[}15{]} Intel, ``64 and IA-32 architectures software developers manual,'' \emph{325462-060US}, vols. 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C and 3D, p. 4670, 2016, Available: \url{https://software.intel.com/en-us/articles/intel-sdm}

\leavevmode\hypertarget{ref-amd_developer_2019}{}%
{[}16{]} AMD, ``Developer Guides, Manuals \& ISA Documents.'' Apr. 2019. Accessed: Apr. 21, 2019. Available: \url{https://developer.amd.com/resources/developer-guides-manuals/}

\leavevmode\hypertarget{ref-abel_ibm_2000}{}%
{[}17{]} P. Abel, \emph{IBM PC Assembly Language and Programming}, Fifth Edition. Upper Saddle River, NJ, USA: Prentice Hall PTR, 2000.

\leavevmode\hypertarget{ref-skrien_cpu_2001}{}%
{[}18{]} D. Skrien, ``CPU Sim 3.1: A tool for simulating computer architectures for computer organization classes,'' \emph{Journal on Educational Resources in Computing (JERIC)}, 2001.

\leavevmode\hypertarget{ref-peterson_petri_1981}{}%
{[}19{]} J. L. Peterson, \emph{Petri net theory and the modeling of systems}. Prentice Hall PTR, 1981.

\leavevmode\hypertarget{ref-zeigler_theory_2000}{}%
{[}20{]} B. Zeigler, H. Prähofer, and T. G. Kim, ``Theory of Modeling and Simulation: Integrating Discrete Event and Continuous Complex Dynamic Systems,'' vol. 2, Jan. 2000.

\leavevmode\hypertarget{ref-zeigler_theory_2018}{}%
{[}21{]} B. P. Zeigler, A. Muzy, and E. Kofman, \emph{Theory of Modeling and Simulation: Discrete Event \& Iterative System Computational Foundations}. Academic Press, 2018.

\leavevmode\hypertarget{ref-patterson2016computer}{}%
{[}22{]} D. A. Patterson and J. L. Hennessy, \emph{Computer organization and design arm edition: The hardware software interface}. Morgan kaufmann, 2016.

\leavevmode\hypertarget{ref-waterman2014risc}{}%
{[}23{]} A. Waterman, Y. Lee, D. A. Patterson, and K. Asanovic, ``The risc-v instruction set manual, volume i: User-level isa,'' \emph{CS Division, EECE Department, University of California, Berkeley}, p. 28, 2014.

\leavevmode\hypertarget{ref-patterson_computer_2017}{}%
{[}24{]} D. A. Patterson and J. L. Hennessy, \emph{Computer organization and design risc-v edition: The hardware software interface}. Morgan Kaufmann, 2017.

\leavevmode\hypertarget{ref-irvine2011assembly}{}%
{[}25{]} K. R. Irvine and L. B. Das, \emph{Assembly language for x86 processors}. Prentice Hall, 2011.

\leavevmode\hypertarget{ref-tasm}{}%
{[}26{]} B. International, \emph{Turbo assembler user's guide}. Borland International, 1993.

\leavevmode\hypertarget{ref-masm}{}%
{[}27{]} M. Corporation, \emph{Microsoft macro assembler 6.1 reference}. Microsoft Press, 1992.

\leavevmode\hypertarget{ref-nasm}{}%
{[}28{]} The NASM Project, \emph{The netwide assembler (nasm) manual}. 2023.

\leavevmode\hypertarget{ref-hyde2010art}{}%
{[}29{]} R. Hyde, \emph{The art of assembly language}. No Starch Press, 2010.

\leavevmode\hypertarget{ref-colombani_herramientas_2022}{}%
{[}30{]} M. A. Colombani, J. M. Ruiz, A. G. Delduca, and M. A. Falappa, ``Herramientas de software para dar soporte en la enseñanza y aprendizaje de la arquitectura x86,'' 2022. Accessed: Jul. 10, 2024. Available: \url{http://sedici.unlp.edu.ar/handle/10915/139908}

\leavevmode\hypertarget{ref-behrooz_computer_2005}{}%
{[}31{]} P. BEHROOZ, \emph{Computer Architecture: From Microprocessors to Supercomputers}. Oxford University Press Inc, 2005.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%% Bibliography                              %%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \addtocontents{toc}{\vspace{.5\baselineskip}}
% \cleardoublepage
% \phantomsection
% \addcontentsline{toc}{chapter}{\protect\numberline{}{Bibliography}}
\bibliography{tesis}


%% All books from our library (SfS) are already in a BiBTeX file
%% (Assbib). You can use Assbib combined with your personal BiBTeX file:
%% \bibliography{Myreferences,Assbib}. Of course, this will only work on
%% the computers at SfS, unless you copy the Assbib file
%%  --> /u/sfs/bib/Assbib.bib



\end{document}
