# Diseño y construcción del simulador
El objetivo principal de esta tesis es construir una herramienta de simulación de la arquitectura x86 para apoyar la enseñanza de arquitectura de computadoras. Para lograr este objetivo, se plantean los siguientes objetivos específicos: 

1. Estudiar y evaluar diferentes herramientas actuales de simulación destinadas a dar apoyo a la enseñanza de la arquitectura x86.

    Se cumplió el primer objetivo mediante una revisión exhaustiva de las herramientas de simulación actuales destinadas a apoyar la enseñanza de la arquitectura x86.

2. Construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras, para ello debe cumplir:
    - Una visión global de la estructura y funcionamiento de la computadora.
    - Generación y ejecución de programas en ensamblador.
    - Repertorio de instrucciones x86 reducido y habilitado progresivamente.
    - Simulación visual e interactiva de micropasos de instrucciones.
    - Gestión de interrupciones y comunicación con periféricos.
    - Medidas de rendimiento de ejecución de programas.

Para cumplir con el segundo objetivo, se diseñó y construyó una herramienta de apoyo que cumple con los requisitos previamente mencionados para impartir los contenidos de la asignatura Arquitectura de Computadoras.

Construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras, para ello debe cumplir, se puede adpatar

Para lograr esto, se comenzamos por definir los requisitos de la herramienta. 

### Requisitos de la herramienta
Para cumplir con el segundo objetivo específico, la herramienta debe cumplir con los siguientes requisitos:

**Visión global de la computadora:** Debe mostrar la estructura completa de la computadora (CPU, bus, memoria y E/S) durante la ejecución de programas, destacando componentes relevantes.

**Generación y ejecución de programas en ensamblador:** Permitir tanto la ejecución paso a paso como completa, facilitando la comprensión de cada instrucción.

**Repertorio de instrucciones x86 reducido:** Seleccionar un subconjunto esencial de instrucciones x86, habilitándolas progresivamente según avance el contenido de la asignatura.

**Simulación visual e interactiva de micropasos:** Utilizar el lenguaje de transferencia entre registros (RTL) para describir el flujo de datos, facilitando la comprensión del ciclo básico de una instrucción. Correr un programa y que se ilumine  cada componente durante la ejecución de un programa.

**Gestión de interrupciones:** Incorporar un vector de interrupción predefinido para interactuar con el teclado y monitor.

**Comunicación con módulos de E/S y periféricos:** Incluir instrucciones IN y OUT, y un módulo de E/S simplificado basado en el modo 2 del Intel 8255.

**Medidas de rendimiento:** Proveer información sobre tiempo de ciclo, tiempo de CPU y CPI de un programa. 

La herramienta debe ofrecer una visión global de la estructura y funcionamiento de la computadora, permitir la generación y ejecución de programas escritos en lenguaje ensamblador, ya sea paso a paso por instrucción o completa, y ofrecer un repertorio de instrucciones x86 reducido donde se habiliten las instrucciones a medida que se desarrolle el contenido en la asignatura.

Además, la herramienta debe simular de manera visual e interactiva los micropasos que conlleva el ciclo básico de una instrucción, permitir la gestión básica de interrupciones permitiendo la interacción con el teclado y la pantalla, permitir la comunicación con los módulos de entrada y salida e interacciones con los periféricos, y ofrecer medidas de rendimiento sobre la ejecución de un programa.

**Definición de Requisitos:** 
- Visión global de la estructura y funcionamiento de la computadora.
- Generación y ejecución de programas en ensamblador.
- Repertorio de instrucciones x86 reducido y habilitado progresivamente.
- Simulación visual e interactiva de micropasos.
- Gestión de interrupciones y comunicación con periféricos.
- Medidas de rendimiento de ejecución de programas.

**Diseño de la Herramienta:** 
- Considerar la facilidad de uso para estudiantes y profesores.
- Utilizar gráficos y diagramas para mejorar la comprensión.

**Construcción de la Herramienta:** 
- Implementar la herramienta siguiendo las especificaciones de diseño.
- Realizar pruebas exhaustivas para asegurar que la herramienta cumple con todos los requisitos.
- Solucionar cualquier problema identificado durante las pruebas antes del lanzamiento.

Para cumplir con el segundo objetivo específico, es esencial diseñar y construir una herramienta de apoyo que sea fácil de usar para estudiantes y profesores, cumpliendo con los requisitos definidos, y realizar pruebas rigurosas para asegurar su funcionalidad y usabilidad.

La herramienta debe ofrecer una visión global de la estructura y funcionamiento de la computadora, permitir la generación y ejecución de programas escritos en lenguaje ensamblador, ya sea paso a paso por instrucción o completa, y ofrecer un repertorio de instrucciones x86 reducido donde se habiliten las instrucciones a medida que se desarrolle el contenido en la asignatura. Además, la herramienta debe simular de manera visual e interactiva los micropasos que conlleva el ciclo básico de una instrucción, permitir la gestión básica de interrupciones permitiendo la interacción con el teclado y la pantalla, permitir la comunicación con los módulos de entrada y salida e interacciones con los periféricos, y ofrecer medidas de rendimiento sobre la ejecución de un programa.

Una vez que se hayan definido los requisitos, se puede comenzar a diseñar la herramienta. Se debe tener en cuenta la facilidad de uso para los estudiantes y profesores. La herramienta debe ser intuitiva y fácil de navegar. Se pueden utilizar gráficos y diagramas para ayudar a los estudiantes a comprender mejor la estructura y funcionamiento de la computadora.

Después de diseñar la herramienta, se debe construir y probar. Se deben realizar pruebas exhaustivas para asegurarse de que la herramienta cumpla con todos los requisitos y sea fácil de usar. Si se encuentran problemas durante las pruebas, se deben solucionar antes de lanzar la herramienta.

En resumen, para cumplir con el segundo objetivo específico, se debe diseñar y construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras. La herramienta debe cumplir con los requisitos mencionados anteriormente y debe ser fácil de usar para los estudiantes y profesores. Para lograr esto, se puede comenzar por definir los requisitos de la herramienta, diseñar la herramienta, construir y probar.

### Desarrollo y Pruebas
**Diseño de la Herramienta:** Comenzar con la definición detallada de los requisitos, seguido de un diseño centrado en la facilidad de uso para estudiantes y profesores. Se utilizarán gráficos y diagramas para mejorar la comprensión.

**Construcción de la Herramienta:** Implementar la herramienta siguiendo las especificaciones de diseño, asegurando la integridad y funcionalidad de cada componente.

**Pruebas Exhaustivas:** Realizar pruebas rigurosas para asegurar que la herramienta cumple con todos los requisitos. Las pruebas incluirán:
- Validación de la funcionalidad completa de la herramienta.
- Evaluación de la usabilidad por parte de estudiantes y profesores.
- Identificación y solución de problemas antes del lanzamiento.

### Portabilidad
Para asegurar la portabilidad, el simulador se implementará como una aplicación web que puede ejecutarse en cualquier navegador web, garantizando su uso multiplataforma.

### Simplicidad
La herramienta será diseñada con una interfaz intuitiva y fácil de navegar, minimizando la curva de aprendizaje para los usuarios.

### Mantenibilidad
El código de la herramienta será modular y bien documentado, facilitando futuras actualizaciones y mantenimiento. Además, se implementarán prácticas de desarrollo sostenibles para asegurar su longevidad.

### Escalabilidad
Desde la asignatura se incentiva el uso de simuladores para dar apoyo a los proceso de enseñanza y aprendizaje, pero también se incentiva que los contenidos desarrollados puedan volcarse en máquinas reales, en este sentido consideramos que el enfoque planteado por la herramienta emu8086 es el más adecuado para la asignatura, ya que facilita mecanismos para implementar los programas en máquinas reales. Sin embargo presenta el inconveniente que genera ejecutables dependientes del sistema operativo MS-DOS, la mayoría de los sistemas operativos actuales no permiten la ejecución de dichos programas, obligando a la utilización de emuladores de MS-DOS para poder correrlos, siendo esto otro elemento más que se incorpora a los procesos de enseñanza y aprendizaje. 
Utilizar lenguaje NASM (Netwide Assembler) garantiza soporte tanto para Linux como Windows a través de herramientas libres como GCC (GNU Compiler Collection), generando programas para la arquitectura x86 de 16, 32 y 64 bits.

### Memoria
La memoria contiene 256 posiciones y cada una contiene un byte. Por lo tanto, el bus de direcciones y de datos son de 8 bits. 

## Repertorio de instrucciones propuesto
El repertorio de instrucciones x86 propuesto para facilitar el aprendizaje y la enseñanza de la arquitectura x86 para aquellos que están recién familiarizándose con este conjunto de instrucciones, es un repertorio ficticio basado en la arquitectura x86, para facilitar el aprendizaje se decidió simplificar los conceptos a un repertorio de 8 bits para un mejor entendimiento. Aunque el conjunto de instrucciones real de x86 es mucho más amplio y complejo, este enfoque básico sentará las bases para comprender el formato de instrucciones, los modos de direccionamiento y el ciclo de búsqueda y ejecución.

## Transferencia MOV (COPIAR)

MOV d, f

Tipo de operandos d y f: pueden ser registros, dirección de memoria, dirección indirecta por registro (BL) o valor. El operando valor no puede ser destino.

rf: registro fuente
rd: registro destino

Los 4 primeros bits de la instrucción se descompone en:
Código operación 3 bis y 1 bit se corresponde al tipo de destino, si es cero representa registro y si es 1 representa memoria.

Formato instrucción MOV	Ejemplo	Acción	Direccionamiento
byte 1	byte 2	byte 3			
4	2	2					
0=0000	rd	rf	-	-	MOV AL, BL	Copiar entre registros: rd = rf  	registro-registro
1=0001	0=00	rf	Dir	-	MOV [0x1], AL	Almacenar en memoria:
0.	mem = rf
1.	mem[BL] = rf
2.mem[Dir + BL] = rf
3.0 mem = valor
3.1.mem[BL] = valor  
3.2.mem[Dir + BL] = valor	
0.	directo
1.	indirecto
2.	indirecto
3.	0.inmediato
3.1.inmediato
3.2.inmediato

1=0001	1=01	rf	-	-	MOV [BL], AL		
1=0001	2=10	rf	Dir	-	MOV [[0x4 + BL], AL		
1=0001	3=11	0=00	Dir	Valor	MOV [0x1], 0x1		
1=0001	3=11	1=01	Valor	-	MOV [BL], 0x1		
1=0001	3=11	2=10	Dir	Valor	MOV [0x4 + BL], 0x1		
2=0010	rd	0=00	Dir	-	MOV AL, [0x1]	Cargar a registro:
0.	rd = mem
1.	rd = mem[BL] 
2.	rd = mem[Dir + BL]
3.	rd = valor   	
0.	directo
1.	indirecto
2.	indirecto
3.	inmediato
2=0010	rd	1=01	-	-	MOV AL, [BL]		
2=0010	rd	2=10	Dir	-	MOV AL, [0x4 + BL]		
2=0010	rd	3=11	Valor	-	MOV AL, 0x2		

### Ciclo de la instrucción (Etapas de captación y ejecución)

#### Captación
    1.	MAR = IP 
    2.	MDR = read(Memoria[MAR])
        IP = IP + 1
    3.	IR  = MDR

#### Ejecución
Instrucciones	Operación	Nemónico	Acción
Transferencia de datos        	 Mover	MOV od, of	Copiar: operando-destino (od)   operando-fuente (of)

Procesamiento de datos      	+  Sumar  
- Restar
Comparar 	ADD  od, of
SUB   od, of
CMP  od, of  	od = od + of  
od  od - of  
od - of  

Control de flujo	 Salto incondicional 
 Salto condicional
 Detener 	JMP  d
Jxx    d
HLT 	Salto incondicional a dirección destino (d). 
Saltos condicionales en base a las banderas (flags) a d.
Detiene el CPU.

#### Formato de Instrucciones y modos de direccionamiento
El formato de las instrucciones propuesto para la enseñanza de la arquitectura es una simplificación de la arquitectura x86, siendo este último un set CISC (conjunto de repertorio de instrucciones complejas) las instrucciones tienen diferente tamaño para poder aplicar estos conceptos a la enseñanza se representa un repertorio de instrucciones simplificado, podemos clasificar las instrucciones según los modos de direccionamientos que indica de donde proviene un operando:
Operando	tipo
r	Registros del CPU
[d]	Contenido de la dirección de memoria
i	Valor inmediato
[r]	Contenido de la dirección de memoria dada por el registro



## Procesador `VonSim8`

`VonSim8` es un procesador diseñado e implementado sobre la herramienta *Logisim*.
Este cuenta con las siguientes características:

| Arquitectura CPU | **Características** |
| --- | --- |
| | - Arquitectura *von Neumann*, memoria de datos e instrucciones compartida. |
| | - 8 registros de propósito general, `R0` a `R7`. |
| | - 1 registro de propósito específico `IP`. |
| | - Tamaño de palabra de 8 bits e instrucciones de 16 bits. |
| | - Memoria de 256 palabras de 8 bits. |
| | - Bus de 8 bits. |
| | - Diseño microprogramado. |

## Instrucciones

Las instrucciones están codificadas en 16 bits. Los primeros 5 bits identifican el `opcode` de la instrucción, el resto de los bits indican los parámetros. Existen 4 posibles codificaciones de parámetros.

| Caso | Codificación | Parámetros |
| --- | --- | --- |
| A | `OOOOO XXXYYY-----` | `XXX` = Registro X, `YYY` = Registro Y o inmediato |
| B | `OOOOO XXX--------` | `XXX` = Registro X |
| C | `OOOOO ---MMMMMMMM` | `MMMMMMMM` = Dirección de memoria o Inmediato |
| D | `OOOOO XXXMMMMMMMM` | `XXX` = Registro X, `MMMMMMMM` = Dir. de memoria o Imm. |

Considerando:

- `Rx` o `Ry`: Índices de registros, número entre `0` y `7`.
- `M`: Dirección de memoria o valor inmediato, número de 8 bits.
- `t`: Valor inmediato de desplazamiento, número entre `0` y `7`. Se codifica como `YYY`.
- En la columna de codificación, los bits indicados con `-` son reservados y deben valer cero.
- Las instrucciones de `opcode`: 9, 10, 11, 12, 13, 14, 15, 28, 29 y 30 son instrucciones reservadas.

Las instrucciones soportadas por la arquitectura son las siguientes:

| Instrucción            | Acción                                                             | Codificación               |
| ---                    | ---                                                                | ---                        |
| `ADD  Rx, Ry`          | `Rx` $\leftarrow$ `Rx + Ry`                                        | `00001 XXXYYY-----`        |
| `ADC  Rx, Ry`          | `Rx` $\leftarrow$ `Rx + Ry + flag_C`                               | `00010 XXXYYY-----`        |
| `SUB  Rx, Ry`          | `Rx` $\leftarrow$ `Rx - Ry`                                        | `00011 XXXYYY-----`        |
| `AND  Rx, Ry`          | `Rx` $\leftarrow$ `Rx and Ry`                                      | `00100 XXXYYY-----`        |
| `OR   Rx, Ry`          | `Rx` $\leftarrow$ `Rx or Ry`                                       | `00101 XXXYYY-----`        |
| `XOR  Rx, Ry`          | `Rx` $\leftarrow$ `Rx xor Ry`                                      | `00110 XXXYYY-----`        |
| `CMP  Rx, Ry`          | Modifica *flags* de `Rx - Ry`                                      | `00111 XXXYYY-----`        |
| `MOV  Rx, Ry`          | `Rx` $\leftarrow$ `Ry`                                             | `01000 XXXYYY-----`        |
| `STR  [M], Rx`         | `Mem[M]` $\leftarrow$ `Rx`                                         | `10000 XXXMMMMMMMM`        |
| `LOAD Rx, [M]`         | `Rx` $\leftarrow$ `Mem[M]`                                         | `10001 XXXMMMMMMMM`        |
| `STR  [Rx], Ry`        | `Mem[Rx]` $\leftarrow$ `Ry`                                        | `10010 XXXYYY-----`        |
| `LOAD Rx, [Ry]`        | `Rx` $\leftarrow$ `Mem[Ry]`                                        | `10011 XXXYYY-----`        |
| `JMP M`                | `PC` $\leftarrow$ `M`                                              | `10100 ---MMMMMMMM`        |
| `JC M`                 | Si `flag_C=1` entonces `PC` $\leftarrow$ `M`                       | `10101 ---MMMMMMMM`        |
| `JZ M`                 | Si `flag_Z=1` entonces `PC` $\leftarrow$ `M`                       | `10110 ---MMMMMMMM`        |
| `JN M`                 | Si `flag_N=1` entonces `PC` $\leftarrow$ `M`                       | `10111 ---MMMMMMMM`        |
| `INC Rx`               | `Rx` $\leftarrow$ `Rx + 1`                                         | `11000 XXX--------`        |
| `DEC Rx`               | `Rx` $\leftarrow$ `Rx - 1`                                         | `11001 XXX--------`        |
| `SHR Rx, t`            | `Rx` $\leftarrow$ `Rx` << `t`                                      | `11010 XXXYYY-----`        |
| `SHL Rx, t`            | `Rx` $\leftarrow$ `Rx` >> `t`                                      | `11011 XXXYYY-----`        |
| `SET Rx, M`            | `Rx` $\leftarrow$ `M`                                              | `11111 XXXMMMMMMMM`        |

## Componentes

La arquitectura está compuesta por 6 componentes interconectados. El circuito identificado como `microOrgaSmall` los integra en un `dataPath` sobre el lado izquierdo del mismo. El lado derecho presenta la visualización del estado de los registros.

Los componentes de la arquitectura son: `Registers` (Banco de Registros), `PC` (Contador de Programa), `ALU` (Unidad Aritmético Lógica), `Memory` (Memoria), `Decode` (Decodificador de Instrucciones) y `ControlUnit` (Unidad de Control).

Cada uno de estos componentes es controlado por medio del conjunto de entradas y salidas descritas a continuación:

### `Registers` (Banco de Registros)
- `inData(8)` y `outData(8)`: Entrada y salida de datos.
- `RB_enIn(1)` y `RB_enOut(1)`: Habilita entrada y salida.
- `RB_inSelect(1)` y `RB_outSelect(1)`: Selecciona el índice de `X` y `Y`.

### `PC` (Contador de Programa)
- `inValue(8)` y `outValue(8)`: Entrada y salida del PC.
- `PC_load(1)`: Carga un nuevo valor en el registro.
- `PC_inc(1)`: Incrementa el valor actual.
- `PC_enOut(1)`: Habilita la salida del valor.

### `ALU` (Unidad Aritmético Lógica)
- `A(8)`, `B(8)`, `out(8)` y `flags(3)`: Entradas y salidas de la ALU.
- `ALU_enA(1)`, `ALU_enB(1)` y `ALU_enOut(1)`: Habilitación de entradas y salidas.
- `ALU_opW(1)`: Indica si se deben escribir los *flags*.
- `ALU_OP(4)`: Indica la operación a realizar por la ALU.

### `Memory` (Memoria)
- `inData(8)` y `outData(8)`: Entrada y salida de datos.
- `MM_addr`: Dirección de memoria donde leer.
- `MM_enOut`: Habilitación de la salida.
- `MM_load`: Indica si leer o escribir.
- `MM_enAddr`: Habilita cargar la dirección.

### `Decode` (Decodificador de Inst.)
- `halfInst(8)`: Entrada de datos (media instrucción).
- `DE_loadL(8)` y `DE_loadH(8)`: Indica cargar la mitad alta o baja.
- `opcode(5)`: Salida de Opcode decodificado.
- `indexX(3)` y `indexY(3)`: Salidas de índices de registros.
- `valueM(8)`: Salida de valor inmediato o dirección.

### `ControlUnit` (Unidad de Control)
- `inOpcode(5)`: Entrada de *Opcode*.
- `flags(3)`: Entrada de *flags*.
- `RB_enIn(1)` y `RB_enOut(1)`: Señales de habilitación para Registros.
- `RB_inSelect(1)` y `RB_outSelect(1)`: Señales de selección para Registros.
- `MM_enOut(1)` y `MM_load(1)`: Señales para la Memoria.
- `MM_enAddr(1)`: Habilita cargar la dirección.
- `ALU_enA(1)`, `ALU_enB(1)` y `ALU_enOut(1)`: Señales de habilitación de la ALU.
- `ALU_opW(1)`, `ALU_OP(4)`: Señales de control de la ALU.
- `PC_load(1)`, `PC_inc(1)` y `PC_enOut(1)`: Señales de control de PC.
- `DE_loadL(1)` y `DE_loadH(1)`: Señales de control del Decodificador.

## Ejecución de Instrucciones

Las instrucciones en `OrgaSmall` se ejecutan en varios ciclos de reloj, donde cada ciclo implica una acción específica. A continuación, se describe la secuencia de acciones para la ejecución de las instrucciones de la arquitectura.

1. **Ciclo de Búsqueda**: 
   - `PC` envía la dirección actual al bus.
   - `Memory` coloca la instrucción en el bus de datos.
   - `Decode` carga la instrucción en sus registros internos.
   - `PC` incrementa su valor.

2. **Ciclo de Decodificación**:
   - `Decode` divide la instrucción en `opcode`, registros e inmediato.
   - `ControlUnit` interpreta el `opcode` y emite señales correspondientes.

3. **Ciclo de Ejecución**:
   - `ControlUnit` habilita y controla los componentes para ejecutar la instrucción.
   - `ALU` realiza la operación aritmética o lógica.
   - `Registers` y `Memory` realizan operaciones de lectura/escritura según sea necesario.

Este flujo se repite para cada instrucción, permitiendo la ejecución de programas complejos en la arquitectura `OrgaSmall`.
