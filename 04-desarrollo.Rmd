# Dise√±o y Construcci√≥n del Simulador

## Objetivo General
El objetivo principal de esta tesis es construir una herramienta de simulaci√≥n de la arquitectura x86 para apoyar la ense√±anza de arquitectura de computadoras. Para lograr este objetivo, se plantean los siguientes objetivos espec√≠ficos:

## Objetivos Espec√≠ficos
### Evaluaci√≥n de Herramientas Existentes
Estudiar y evaluar diferentes herramientas actuales de simulaci√≥n destinadas a apoyar la ense√±anza de la arquitectura x86. Este objetivo se cumpli√≥ mediante una revisi√≥n exhaustiva de las herramientas de simulaci√≥n disponibles.


### Desarrollo de una Nueva Herramienta de Simulaci√≥n:
Dise√±ar y construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras, que sea intuitiva y f√°cil de usar para estudiantes y profesores.  

### Requisitos de la Herramienta
La herramienta debe cumplir con los siguientes requisitos:
1. **Visi√≥n global de la estructura y funcionamiento de la computadora:**
   - Mostrar la estructura completa de la computadora (CPU, bus, memoria y E/S) durante la ejecuci√≥n de programas, destacando componentes relevantes.

2. **Generaci√≥n y ejecuci√≥n de programas escritos en ensamblador:**
   - Permitir tanto la ejecuci√≥n paso a paso como completa, facilitando la comprensi√≥n de cada instrucci√≥n.

3. **Repertorio de instrucciones x86 reducido y habilitado progresivamente:**
   - Seleccionar un subconjunto esencial de instrucciones x86, habilit√°ndolas progresivamente seg√∫n avance el contenido de la asignatura.

4. **Simulaci√≥n visual e interactiva de micropasos de una instrucci√≥n:**
    - Utilizar el lenguaje de transferencia entre registros (RTL) para describir el flujo de datos, facilitando la comprensi√≥n del ciclo b√°sico de una instrucci√≥n. Correr un programa y que se ilumine  cada componente durante la ejecuci√≥n de un programa.

5. **Gesti√≥n b√°sica de interrupciones y comunicaci√≥n con perif√©ricos:**
    - Incorporar un vector de interrupci√≥n predefinido para interactuar con el teclado y monitor. Incluir instrucciones IN y OUT, y un m√≥dulo de E/S simplificado.

6. **Medidas de rendimiento sobre la ejecuci√≥n de un programa:**
    - Proveer informaci√≥n sobre tiempo de ciclo, tiempo de CPU y CPI de un programa. 

## Arquitectura propuesta
La arquitectura es una simplificaci√≥n de la arquitectura x86, con un repertorio de instrucciones reducido y un conjunto de componentes b√°sicos. Se propone una arquitectura de 8 bits que pueda ser utilizada como apoyo para ense√±ar los conceptos de formato de instrucciones, los modos de direccionamiento y el ciclo de b√∫squeda y ejecuci√≥n. La arquitectura propuesta consta de los siguientes componentes:

### Componentes
Procesador o CPU cuenta con las siguientes caracter√≠sticas:

| Arquitectura CPU | **Caracter√≠sticas** |
| --- | --- |
| Arquitectura | -  *von Neumann*, memoria de datos e instrucciones compartidas. |
|Registros | - 4 registros de prop√≥sito general, `AL`, `BL`, `DL` y `DL` de 8 bits. |
| | - 2 registros de prop√≥sito espec√≠fico `IP` y `SP`. |
| | - 1 registro de estado para las banderas `RS`. |
| | - 2 registros Buffer entre CPU y memoria `MAR`:buffer de direcciones y `MBR`:buffer de datos. |
|Memoria | - contiene 256 posiciones y cada una contiene un byte. |
|Buses | - Bus de datos y direcciones de 8 bits. | 
| Instrucciones| - Tama√±o de instrucciones variable de 1, 2 y 3 bytes. | 
| | - 16 instrucciones soportadas. |


### Repertorio de instrucciones
El repertorio de instrucciones x86 propuesto para facilitar el aprendizaje y la ense√±anza de la arquitectura x86 para aquellos que est√°n reci√©n familiariz√°ndose con este conjunto de instrucciones, es un repertorio ficticio basado en la arquitectura x86, para facilitar el aprendizaje se decidi√≥ simplificar los conceptos a un repertorio de 8 bits para un mejor entendimiento.

#### Primera etapa
En un primera instancia se presentaran solo algunas instrucciones necesarias para desarrollar los primeros contenidos de la asignatura:

```{r data, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear los datos
data <- data.frame(
    `C√≥digo operaci√≥n` = c(
    "{0, 1, 2}", 
    "{3, 4, 5} {6, 7, 8} {9, 10, 11}", 
    "{12}"
  ),
  Instrucciones = c(
    "üîÑ Transferencia de datos", 
    "‚ûï Procesamiento de datos", 
    "‚¨ÜÔ∏è Control de flujo" 
  ),
  `Nem√≥nico` = c(
    "MOV ", 
    "ADD, SUB,  CMP", 
    "JMP, Jxx "
  ),
  Acci√≥n = c( "1- Copiar entre registros 2- Cargar a registro  3- Almacenar en memoria",
    "1- Sumar  2- Restar 3- Comparar",
    "- Saltos condicionales e incondicionales"
  )
)

# Convertir a HTML
kable(data, format = "markdown", align = "l", col.names = c("C√≥digo operaci√≥n", "Instrucciones", "nem√≥nico", "Acci√≥n"), 
      caption = "Tabla de Instrucciones y C√≥digos de Operaci√≥n de la Arquitectura x86")
```

##### Formato de instrucciones
El formato de las instrucciones propuesto para la ense√±anza de la arquitectura es una simplificaci√≥n de la arquitectura x86, siendo este √∫ltimo un set CISC (conjunto de repertorio de instrucciones complejas) las instrucciones tienen diferente tama√±o para poder aplicar estos conceptos a la ense√±anza se representa un repertorio de instrucciones simplificado. 
Primero veremos la codificaciones de 4 tipos de instrucciones.

| Caso | Codificaci√≥n | Par√°metros |
| --- | --- | --- |
| A: entre registros | `---- XXYY` | `XX` = Registro destino, `YY` = Registro fuente |
| B: Cargar a registro  | `---- XX00 DDDDDDDD` | `XX` = Registro destino, `D` = Direcci√≥n de memoria |
| C: Almacenar en memoria | `---- 00YY DDDDDDDD` | `YY` = Registro fuente, `D` = Direcci√≥n de memoria |
| D: control de flujo  | `---- ffff DDDDDDDD` | `ffff` = funcionalidad `D` = Direcci√≥n de memoria |

Considerando:

  - `A`: operaciones entre registros del procesador.

  - `B`: operaciones que cargan en registros del procesado.

  - `C`: operaciones que almacenan en memoria.

  - `D`: operaciones de control de flujo del programa.

  - `----`: C√≥digo de operaci√≥n de la instrucci√≥n.

  - `XX` o `YY`: √çndices de registros, n√∫mero entre `0` y `3`.

  - `D`: Direcci√≥n de memoria, n√∫mero de 8 bits.

  - `ffff`: representan el comportamiento de la instrucci√≥n.

  - Las instruciones de transferencia y de procesamiento soportan los formatos `A`, `B` y `C`.

  - Las instruciones de control de flujo soportan el formato `D`. 

#### Registros (Banco de Registros)

| N√∫meros de registros (R)  |  |  |
| :---: | :---: | :---: |
| **registro** | **binario** | **decimal** |
| AL | 00 | 0 |
| BL | 01 | 1 |
| CL | 10 | 2 |
| DL | 11 | 3 |

##### Modos de direccionamientos

Los siguientes tipos de direccionamiento son utilizados en las instrucciones de esta CPU para referenciar a los operandos involucrados en la instrucci√≥n:

  * Registro a registro: los operandos de la instrucci√≥n son registros. 

  * Directo: en la instrucci√≥n se indica la direcci√≥n de memoria en la que est√° contenido el operando.  


La mayor√≠a de las instrucciones b√°sicas tienen solo las siguientes formas:

  * **MOV *Rx, Ry***  

  * **MOV *Rx, [M]***  

  * **MOV *[M], Ry***  

  * **JMP *M***  


| Operando | tipo | 
| --- | --- |
| `Rx`,`Ry`| por Registros |
| `[M]`|	Directo, se accede a un contenido de memoria |
| `M`|	Directo, se accede a una direcci√≥n de memoria |

| # | Instrucci√≥n        | Acci√≥n                                                             | Codificaci√≥n                  |
| - | ---                | ---                                                                | ---                           |
| 0 | `MOV Rx, Ry`       | `Rx` $\leftarrow$ `Ry`                                             | `0000 XXYY`                   |
| 1 | `MOV Rx, [M]`      | `Rx` $\leftarrow$ `Mem[Direcci√≥n]`                                 | `0001 00YY DDDDDDDD`          |
| 2 | `MOV [M], Ry`      | `Mem[Direcci√≥n]` $\leftarrow$ `Rx`                                 | `0010 XX00 DDDDDDDD`          |
| 3 | `ADD Rx, Ry`       | `Rx` $\leftarrow$ `Rx + Ry`                                        | `0011 XXYY`                   |
| 4 | `ADD Rx, [M]`      | `Rx` $\leftarrow$ `Rx + Mem[Direcci√≥n]`                            | `0100 00YY DDDDDDDD`          |
| 5 | `ADD [M], Ry`      | `Mem[Direcci√≥n]` $\leftarrow$ `Mem[Direcci√≥n] + Ry`                | `0101 XX00 DDDDDDDD`          |
| 6 | `SUB Rx, Ry`       | `Rx` $\leftarrow$ `Rx - Ry`                                        | `0110 XXYY`                   |
| 7 | `SUB Rx, [M]`      | `Rx` $\leftarrow$ `Rx - Mem[Direcci√≥n]`                            | `0111 00YY DDDDDDDD`          |
| 8 | `SUB [M], Ry`      | `Mem[Direcci√≥n]` $\leftarrow$ `Mem[Direcci√≥n] - Ry`                | `1000 XX00 DDDDDDDD`          |
| 9 | `CMP Rx, Ry`       | Modifica *flags* de `Rx - Ry`                                      | `1001 XXYY`                   |
| A | `CMP Rx, [M]`       | Modifica *flags* de `Rx - Mem[Direcci√≥n]`                         | `1010 00YY DDDDDDDD`          |
| B | `CMP [M], Ry`       | Modifica *flags* de `Mem[Direcci√≥n] - Ry`                         | `1011 XX00 DDDDDDDD`          |
| C | `JMP M`            | `IP` $\leftarrow$ `Direcci√≥n`                                      | `1100 0000 DDDDDDDD`          |
| C | `JC M`             | Si `flag C=1` entonces `IP` $\leftarrow$ `Direcci√≥n`               | `1100 0001 DDDDDDDD`          |
| C | `JZ M`             | Si `flag Z=1` entonces `IP` $\leftarrow$ `Direcci√≥n`               | `1100 0011 DDDDDDDD`          |
| C | `Jxx M`            | Se pueden implementar m√°s flags                                  | `1100 ffff DDDDDDDD`          |

### Segunda etapa
En un segunda instancia se amplian los modos de direccionamiento de las instrucciones y se incorporan nuevos formato de instrucciones y modos de direccionamiento.

#### Modos de direccionamientos
Se incoporan los siguientes modos de direccionamiento:

  * Indirecto: direcci√≥n de memoria donde est√° el operando viene determinada por el contenido del registro `BL`  

  * Inmediato: el operando fuente de la instrucci√≥n es un valor contenido en la misma instrucci√≥n.   


Se incorpora los siguientes operandos a las instrucciones:
  * **MOV *Rx, [BL]***  

  * **MOV *Rx, d***  

  * **MOV *Rx, [BL + d]***  

  * **MOV *[BL], Ry***

  * **MOV *[BL + d], Ry***

  * **MOV *[mem], [BL]***

  * **MOV *[mem], d***

  * **MOV *[mem], [BL + d]***

| Operando | tipo | 
| --- | --- |
| `[BL]`|	indirecto por registro,	Contenido de la direcci√≥n de memoria esta dada por el registro `BL`  |
| `D` o `d`| el operando fuente es un dato inmediato |
| `[BL + d]`|	registro `BL` + dato inmediato  |

#### Formato de instrucciones
Las instrucciones est√°n codificadas con 1, 2 o 3 bytes. Los primeros 4 bits identifican el `opcode` de la instrucci√≥n y determinan como se tienen que ise interpretar los 4 bits restantes. 

| Caso | Codificaci√≥n | Par√°metros |
| --- | --- | --- |
| A: entre registros | `---- XXYY` | `XX` = Registro destino, `YY` = Registro fuente |
| B: Cargar a registro  | `---- XXmm DDDDDDDD` | `mm` = modo, `XX` = Registro destino, `D` = Direcci√≥n de memoria o Dato Inmediato |
| C: Almacenar en memoria | `---- mmmm DDDDDDDD dddddddd` | `mmmm` = modo ampliado, `D` = Direcci√≥n de memoria,  `d` = Dato Inmediato |
| D: control de flujo  | `---- ffff DDDDDDDD` | `ffff` = funcionalidad `D` = Direcci√≥n de memoria |

 `d` = Dato Inmediato, no puede ser destino de la instrucci√≥n.

| Modo direccionamientos B: Cargar a registro  |  |  |
| :---: | :---: | :---: |
| **`mm`= Modo** | **`Byte`= tama√±o** | **Interpretaci√≥n** |
| 00 |  2 |directo `D` = Direcci√≥n de memoria |
| 01 |  1 |indirecto utiliza como operando implicito el registro `BL` y no requiere operando `D` |
| 10 |  2 |Inmediato `D` = Dato Inmediato |
| 11 |  2 |Indirecto la direcci√≥n se calcula operando implicito `BL` + Dato Inmediato|

| Modo direccionamientos C: Almacenar en memoria  |  |  |
| :---: | :---: | :---: |
| **`mmmm`= Modo** | **`Byte`= tama√±o** | **Interpretaci√≥n** |
| 00YY |  2 |directo `D` = Direcci√≥n de memoria, `YY` = Registro fuente |
| 01YY |  1 |indirecto `BL`, `YY` = Registro fuente|
| 01YY |  2 |Indirecto la direcci√≥n se calcula operando implicito `BL` + Dato Inmediato |
| 1100 |  3 |Inmediato a memoria|
| 1101 |  2 |Inmediato a memoria mediante indirecto `BL`|
| 1110 |  3 |Inmediato a memoria mediante indirecto `BL`+ Dato Inmediato |


| # | Instrucci√≥n        | Acci√≥n                                                             | Codificaci√≥n                  |
| - | ---                | ---                                                                | ---                           |
| 0 | `MOV Rx, Ry`       | `Rx` $\leftarrow$ `Ry`                                             | `0000 XXYY`                   |
| 1 | `MOV Rx, [M]`      | `Rx` $\leftarrow$ `Mem[Direcci√≥n]`                                 | `0001 XX00 DDDDDDDD`          |
| 1 | `MOV Rx, [BL]`     | `Rx` $\leftarrow$ `Mem[BL]`                                        | `0001 XX01`                   |
| 1 | `MOV Rx, D`        | `Rx` $\leftarrow$ `Dato`                                           | `0001 XX10 DDDDDDDD`          |
| 1 | `MOV Rx, [BL + D]` | `Rx` $\leftarrow$ `Mem[BL + Dato]`                                 | `0001 XX11 DDDDDDDD`          |
| 2 | `MOV [M], Ry`      | `Mem[Direcci√≥n]` $\leftarrow$ `Rx`                                 | `0010 00YY DDDDDDDD`          |
| 2 | `MOV [BL], Ry`     | `Mem[BL]` $\leftarrow$ `Rx`                                        | `0010 01YY`                   |
| 2 | `MOV [BL + D], Ry` | `Mem[BL + Dato]` $\leftarrow$ `Rx`                                 | `0010 10YY DDDDDDDD`          |
| 2 | `MOV [M], D`       | `Mem[Direcci√≥n]` $\leftarrow$ `Dato`                               | `0010 1100 DDDDDDDD dddddddd` |
| 2 | `MOV [BL], D`      | `Mem[BL]` $\leftarrow$ `Dato`                                      | `0010 1101 DDDDDDDD`          |
| 2 | `MOV [BL + D], D`  | `Mem[BL + Dato]` $\leftarrow$ `Dato`                               | `0010 1110 DDDDDDDD`          |
| 3 | `ADD Rx, Ry`       | `Rx` $\leftarrow$ `Rx + Ry`                                        | `0011 XXYY`                   |
| 4 | `ADD --, --`       | Mismo direccionamientos que MOV                                    | `0100 ---- --------`          |
| 5 | `ADD --, --`       | Mismo direccionamientos que MOV                                    | `0101 ---- -------- --------` |
| 6 | `SUB Rx, Ry`       | `Rx` $\leftarrow$ `Rx - Ry`                                        | `0110 XXYY`                   |
| 7 | `SUB --, --`       | Mismo direccionamientos que MOV                                    | `0111 ---- --------`          |
| 8 | `SUB --, --`       | Mismo direccionamientos que MOV                                    | `1000 ---- -------- --------` |
| 9 | `CMP Rx, Ry`       | Modifica *flags* de `Rx - Ry`                                      | `1001 XXYY`                   |
| A | `CMP --, --`       | Mismo direccionamientos que MOV                                    | `1010 ---- --------`          |
| B | `CMP --, --`       | Mismo direccionamientos que MOV                                    | `1011 ---- -------- --------` |
| C | `JMP M`            | `IP` $\leftarrow$ `Direcci√≥n`                                      | `1100 0000 DDDDDDDD`          |
| C | `JC M`             | Si `flag C=1` entonces `IP` $\leftarrow$ `Direcci√≥n`               | `1100 0001 DDDDDDDD`          |
| C | `JZ M`             | Si `flag Z=1` entonces `IP` $\leftarrow$ `Direcci√≥n`               | `1100 0011 DDDDDDDD`          |
| C | `Jxx M`            | Se pueden implemementar m√°s flags y CALL                           | `1100 ffff --------`          |



### Tercera etapa
Se incorporan las instrucciones de manejo de pila y de manejo de interrupciones.

```{r isacompleta, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear los datos
isacompleta <- data.frame(
    `C√≥digo operaci√≥n` = c(
    "{0, 1, 2}", 
    "{3, 4, 5} {6, 7, 8} {9, 10, 11}", 
    "{12}",
    "{13}",
    "{14}",
    "{15}"
  ),
  Instrucciones = c(
    "üîÑ Transferencia de datos", 
    "‚ûï Procesamiento de datos", 
    "‚¨ÜÔ∏è Control de flujo", 
    "üì¶ Manejo de pila y E/S", 
    "üö® Manejo de interrupci√≥n", 
    "‚öôÔ∏è Control del CPU"
  ),
  `Nem√≥nico` = c(
    "MOV ", 
    "ADD, SUB,  CMP", 
    "JMP, Jxx,CALL, RET",
    "PUSH, POP, OUT, IN",
    "INT , IRET",
    "NOP , HLT"
  ),
  Acci√≥n = c(
    "1- Copiar entre registros 2- Cargar a registro 3- Almacenar en memoria",
    "Operaci√≥n aritm√©tica sumar y restar. Comparaci√≥n",
    "Salto incondicional JMP. Saltos condicionales Jxx.Llamadas a rutinas CALL y retorno RET ",
    "Poner en la pila PUSH Retirar de la pila POP Enviar un byte al puerto del dispositivo de E/S Recibir un byte del dispositivo de E/S",
    "Llamar a una rutina de tratamiento de interrupci√≥n INT Retornar de una rutina de tratamiento de interrupci√≥n IRET",
    "No opera NOP Detiene el CPU HLT"
  )
)

# Convertir a HTML
kable(isacompleta, format = "markdown", align = "l", col.names = c("C√≥digo operaci√≥n", "Instrucciones", "nem√≥nico", "Acci√≥n"), 
      caption = "Tabla de Instrucciones y C√≥digos de Operaci√≥n de la Arquitectura x86")
```

### Ciclo de la instrucci√≥n (Etapas de captaci√≥n y ejecuci√≥n)

#### **Etapa de B√∫squeda**: 
    1.	MAR = IP 
    2.	MDR = read(Memoria[MAR])
        IP = IP + 1
    3.	IR  = MDR

#### **Etapa de Ejecuci√≥n**:
- MOV Rx, Ry:
    1.	Rx ‚Üê Ry




## Desarrollo y Pruebas
Despu√©s de dise√±ar la herramienta, se debe construir y probar. Se deben realizar pruebas exhaustivas para asegurarse de que la herramienta cumpla con todos los requisitos y sea f√°cil de usar. Si se encuentran problemas durante las pruebas, se deben solucionar antes de lanzar la herramienta.
La herramienta debe cumplir con los requisitos mencionados anteriormente y debe ser f√°cil de usar para los estudiantes y profesores. Para lograr esto, se puede comenzar por definir los requisitos de la herramienta, dise√±ar la herramienta, construir y probar.

Para cumplir con el segundo objetivo, se dise√±√≥ y construy√≥ una herramienta de apoyo que cumple con los requisitos previamente mencionados para impartir los contenidos de la asignatura Arquitectura de Computadoras.

- **Dise√±o de la Herramienta:** Comenzar con la definici√≥n detallada de los requisitos, seguido de un dise√±o centrado en la facilidad de uso para estudiantes y profesores. Se utilizar√°n gr√°ficos y diagramas para mejorar la comprensi√≥n.

- **Construcci√≥n de la Herramienta:** Implementar la herramienta siguiendo las especificaciones de dise√±o, asegurando la integridad y funcionalidad de cada componente.

- **Pruebas Exhaustivas:** Realizar pruebas rigurosas para asegurar que la herramienta cumple con todos los requisitos. Las pruebas incluir√°n:
    - Validaci√≥n de la funcionalidad completa de la herramienta.
    - Evaluaci√≥n de la usabilidad por parte de estudiantes y profesores.
    - Identificaci√≥n y soluci√≥n de problemas antes del lanzamiento.

### Portabilidad
Para asegurar la portabilidad, el simulador se implementar√° como una aplicaci√≥n web que puede ejecutarse en cualquier navegador web, garantizando su uso multiplataforma.

### Simplicidad
La herramienta ser√° dise√±ada con una interfaz intuitiva y f√°cil de navegar, minimizando la curva de aprendizaje para los usuarios.

### Mantenibilidad
El c√≥digo de la herramienta ser√° modular y bien documentado, facilitando futuras actualizaciones y mantenimiento. Adem√°s, se implementar√°n pr√°cticas de desarrollo sostenibles para asegurar su longevidad.

### Escalabilidad
Desde la asignatura se incentiva el uso de simuladores para dar apoyo a los proceso de ense√±anza y aprendizaje, pero tambi√©n se incentiva que los contenidos desarrollados puedan volcarse en m√°quinas reales, en este sentido consideramos que el enfoque planteado por la herramienta emu8086 es el m√°s adecuado para la asignatura, ya que facilita mecanismos para implementar los programas en m√°quinas reales. Sin embargo presenta el inconveniente que genera ejecutables dependientes del sistema operativo MS-DOS, la mayor√≠a de los sistemas operativos actuales no permiten la ejecuci√≥n de dichos programas, obligando a la utilizaci√≥n de emuladores de MS-DOS para poder correrlos, siendo esto otro elemento m√°s que se incorpora a los procesos de ense√±anza y aprendizaje. 
Utilizar lenguaje NASM (Netwide Assembler) garantiza soporte tanto para Linux como Windows a trav√©s de herramientas libres como GCC (GNU Compiler Collection), generando programas para la arquitectura x86 de 16, 32 y 64 bits.
