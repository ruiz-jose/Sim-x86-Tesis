# Diseño y construcción del simulador
El objetivo principal de esta tesis es construir una herramienta de simulación de la arquitectura x86 para apoyar la enseñanza de arquitectura de computadoras. Para lograr este objetivo, se plantean los siguientes objetivos específicos: 

1. Estudiar y evaluar diferentes herramientas actuales de simulación destinadas a dar apoyo a la enseñanza de la arquitectura x86.

    Se cumplió el primer objetivo mediante una revisión exhaustiva de las herramientas de simulación actuales destinadas a apoyar la enseñanza de la arquitectura x86.

2. Construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras, para ello debe cumplir:
    - Una visión global de la estructura y funcionamiento de la computadora.
    - Generación y ejecución de programas en ensamblador.
    - Repertorio de instrucciones x86 reducido y habilitado progresivamente.
    - Simulación visual e interactiva de micropasos de instrucciones.
    - Gestión de interrupciones y comunicación con periféricos.
    - Medidas de rendimiento de ejecución de programas.

Para cumplir con el segundo objetivo, se diseñó y construyó una herramienta de apoyo que cumple con los requisitos previamente mencionados para impartir los contenidos de la asignatura Arquitectura de Computadoras.

Construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras, para ello debe cumplir, se puede adpatar

Para lograr esto, se comenzamos por definir los requisitos de la herramienta. 

### Requisitos de la herramienta
Para cumplir con el segundo objetivo específico, la herramienta debe cumplir con los siguientes requisitos:

**Visión global de la computadora:** Debe mostrar la estructura completa de la computadora (CPU, bus, memoria y E/S) durante la ejecución de programas, destacando componentes relevantes.

**Generación y ejecución de programas en ensamblador:** Permitir tanto la ejecución paso a paso como completa, facilitando la comprensión de cada instrucción.

**Repertorio de instrucciones x86 reducido:** Seleccionar un subconjunto esencial de instrucciones x86, habilitándolas progresivamente según avance el contenido de la asignatura.

**Simulación visual e interactiva de micropasos:** Utilizar el lenguaje de transferencia entre registros (RTL) para describir el flujo de datos, facilitando la comprensión del ciclo básico de una instrucción. Correr un programa y que se ilumine  cada componente durante la ejecución de un programa.

**Gestión de interrupciones:** Incorporar un vector de interrupción predefinido para interactuar con el teclado y monitor.

**Comunicación con módulos de E/S y periféricos:** Incluir instrucciones IN y OUT, y un módulo de E/S simplificado basado en el modo 2 del Intel 8255.

**Medidas de rendimiento:** Proveer información sobre tiempo de ciclo, tiempo de CPU y CPI de un programa. 

La herramienta debe ofrecer una visión global de la estructura y funcionamiento de la computadora, permitir la generación y ejecución de programas escritos en lenguaje ensamblador, ya sea paso a paso por instrucción o completa, y ofrecer un repertorio de instrucciones x86 reducido donde se habiliten las instrucciones a medida que se desarrolle el contenido en la asignatura.

Además, la herramienta debe simular de manera visual e interactiva los micropasos que conlleva el ciclo básico de una instrucción, permitir la gestión básica de interrupciones permitiendo la interacción con el teclado y la pantalla, permitir la comunicación con los módulos de entrada y salida e interacciones con los periféricos, y ofrecer medidas de rendimiento sobre la ejecución de un programa.

**Definición de Requisitos:** 
- Visión global de la estructura y funcionamiento de la computadora.
- Generación y ejecución de programas en ensamblador.
- Repertorio de instrucciones x86 reducido y habilitado progresivamente.
- Simulación visual e interactiva de micropasos.
- Gestión de interrupciones y comunicación con periféricos.
- Medidas de rendimiento de ejecución de programas.

**Diseño de la Herramienta:** 
- Considerar la facilidad de uso para estudiantes y profesores.
- Utilizar gráficos y diagramas para mejorar la comprensión.

**Construcción de la Herramienta:** 
- Implementar la herramienta siguiendo las especificaciones de diseño.
- Realizar pruebas exhaustivas para asegurar que la herramienta cumple con todos los requisitos.
- Solucionar cualquier problema identificado durante las pruebas antes del lanzamiento.

Para cumplir con el segundo objetivo específico, es esencial diseñar y construir una herramienta de apoyo que sea fácil de usar para estudiantes y profesores, cumpliendo con los requisitos definidos, y realizar pruebas rigurosas para asegurar su funcionalidad y usabilidad.

La herramienta debe ofrecer una visión global de la estructura y funcionamiento de la computadora, permitir la generación y ejecución de programas escritos en lenguaje ensamblador, ya sea paso a paso por instrucción o completa, y ofrecer un repertorio de instrucciones x86 reducido donde se habiliten las instrucciones a medida que se desarrolle el contenido en la asignatura. Además, la herramienta debe simular de manera visual e interactiva los micropasos que conlleva el ciclo básico de una instrucción, permitir la gestión básica de interrupciones permitiendo la interacción con el teclado y la pantalla, permitir la comunicación con los módulos de entrada y salida e interacciones con los periféricos, y ofrecer medidas de rendimiento sobre la ejecución de un programa.

Una vez que se hayan definido los requisitos, se puede comenzar a diseñar la herramienta. Se debe tener en cuenta la facilidad de uso para los estudiantes y profesores. La herramienta debe ser intuitiva y fácil de navegar. Se pueden utilizar gráficos y diagramas para ayudar a los estudiantes a comprender mejor la estructura y funcionamiento de la computadora.

Después de diseñar la herramienta, se debe construir y probar. Se deben realizar pruebas exhaustivas para asegurarse de que la herramienta cumpla con todos los requisitos y sea fácil de usar. Si se encuentran problemas durante las pruebas, se deben solucionar antes de lanzar la herramienta.

En resumen, para cumplir con el segundo objetivo específico, se debe diseñar y construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras. La herramienta debe cumplir con los requisitos mencionados anteriormente y debe ser fácil de usar para los estudiantes y profesores. Para lograr esto, se puede comenzar por definir los requisitos de la herramienta, diseñar la herramienta, construir y probar.

### Desarrollo y Pruebas
**Diseño de la Herramienta:** Comenzar con la definición detallada de los requisitos, seguido de un diseño centrado en la facilidad de uso para estudiantes y profesores. Se utilizarán gráficos y diagramas para mejorar la comprensión.

**Construcción de la Herramienta:** Implementar la herramienta siguiendo las especificaciones de diseño, asegurando la integridad y funcionalidad de cada componente.

**Pruebas Exhaustivas:** Realizar pruebas rigurosas para asegurar que la herramienta cumple con todos los requisitos. Las pruebas incluirán:
- Validación de la funcionalidad completa de la herramienta.
- Evaluación de la usabilidad por parte de estudiantes y profesores.
- Identificación y solución de problemas antes del lanzamiento.

### Portabilidad
Para asegurar la portabilidad, el simulador se implementará como una aplicación web que puede ejecutarse en cualquier navegador web, garantizando su uso multiplataforma.

### Simplicidad
La herramienta será diseñada con una interfaz intuitiva y fácil de navegar, minimizando la curva de aprendizaje para los usuarios.

### Mantenibilidad
El código de la herramienta será modular y bien documentado, facilitando futuras actualizaciones y mantenimiento. Además, se implementarán prácticas de desarrollo sostenibles para asegurar su longevidad.

### Escalabilidad
Desde la asignatura se incentiva el uso de simuladores para dar apoyo a los proceso de enseñanza y aprendizaje, pero también se incentiva que los contenidos desarrollados puedan volcarse en máquinas reales, en este sentido consideramos que el enfoque planteado por la herramienta emu8086 es el más adecuado para la asignatura, ya que facilita mecanismos para implementar los programas en máquinas reales. Sin embargo presenta el inconveniente que genera ejecutables dependientes del sistema operativo MS-DOS, la mayoría de los sistemas operativos actuales no permiten la ejecución de dichos programas, obligando a la utilización de emuladores de MS-DOS para poder correrlos, siendo esto otro elemento más que se incorpora a los procesos de enseñanza y aprendizaje. 
Utilizar lenguaje NASM (Netwide Assembler) garantiza soporte tanto para Linux como Windows a través de herramientas libres como GCC (GNU Compiler Collection), generando programas para la arquitectura x86 de 16, 32 y 64 bits.

### Memoria
La memoria contiene 256 posiciones y cada una contiene un byte. Por lo tanto, el bus de direcciones y de datos son de 8 bits. 

## Repertorio de instrucciones propuesto
El repertorio de instrucciones x86 propuesto para facilitar el aprendizaje y la enseñanza de la arquitectura x86 para aquellos que están recién familiarizándose con este conjunto de instrucciones, es un repertorio ficticio basado en la arquitectura x86, para facilitar el aprendizaje se decidió simplificar los conceptos a un repertorio de 8 bits para un mejor entendimiento. Aunque el conjunto de instrucciones real de x86 es mucho más amplio y complejo, este enfoque básico sentará las bases para comprender el formato de instrucciones, los modos de direccionamiento y el ciclo de búsqueda y ejecución.

## Transferencia MOV (COPIAR)

MOV d, f

Tipo de operandos d y f: pueden ser registros, dirección de memoria, dirección indirecta por registro (BL) o valor. El operando valor no puede ser destino.

rf: registro fuente
rd: registro destino

Los 4 primeros bits de la instrucción se descompone en:
Código operación 3 bis y 1 bit se corresponde al tipo de destino, si es cero representa registro y si es 1 representa memoria.

Formato instrucción MOV	Ejemplo	Acción	Direccionamiento


```{r inst-mov, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)
library(dplyr) # o library(magrittr)

data <- data.frame(
  `Formato instrucción MOV` = c("byte 1", "", "4", "0=0000", "1=0001", "1=0001", "1=0001", "1=0001", "1=0001", "1=0001", "2=0010", "2=0010", "2=0010", "2=0010"),
  `byte 1` = c("", "", "", "", "", "", "rd", "0=00", "1=01", "2=10", "3=11", "3=11", "3=11", "rd", "rd", "rd", "rd"),
  `byte 2` = c("", "", "", "", "", "", "rf", "rf", "rf", "rf", "0=00", "1=01", "2=10", "0=00", "1=01", "2=10", "3=11"),
  `byte 3` = c("", "", "", "", "", "", "-", "Dir", "-", "Dir", "Dir", "Valor", "Dir", "Dir", "-", "Dir", "Valor"),
  `Ejemplo` = c("Ejemplo", "", "", "", "", "", "MOV AL, BL", "MOV [0x1], AL", "MOV [BL], AL", "MOV [[0x4 + BL], AL", "MOV [0x1], 0x1", "MOV [BL], 0x1", "MOV [0x4 + BL], 0x1", "MOV AL, [0x1]", "MOV AL, [BL]", "MOV AL, [0x4 + BL]", "MOV AL, 0x2"),
  `Acción` = c("Acción", "", "", "", "", "", "Copiar entre registros: rd ← rf", "Almacenar en memoria: mem ← rf", "", "", "mem ← valor", "mem[BL] ← valor", "mem[Dir + BL] ← valor", "Cargar a registro: rd ← mem", "", "", "rd ← valor"),
  `Direccionamiento` = c("Direccionamiento", "", "", "", "", "", "registro-registro", "0. directo", "1. indirecto", "2. indirecto", "3.0 inmediato", "3.1 inmediato", "3.2 inmediato", "0. directo", "1. indirecto", "2. indirecto", "3. inmediato"),
  stringsAsFactors = FALSE
)

# Formatear la tabla con kable y kableExtra
kable(data, "html", escape = FALSE, col.names = c("Formato instrucción MOV", "byte 1", "byte 2", "byte 3", "Ejemplo", "Acción", "Direccionamiento")) %>%
  kable_styling("striped", full_width = F) %>%
  column_spec(1, bold = TRUE, border_right = TRUE) %>%
  column_spec(2:4, border_right = TRUE) %>%
  column_spec(5:7, border_right = TRUE)
```

Formato instrucción MOV	Ejemplo	Acción	Direccionamiento
byte 1	byte 2	byte 3			
4	2	2					
0=0000	rd	rf	-	-	MOV AL, BL	Copiar entre registros: rd = rf  	registro-registro
1=0001	0=00	rf	Dir	-	MOV [0x1], AL	Almacenar en memoria:
0.	mem = rf
1.	mem[BL] = rf
2.mem[Dir + BL] = rf
3.0 mem = valor
3.1.mem[BL] = valor  
3.2.mem[Dir + BL] = valor	
0.	directo
1.	indirecto
2.	indirecto
3.	0.inmediato
3.1.inmediato
3.2.inmediato

1=0001	1=01	rf	-	-	MOV [BL], AL		
1=0001	2=10	rf	Dir	-	MOV [[0x4 + BL], AL		
1=0001	3=11	0=00	Dir	Valor	MOV [0x1], 0x1		
1=0001	3=11	1=01	Valor	-	MOV [BL], 0x1		
1=0001	3=11	2=10	Dir	Valor	MOV [0x4 + BL], 0x1		
2=0010	rd	0=00	Dir	-	MOV AL, [0x1]	Cargar a registro:
0.	rd = mem
1.	rd = mem[BL] 
2.	rd = mem[Dir + BL]
3.	rd = valor   	
0.	directo
1.	indirecto
2.	indirecto
3.	inmediato
2=0010	rd	1=01	-	-	MOV AL, [BL]		
2=0010	rd	2=10	Dir	-	MOV AL, [0x4 + BL]		
2=0010	rd	3=11	Valor	-	MOV AL, 0x2		

### Ciclo de la instrucción (Etapas de captación y ejecución)

#### Captación
    1.	MAR = IP 
    2.	MDR = read(Memoria[MAR])
        IP = IP + 1
    3.	IR  = MDR

#### Ejecución
Instrucciones	Operación	Nemónico	Acción
Transferencia de datos        	 Mover	MOV od, of	Copiar: operando-destino (od)   operando-fuente (of)

Procesamiento de datos      	+  Sumar  
- Restar
Comparar 	ADD  od, of
SUB   od, of
CMP  od, of  	od = od + of  
od  od - of  
od - of  

Control de flujo	 Salto incondicional 
 Salto condicional
 Detener 	JMP  d
Jxx    d
HLT 	Salto incondicional a dirección destino (d). 
Saltos condicionales en base a las banderas (flags) a d.
Detiene el CPU.

#### Formato de Instrucciones y modos de direccionamiento
El formato de las instrucciones propuesto para la enseñanza de la arquitectura es una simplificación de la arquitectura x86, siendo este último un set CISC (conjunto de repertorio de instrucciones complejas) las instrucciones tienen diferente tamaño para poder aplicar estos conceptos a la enseñanza se representa un repertorio de instrucciones simplificado, podemos clasificar las instrucciones según los modos de direccionamientos que indica de donde proviene un operando:
Operando	tipo
r	Registros del CPU
[d]	Contenido de la dirección de memoria
i	Valor inmediato
[r]	Contenido de la dirección de memoria dada por el registro