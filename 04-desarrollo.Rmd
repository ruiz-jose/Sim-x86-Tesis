# Diseño y construcción del simulador
El objetivo principal de esta tesis es construir una herramienta de simulación de la arquitectura x86 para apoyar la enseñanza de arquitectura de computadoras. Para lograr este objetivo, se plantean los siguientes objetivos específicos: 

1. Estudiar y evaluar diferentes herramientas actuales de simulación destinadas a dar apoyo a la enseñanza de la arquitectura x86.

    Se cumplió el primer objetivo mediante una revisión exhaustiva de las herramientas de simulación actuales destinadas a apoyar la enseñanza de la arquitectura x86.

2. Construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras, para ello debe cumplir:
    - Una visión global de la estructura y funcionamiento de la computadora.
    - Generación y ejecución de programas en ensamblador.
    - Repertorio de instrucciones x86 reducido y habilitado progresivamente.
    - Simulación visual e interactiva de micropasos de instrucciones.
    - Gestión de interrupciones y comunicación con periféricos.
    - Medidas de rendimiento de ejecución de programas.

Para cumplir con el segundo objetivo, se diseñó y construyó una herramienta de apoyo que cumple con los requisitos previamente mencionados para impartir los contenidos de la asignatura Arquitectura de Computadoras.

Construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras, para ello debe cumplir, se puede adpatar

Para lograr esto, se comenzamos por definir los requisitos de la herramienta. 

## Requisitos de la herramienta
Para cumplir con el segundo objetivo específico, la herramienta debe cumplir con los siguientes requisitos:

- **Visión global de la computadora:** Debe mostrar la estructura completa de la computadora (CPU, bus, memoria y E/S) durante la ejecución de programas, destacando componentes relevantes.

- **Generación y ejecución de programas en ensamblador:** Permitir tanto la ejecución paso a paso como completa, facilitando la comprensión de cada instrucción.

- **Repertorio de instrucciones x86 reducido:** Seleccionar un subconjunto esencial de instrucciones x86, habilitándolas progresivamente según avance el contenido de la asignatura.

- **Simulación visual e interactiva de micropasos:** Utilizar el lenguaje de transferencia entre registros (RTL) para describir el flujo de datos, facilitando la comprensión del ciclo básico de una instrucción. Correr un programa y que se ilumine  cada componente durante la ejecución de un programa.

- **Gestión de interrupciones:** Incorporar un vector de interrupción predefinido para interactuar con el teclado y monitor.

- **Comunicación con módulos de E/S y periféricos:** Incluir instrucciones IN y OUT, y un módulo de E/S simplificado basado en el modo 2 del Intel 8255.

- **Medidas de rendimiento:** Proveer información sobre tiempo de ciclo, tiempo de CPU y CPI de un programa. 

La herramienta debe ofrecer una visión global de la estructura y funcionamiento de la computadora, permitir la generación y ejecución de programas escritos en lenguaje ensamblador, ya sea paso a paso por instrucción o completa, y ofrecer un repertorio de instrucciones x86 reducido donde se habiliten las instrucciones a medida que se desarrolle el contenido en la asignatura.

Además, la herramienta debe simular de manera visual e interactiva los micropasos que conlleva el ciclo básico de una instrucción, permitir la gestión básica de interrupciones permitiendo la interacción con el teclado y la pantalla, permitir la comunicación con los módulos de entrada y salida e interacciones con los periféricos, y ofrecer medidas de rendimiento sobre la ejecución de un programa.

**Definición de Requisitos:** 
    - Visión global de la estructura y funcionamiento de la computadora.
    - Generación y ejecución de programas en ensamblador.
    - Repertorio de instrucciones x86 reducido y habilitado progresivamente.
    - Simulación visual e interactiva de micropasos.
    - Gestión de interrupciones y comunicación con periféricos.
    - Medidas de rendimiento de ejecución de programas.

**Diseño de la Herramienta:** 
    - Considerar la facilidad de uso para estudiantes y profesores.
    - Utilizar gráficos y diagramas para mejorar la comprensión.

**Construcción de la Herramienta:** 
    - Implementar la herramienta siguiendo las especificaciones de diseño.
    - Realizar pruebas exhaustivas para asegurar que la herramienta cumple con todos los requisitos.
    - Solucionar cualquier problema identificado durante las pruebas antes del lanzamiento.

Para cumplir con el segundo objetivo específico, es esencial diseñar y construir una herramienta de apoyo que sea fácil de usar para estudiantes y profesores, cumpliendo con los requisitos definidos, y realizar pruebas rigurosas para asegurar su funcionalidad y usabilidad.

La herramienta debe ofrecer una visión global de la estructura y funcionamiento de la computadora, permitir la generación y ejecución de programas escritos en lenguaje ensamblador, ya sea paso a paso por instrucción o completa, y ofrecer un repertorio de instrucciones x86 reducido donde se habiliten las instrucciones a medida que se desarrolle el contenido en la asignatura. Además, la herramienta debe simular de manera visual e interactiva los micropasos que conlleva el ciclo básico de una instrucción, permitir la gestión básica de interrupciones permitiendo la interacción con el teclado y la pantalla, permitir la comunicación con los módulos de entrada y salida e interacciones con los periféricos, y ofrecer medidas de rendimiento sobre la ejecución de un programa.

Una vez que se hayan definido los requisitos, se puede comenzar a diseñar la herramienta. Se debe tener en cuenta la facilidad de uso para los estudiantes y profesores. La herramienta debe ser intuitiva y fácil de navegar. Se pueden utilizar gráficos y diagramas para ayudar a los estudiantes a comprender mejor la estructura y funcionamiento de la computadora.

Después de diseñar la herramienta, se debe construir y probar. Se deben realizar pruebas exhaustivas para asegurarse de que la herramienta cumpla con todos los requisitos y sea fácil de usar. Si se encuentran problemas durante las pruebas, se deben solucionar antes de lanzar la herramienta.

En resumen, para cumplir con el segundo objetivo específico, se debe diseñar y construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras. La herramienta debe cumplir con los requisitos mencionados anteriormente y debe ser fácil de usar para los estudiantes y profesores. Para lograr esto, se puede comenzar por definir los requisitos de la herramienta, diseñar la herramienta, construir y probar.

## Desarrollo y Pruebas
- **Diseño de la Herramienta:** Comenzar con la definición detallada de los requisitos, seguido de un diseño centrado en la facilidad de uso para estudiantes y profesores. Se utilizarán gráficos y diagramas para mejorar la comprensión.

- **Construcción de la Herramienta:** Implementar la herramienta siguiendo las especificaciones de diseño, asegurando la integridad y funcionalidad de cada componente.

- **Pruebas Exhaustivas:** Realizar pruebas rigurosas para asegurar que la herramienta cumple con todos los requisitos. Las pruebas incluirán:
    - Validación de la funcionalidad completa de la herramienta.
    - Evaluación de la usabilidad por parte de estudiantes y profesores.
    - Identificación y solución de problemas antes del lanzamiento.

## Portabilidad
Para asegurar la portabilidad, el simulador se implementará como una aplicación web que puede ejecutarse en cualquier navegador web, garantizando su uso multiplataforma.

## Simplicidad
La herramienta será diseñada con una interfaz intuitiva y fácil de navegar, minimizando la curva de aprendizaje para los usuarios.

## Mantenibilidad
El código de la herramienta será modular y bien documentado, facilitando futuras actualizaciones y mantenimiento. Además, se implementarán prácticas de desarrollo sostenibles para asegurar su longevidad.

## Escalabilidad
Desde la asignatura se incentiva el uso de simuladores para dar apoyo a los proceso de enseñanza y aprendizaje, pero también se incentiva que los contenidos desarrollados puedan volcarse en máquinas reales, en este sentido consideramos que el enfoque planteado por la herramienta emu8086 es el más adecuado para la asignatura, ya que facilita mecanismos para implementar los programas en máquinas reales. Sin embargo presenta el inconveniente que genera ejecutables dependientes del sistema operativo MS-DOS, la mayoría de los sistemas operativos actuales no permiten la ejecución de dichos programas, obligando a la utilización de emuladores de MS-DOS para poder correrlos, siendo esto otro elemento más que se incorpora a los procesos de enseñanza y aprendizaje. 
Utilizar lenguaje NASM (Netwide Assembler) garantiza soporte tanto para Linux como Windows a través de herramientas libres como GCC (GNU Compiler Collection), generando programas para la arquitectura x86 de 16, 32 y 64 bits.

## Memoria
La memoria contiene 256 posiciones y cada una contiene un byte. Por lo tanto, el bus de direcciones y de datos son de 8 bits. 

## Repertorio de instrucciones propuesto
El repertorio de instrucciones x86 propuesto para facilitar el aprendizaje y la enseñanza de la arquitectura x86 para aquellos que están recién familiarizándose con este conjunto de instrucciones, es un repertorio ficticio basado en la arquitectura x86, para facilitar el aprendizaje se decidió simplificar los conceptos a un repertorio de 8 bits para un mejor entendimiento. Aunque el conjunto de instrucciones real de x86 es mucho más amplio y complejo, este enfoque básico sentará las bases para comprender el formato de instrucciones, los modos de direccionamiento y el ciclo de búsqueda y ejecución.



## Repertorio de instrucciones
El repertorio x86 es reducido (8 bits)


| Instrucciones | Código operación | Acción |
| ----- | ----- | :---- |
|  |  |  |
| **Transferencia de datos**          |   **$\leftarrow$ MOV {0,1,2}** | 0. Copiar entre registros 1. Almacenar en memoria  2. Cargar a registro |
|  |  |  |
| **Procesamiento de datos**       | **\+  ADD {3, 4, 5}**               **\-  SUB {6, 7, 8}**              **\* CMP  {9, 10, 11}** | **Operación aritmética**:  operando1  $\leftarrow$ operando1  OPE operando2  ; actualiza el  destino **Comparación**:  operando1 \- operando2   ;realiza la operación de sustraer pero no actualiza el destino. |
|  |  |  |
| **Control de flujo**       |  **$\uparrow$\ JMP / Jxx /  CALL/ RET {12}** | Salto incondicional JMP Saltos condicionales Jxx Llamadas a rutinas CALL y retorno RET |
|  |  |  |
| **Manejo de pila y E/S**      | **PUSH / POP / OUT / IN {13}** | Poner en la pila PUSH Retirar de la pila POP Enviar un byte al puerto del dispositivo de E/S Recibir un byte del dispositivo de E/S |
|  |  |  |
| **Manejo de interrupción**     | **INT / IRET {14}** | Llamar a una rutina de tratamiento de interrupción INT Retornar de una rutina de tratamiento de interrupción IRET |
|  |  |  |
| **Control del CPU**     |  **NOP / HLT {15}** | No opera NOP Detiene el CPU HLT |


### Formato de la instrucción
|   | Formato instrucción  |  |  |  | Acción |
| ----- | :---: | :---: | :---: | :---: | ----- |
|  | **Código op. byte 1** |  |  |  |  |
|  | **4 bits** | **2 bits** |  | **2 bits** |  |
| **MOV**    | **0** | *rd* |  | *rf* | **Registro a registro**: Copiar entre registros: rd $\leftarrow$ rf   |
|  | **1** |   *{0,1,2,3}* |  | *rf / {0,1, 2}* | ** Registro/valor a memoria**: *mem $\leftarrow$ rf mem\[BL\] $\leftarrow$ rf mem\[Dir + BL\] $\leftarrow$  rf    3.0 mem $\leftarrow$ valor 1 mem\[BL\] $\leftarrow$ valor      3.2 mem\[Dir + BL\] $\leftarrow$ valor*   |
|  | **2** | *rd* |  |   *{0,1,2,3}* | ** Memoria/valor a registro**: *0\. rd $\leftarrow$ mem rd $\leftarrow$ mem\[BL\]  rd $\leftarrow$ mem\[Dir + BL\] rd $\leftarrow$ valor*    |
| **ADD /    SUB /    CMP** |  **{3..11}** | *rd* |  | *rf* | Todas las instrucciones de procesamiento de datos tienen los mismos modos de direccionamiento que la instrucción MOV. Operación aritmética:  **operando1  $\leftarrow$ operando1  OPE operando2**  ; actualiza el  destino Comparación:  **operando1 - *operando2***   ;realiza la operación de sustraer pero no actualiza el destino. Operando2 puede ser registro/memoria/valor inmediato Operando1 puede ser registro o memoria |
|  |  |  |  |  |  |
|  |  | *rr* |  |  |  |
|  |  | *rd* |  | ` |  |
|  **JMP/ Jxx /  CALL / RET**  | **12** |   *{0,1,2,3, 4,5,6,7,8,9,10,11,12,13,14}* |  |  | **saltos/rutinas  *RE: el registro de estado contiene los siguientes flags o banderas: Z \=cero C \= acarreo (Carry) S \= signo (sign) O \= desbordamiento (Overflow) Incondicional: Sin condicional* 0\. JMP:  IP $\uparrow$ IP \+ desp *Condicional: Si se cumple la condición salta* 1\. JZ/JE:  Z \== 1  2\. JNZ/JNE:  Z \== 0  3\. JC:  Si C \== 1 4\. JNC:  Si C \== 0 5\. JS:  Si S \== 1 6\. JNS:  Si S \== 0 7\. JO:  Si O \== 1 8\. JNO:  Si O \== 0 9\. JGE:  Si S \== O   {  (con signo)} 10\. JLE:  Si Z  \== 1 o S \<\> O  { (con signo)} 11\. JAE:  Si C \== 1 {  (sin signo)} 12\. JBE:  Si C \== 1 o Z \== 1 { (sin signo)}                  **Saltar a IP $\uparrow$ IP \+ *desp* Above/Below*: se refiere a valores sin signo.* **Great/Less*: se refiere a valores con signo. Rutinas:*  13\. CALL:  *Memoria\[SP\]  $\uparrow$ IP                     SP$\uparrow$ SP \- 1                        Memoria\[SP\] $\uparrow$ RE                         SP$\uparrow$ SP \- 1                        IP $\uparrow$ \[dirección\]* 14\. RET:    *SP $\uparrow$ SP \+ 1                    RE $\uparrow$  Memoria\[SP\]                      SP $\uparrow$ SP \+1                       IP $\uparrow$  Memoria\[SP\]*  |
| **PUSH /  POP /  OUT / IN** | **13** | *{0,1, 2, 3}* |  | *rf/rd* | **Pila y E/S *0\.* PUSH *rf:  Memoria\[SP\]  $\uparrow$ rf                      SP $\uparrow$ SP \- 1 1\.* POP *rd:   SP $\uparrow$ SP \+ 1                      rd $\uparrow$  Memoria\[SP\]    2\.* E/S\[puerto\] $\uparrow$ DL    *3\.* DL $\uparrow$E/S\[puerto\] |
|  |  |  |  |  |  |
| **INT / IRET** | **14** |  |  *ID\_INT / \-* |  |  **Interrupción  *0\.* INT Nro\_INT*:  Memoria\[SP\]  $\uparrow$ IP                               SP $\uparrow$ SP \- 1                                  Memoria\[SP\] $\uparrow$ RE                               SP $\uparrow$ SP \- 1                                  IP $\uparrow$ \[dirección\]                                  IP $\uparrow$ Vector\_Interrupción\[ID\_INT\]                                  STI (Setear flag interrupción)*  *1\.* IRET*:   SP $\uparrow$ SP \+ 1                 RE $\uparrow$  Memoria\[SP\]                   SP $\uparrow$ SP \+1                   IP $\uparrow$  Memoria\[SP\]                   CLI (restablecer flag interrupción)* |
|  |  |  |  |  |  |
| **NOP /  HLT** | **15** | *\-* |  | **{0,1} | ** Control *0\.* NOP*:   IP $\uparrow$ IP \+ 1  1\.* HLT*:   Detiene el CPU*           |



### Registros (Banco de Registros)

| Números de registros (r)  |  |  |
| :---: | :---: | :---: |
| **registro** | **binario** | **decimal** |
| AL | 00 | 0 |
| BL | 01 | 1 |
| CL | 10 | 2 |
| DL | 11 | 3 |


### Modos de direccionamientos

Los siguientes tipos de direccionamiento son utilizados en las instrucciones de esta CPU para referenciar a los operandos involucrados en la instrucción:

* Registro a registro: los operandos de la instrucción son registros.  
* Directo: en la instrucción se indica la dirección de memoria en la que está contenido el operando.  
* Indirecto: dirección de memoria donde está el operando viene determinada por el contenido del registro BL  
* Inmediato: el operando fuente de la instrucción es un valor contenido en la misma instrucción.   


La mayoría de las instrucciones básicas tienen solo las siguientes formas:

* **MOV *reg, reg***  
* **MOV *reg, mem***  
* **MOV *reg, inm***  
* **MOV *mem, reg***  
* **MOV *mem, inm***

### Transferencia MOV (COPIAR)

MOV d, f

Tipo de operandos d y f: pueden ser registros, dirección de memoria, dirección indirecta por registro (BL) o valor. El operando valor no puede ser destino.

rf: registro fuente
rd: registro destino

Los 4 primeros bits de la instrucción se descompone en:
Código operación 3 bis y 1 bit se corresponde al tipo de destino, si es cero representa registro y si es 1 representa memoria.

Formato instrucción MOV	Ejemplo	Acción	Direccionamiento





### Ciclo de la instrucción (Etapas de captación y ejecución)

#### Captación
    1.	MAR = IP 
    2.	MDR = read(Memoria[MAR])
        IP = IP + 1
    3.	IR  = MDR

#### Ejecución
Instrucciones	Operación	Nemónico	Acción
Transferencia de datos        	 Mover	MOV od, of	Copiar: operando-destino (od)   operando-fuente (of)

Procesamiento de datos      	+  Sumar  
- Restar
Comparar 	ADD  od, of
SUB   od, of
CMP  od, of  	od = od + of  
od  od - of  
od - of  

Control de flujo	 Salto incondicional 
 Salto condicional
 Detener 	JMP  d
Jxx    d
HLT 	Salto incondicional a dirección destino (d). 
Saltos condicionales en base a las banderas (flags) a d.
Detiene el CPU.

#### Formato de Instrucciones y modos de direccionamiento
El formato de las instrucciones propuesto para la enseñanza de la arquitectura es una simplificación de la arquitectura x86, siendo este último un set CISC (conjunto de repertorio de instrucciones complejas) las instrucciones tienen diferente tamaño para poder aplicar estos conceptos a la enseñanza se representa un repertorio de instrucciones simplificado, podemos clasificar las instrucciones según los modos de direccionamientos que indica de donde proviene un operando:
Operando	tipo
r	Registros del CPU
[d]	Contenido de la dirección de memoria
i	Valor inmediato
[r]	Contenido de la dirección de memoria dada por el registro

## Procesador `VonSim8`

`VonSim8` es un procesador diseñado e implementado sobre la herramienta *Logisim*.
Este cuenta con las siguientes características:

| Arquitectura CPU | **Características** |
| --- | --- |
| | - Arquitectura *von Neumann*, memoria de datos e instrucciones compartida. |
| | - 8 registros de propósito general, `R0` a `R7`. |
| | - 1 registro de propósito específico `IP`. |
| | - Tamaño de palabra de 8 bits e instrucciones de 16 bits. |
| | - Memoria de 256 palabras de 8 bits. |
| | - Bus de 8 bits. |
| | - Diseño microprogramado. |

## Instrucciones

Las instrucciones están codificadas en 16 bits. Los primeros 5 bits identifican el `opcode` de la instrucción, el resto de los bits indican los parámetros. Existen 4 posibles codificaciones de parámetros.

| Caso | Codificación | Parámetros |
| --- | --- | --- |
| A | `OOOO XXYY-----` | `XX` = Registro X, `YY` = Registro Y o inmediato |
| B | `OOOO XX--------` | `XX` = Registro X |
| C | `OOOO ---MMMMMMMM` | `MMMMMMMM` = Dirección de memoria o Inmediato |
| D | `OOOO XXMMMMMMMM` | `XXX` = Registro X, `MMMMMMMM` = Dir. de memoria o Imm. |

Considerando:

- `Rx` o `Ry`: Índices de registros, número entre `0` y `7`.
- `M`: Dirección de memoria o valor inmediato, número de 8 bits.
- `t`: Valor inmediato de desplazamiento, número entre `0` y `7`. Se codifica como `YYY`.
- En la columna de codificación, los bits indicados con `-` son reservados y deben valer cero.
- Las instrucciones de `opcode`: 9, 10, 11, 12, 13, 14, 15, 28, 29 y 30 son instrucciones reservadas.

Las instrucciones soportadas por la arquitectura son las siguientes:

| Instrucción            | Acción                                                             | Codificación               |
| ---                    | ---                                                                | ---                        |
| `ADD  Rx, Ry`          | `Rx` $\leftarrow$ `Rx + Ry`                                        | `00001 XXXYYY-----`        |
| `SUB  Rx, Ry`          | `Rx` $\leftarrow$ `Rx - Ry`                                        | `00011 XXXYYY-----`        |
| `CMP  Rx, Ry`          | Modifica *flags* de `Rx - Ry`                                      | `00111 XXXYYY-----`        |
| `MOV  Rx, Ry`          | `Rx` $\leftarrow$ `Ry`                                             | `01000 XXXYYY-----`        |
| `MOV  [M], Rx`         | `Mem[M]` $\leftarrow$ `Rx`                                         | `10000 XXXMMMMMMMM`        |
| `MOV Rx, [M]`          | `Rx` $\leftarrow$ `Mem[M]`                                         | `10001 XXXMMMMMMMM`        |
| `MOV  [Rx], Ry`        | `Mem[Rx]` $\leftarrow$ `Ry`                                        | `10010 XXXYYY-----`        |
| `MOV Rx, [Ry]`         | `Rx` $\leftarrow$ `Mem[Ry]`                                        | `10011 XXXYYY-----`        |
| `JMP M`                | `PC` $\leftarrow$ `M`                                              | `10100 ---MMMMMMMM`        |
| `JC M`                 | Si `flag C=1` entonces `PC` $\leftarrow$ `M`                       | `10101 ---MMMMMMMM`        |
| `JZ M`                 | Si `flag Z=1` entonces `PC` $\leftarrow$ `M`                       | `10110 ---MMMMMMMM`        |


Las instrucciones soportadas por la arquitectura son las siguientes:

## Assembler
| # | Mnemonics              | Action                       |
| - | ---------------------- | ---------------------------- |
| 0 | `MOV Rx, Ry`           | `Ra = Rb`                    |
| 1 | `ADD Rx, Ry`           | `Ra += Rb`                   |
| 2 | `SUB Rx, Ry`           | `Ra -= Rb`                   |
| 3 | `CMP Rx, Ry`           | `Ra -= Rb`                   |
| 4 | `MOV Rx, [Rb]`         | `Ra = Mem[Rb]`               |
| 5 | `MOV [Rb], Rx`         | `Mem[Rb] = Ra`               |
| 7 | `INP Ra`               | `Ra = Inp`                   |
| 8 | `JEQ Ra, value\|label` | `PC = value\|label, Ra == 0` |
| 9 | `JNE Ra, value\|label` | `PC = value\|label, Ra != 0` |
| a | `JGT Ra, value\|label` | `PC = value\|label, Ra > 0`  |
| b | `JLT Ra, value\|label` | `PC = value\|label, Ra < 0`  |
| c | `MOV Ra, value\|label` | `Ra = Mem[value\|label]`     |
| d | `MOV value\|label, Ra` | `Mem[value\|label] = Ra`     |
| e | `MOV Ra, value\|label` | `Ra = value\|label`          |
| f | `JMP value\|label`     | `PC = value\|label`          |

## Registros
| ## | Name | Description                   |
| -- | ---- | ----------------------------- |
| 00 | R0   | User data                     |
| 01 | R1   | User data                     |
| 10 | R2   | User data (output pins A0-A7) |
| 11 | R3   | User data (output pins B0-B7) |


## Componentes

La arquitectura está compuesta por 6 componentes interconectados. El circuito identificado como `microOrgaSmall` los integra en un `dataPath` sobre el lado izquierdo del mismo. El lado derecho presenta la visualización del estado de los registros.

Los componentes de la arquitectura son: `Registers` (Banco de Registros), `PC` (Contador de Programa), `ALU` (Unidad Aritmético Lógica), `Memory` (Memoria), `Decode` (Decodificador de Instrucciones) y `ControlUnit` (Unidad de Control).

Cada uno de estos componentes es controlado por medio del conjunto de entradas y salidas descritas a continuación:

## Ejecución de Instrucciones

Las instrucciones en `OrgaSmall` se ejecutan en varios ciclos de reloj, donde cada ciclo implica una acción específica. A continuación, se describe la secuencia de acciones para la ejecución de las instrucciones de la arquitectura.

1. **Ciclo de Búsqueda**: 
   - `IP` se copia en el `MAR`.
   - `Memory` coloca la instrucción en el `MBR`.
   - `PC` incrementa su valor.
   - `MBR` se copia en el `IR`.

2. **Ciclo de Ejecución**:
   - `ControlUnit` interpreta el `opcode` y emite señales correspondientes a los componentes para ejecutar la instrucción.
   - `ALU` realiza la operación aritmética o lógica.
   - `Registers` y `Memory` realizan operaciones de lectura/escritura según sea necesario.

Este flujo se repite para cada instrucción, permitiendo la ejecución de programas complejos en la arquitectura `OrgaSmall`.
