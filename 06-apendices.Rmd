# Apéndices {#apendices}

## Anexo A: Protocolo de Entrevista Semiestructurada  {#anexoA}

**Objetivo:**  
Relevar necesidades, experiencias y percepciones de docentes especializados en la enseñanza de Arquitectura de Computadoras, con el fin de fundamentar los requisitos funcionales y pedagógicos de una herramienta de simulación orientada a la arquitectura x86.

**Tipo de entrevista:** Semiestructurada  
**Duración estimada:** 45–60 minutos  
**Participantes:** Docentes universitarios con experiencia en la enseñanza de asignaturas vinculadas a Arquitectura de Computadoras  
**Modo de registro:** Grabación de audio (previo consentimiento informado) y notas del entrevistador

### Introducción (a cargo del entrevistador)

- Breve presentación personal y del objetivo de la entrevista.
- Explicación sobre la confidencialidad de los datos.
- Solicitud de consentimiento para grabar la entrevista.
- Aclaración sobre la posibilidad de no responder a alguna pregunta o interrumpir la entrevista en cualquier momento.

### Datos generales del entrevistado

- **Universidad o institución en la que trabaja:**
- **Asignatura(s) que dicta relacionadas con arquitectura de computadoras:**
- **Años de experiencia docente en el área:**
- **Nivel en el que dicta la asignatura:** (Grado, Posgrado, Técnico, Otro)

### Preguntas principales

#### A. Enseñanza y dificultades

- ¿Cuáles considera que son los principales desafíos que enfrentan los estudiantes al aprender los conceptos de arquitectura de computadoras?
- ¿Qué contenidos o temas observa que generan mayores dificultades de comprensión?
- ¿Cómo aborda actualmente la enseñanza del lenguaje ensamblador y el ciclo de instrucción?

#### B. Experiencia con herramientas de simulación

- ¿Utiliza o ha utilizado herramientas de simulación en sus clases? ¿Cuáles?
- ¿Qué ventajas ha encontrado en el uso de estas herramientas?
- ¿Qué limitaciones o dificultades ha identificado en las herramientas actualmente disponibles?

#### C. Requisitos deseables en una herramienta

- En su opinión, ¿qué funcionalidades debería tener una herramienta de simulación para ser útil en el proceso de enseñanza?
- ¿Considera importante que la herramienta incluya visualizaciones gráficas del ciclo de instrucción o del flujo de datos entre componentes?
- ¿Cree que el soporte para interrupciones y periféricos (por ejemplo, teclado o pantalla) aporta valor al aprendizaje?
- ¿Considera que la posibilidad de activar progresivamente instrucciones del repertorio x86 según el avance del curso puede beneficiar el proceso de enseñanza-aprendizaje?
- ¿Qué importancia le asigna a la incorporación de métricas de rendimiento (como ciclos por instrucción, tiempo de CPU, etc.) en una herramienta educativa?

#### D. Interfaz y accesibilidad

- ¿Qué aspectos de la interfaz considera prioritarios en una herramienta pensada para estudiantes?
- ¿Debería contemplarse la accesibilidad para personas con discapacidad? ¿De qué forma?

### Cierre

- ¿Desea agregar algo más que no hayamos preguntado?
- Agradecimiento por el tiempo y colaboración.

**Nota:** El análisis posterior de las entrevistas será realizado de manera confidencial y con fines exclusivamente académicos.

## Anexo B: Instrumentos de recolección de datos  {#anexoB}

En este anexo se presentan los instrumentos empleados para la validación pedagógica del simulador VonSim8. Se incluyen encuestas, pruebas objetivas, guía de entrevistas y plantilla de registro de uso, con sus respectivos ítems, escalas y pautas de codificación. Las encuestas y pruebas se aplican en dos momentos (pre y post) para medir la ganancia de aprendizaje.

### 1) Encuesta de retroalimentación – Unidad ciclo de instrucción y simulador VonSim8 estudiantes

#### Sección 1: Experiencia previa

1. Antes de esta unidad, ¿qué tanto conocías el ciclo de instrucción?
2. ¿Habías usado simuladores educativos de este tipo antes?  

#### Sección 2: Calidad del material didáctico

**(Escala 1–5: 1 = Totalmente en desacuerdo, 5 = Totalmente de acuerdo)**
3. La explicación de las etapas de captación (fetch) y ejecución (execute) fue clara.
4. Los ejemplos con instrucciones (MOV, ADD, SUB, JMP) me ayudaron a entender las microoperaciones.
5. La explicación de los modos de direccionamiento (inmediato, directo, indirecto, entre registros) fue suficiente y comprensible.
6. Las actividades propuestas (análisis, ejercicios, simulaciones) me ayudaron a consolidar los conceptos.
7. Las tablas, esquemas e imágenes del material fueron útiles para mi aprendizaje.

#### Sección 3: Valor del simulador VonSim8

**(Escala 1–5: 1 = Totalmente en desacuerdo, 5 = Totalmente de acuerdo)**
8. El simulador me permitió visualizar con claridad los cambios en registros y memoria durante la ejecución de los programas.
9. El simulador facilitó la conexión entre la teoría y la práctica.
10. El simulador es intuitivo y fácil de usar.
11. Ver las microoperaciones y los componentes internos en el simulador mejoró mi comprensión del ciclo de instrucción.

#### Sección 4: Reflexión y sugerencias

**(Respuesta abierta, párrafo largo)**
12. ¿Cuál fue el aspecto más útil o interesante de la unidad (material o simulador)?
13. ¿Qué parte del material o del simulador te resultó más confusa o difícil?
14. Después de completar esta unidad, ¿cuánto sientes que mejoraron tus conocimientos sobre el ciclo de instrucción?
Gracias por tu tiempo. Tus respuestas sinceras nos ayudarán a mejorar esta unidad y el simulador VonSim8 para futuros estudiantes.

### 2) Entrevista semiestructurada a docentes sobre el simulador VonSim

**Objetivo:**  
Recoger valoraciones cualitativas de los docentes sobre la calidad del material didáctico y la utilidad del simulador VonSim8 en la enseñanza del ciclo de instrucción y conceptos relacionados con la arquitectura de computadoras.

#### Sección 1: Experiencia previa

   1. ¿Cuánto tiempo llevas enseñando temas relacionados con la arquitectura de computadoras?

   2. ¿Has utilizado simuladores educativos en tus clases anteriormente? Si es así, ¿cuáles y cómo ha sido tu experiencia con ellos?

   3. Antes de utilizar el simulador VonSim8, ¿qué tan familiarizado/a estabas con el ciclo de instrucción y los conceptos relacionados?

#### Sección 2: Calidad del material didáctico

   4. ¿Cómo evalúas la claridad y completitud de las explicaciones proporcionadas en el material didáctico sobre las etapas del ciclo de instrucción (captación y ejecución)?

   5. ¿Consideras que las tablas, esquemas e imágenes del material son útiles para enseñar conceptos abstractos como modos de direccionamiento y microoperaciones? ¿Por qué?

   6. ¿Qué opinas de los ejemplos prácticos (MOV, ADD, SUB, JMP) incluidos en el material? ¿Crees que son adecuados para ilustrar las microoperaciones y el flujo de datos?

   7. ¿El material didáctico permite a los estudiantes conectar la teoría con la práctica de manera efectiva? ¿Podrías dar un ejemplo?

   8. ¿Qué opinas de las actividades propuestas (análisis, ejercicios, simulaciones)? ¿Crees que son apropiadas para consolidar los conceptos clave?

#### Sección 3: Valor del simulador VonSim8

   9. ¿Cómo evalúas la capacidad del simulador para facilitar la visualización de los cambios en registros y memoria durante la ejecución de los programas?

   10. ¿Crees que el simulador ayuda a los estudiantes a comprender mejor el ciclo de instrucción y las microoperaciones? ¿Por qué?

   11. ¿Qué opinas de la representación gráfica del flujo de datos y las señales de control en el simulador? ¿Es clara y didáctica?

   12. ¿Cómo describirías la interfaz del simulador? ¿Es intuitiva y fácil de usar para los estudiantes?

   13. ¿Consideras que la activación progresiva del repertorio de instrucciones es útil para evitar la sobrecarga cognitiva en los estudiantes? ¿Por qué?

   14. ¿Qué tan útiles consideras las métricas de rendimiento (CPI, tiempo de CPU, etc.) para enseñar conceptos relacionados con la eficiencia del procesador?

#### Sección 4: Reflexión y sugerencias

**(Respuesta abierta, párrafo largo)**

   15. ¿Qué aspectos del simulador VonSim8 consideras más útiles para la enseñanza del ciclo de instrucción y la arquitectura de computadoras?

   16. ¿Qué aspectos del simulador o del material didáctico crees que podrían mejorarse?

   17. ¿Cómo percibes el impacto del simulador en la motivación y comprensión de los estudiantes?

   18. ¿Recomendarías el uso del simulador VonSim8 en otros cursos o contextos educativos? ¿Por qué?

## Anexo C: Análisis de los resultados {#anexoC}

### Encuesta de retroalimentación estudiantes

La encuesta de retroalimentación sobre la unidad **Ciclo de Instrucción y simulador VonSim8** fue respondida por un total de 14 estudiantes. El objetivo de este instrumento fue evaluar la claridad de los contenidos teóricos, la calidad del material didáctico, la utilidad del simulador y el impacto percibido en el aprendizaje. A continuación, se presenta un análisis detallado de los resultados obtenidos.

1. Experiencia previa de los estudiantes

En cuanto al conocimiento inicial sobre el ciclo de instrucción, el 64,3 % de los estudiantes manifestó poseer poco o nulo conocimiento, mientras que el 35,7 % indicó tener un nivel moderado o alto. Estos resultados reflejan que la mayoría de los participantes partía de una base conceptual limitada, lo que justifica la necesidad de incluir actividades introductorias y recursos visuales que faciliten la comprensión de los conceptos fundamentales.

Respecto al uso de simuladores educativos, el 64,3 % de los estudiantes indicó no haber utilizado previamente herramientas de este tipo. Este dato evidencia que el simulador VonSim8 representó una experiencia novedosa para la mayoría del grupo, lo que pone en relieve la importancia de una guía docente clara y materiales de apoyo que orienten su uso.

2. Valoración del material didáctico

Los resultados obtenidos muestran una valoración positiva del material teórico y de las actividades propuestas. Los promedios de calificación fueron los siguientes:

```{r tablaaspectos, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear los datos de la tabla
aspectos <- data.frame(
  `Aspecto evaluado` = c(
    "Claridad de los conceptos teóricos (fetch/execute)",
    "Ejemplos con instrucciones (MOV, ADD, SUB, JMP)",
    "Explicación de los modos de direccionamiento",
    "Actividades (análisis, ejercicios, simulaciones)",
    "Tablas, esquemas e imágenes"
  ),
  Promedio = c(3.86, 4.07, 4.14, 4.07, 4.21),
  Interpretación = c(
    "Buena comprensión general, aunque con margen de mejora en la claridad conceptual.",
    "Los ejemplos prácticos facilitaron la comprensión de las microoperaciones.",
    "Los estudiantes valoraron positivamente la claridad en la exposición de estos conceptos.",
    "Las actividades fueron percibidas como útiles para consolidar los aprendizajes.",
    "Los recursos visuales fueron altamente valorados como apoyo al aprendizaje."
  )
)

# Crear la tabla con formato dinámico
tabla <- kable(aspectos,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Valoración de aspectos clave del simulador VonSim8",
               col.names = c("Aspecto evaluado", "Promedio", "Interpretación"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("l", "c", "l"))

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "2cm") %>%
    column_spec(3, width = "8cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(aspectos)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas

} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "20em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "10em") %>%
    column_spec(3, width = "30em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

En conjunto, estos resultados evidencian un alto grado de satisfacción con el material didáctico, destacándose especialmente los recursos visuales y los ejemplos aplicados como elementos clave para la comprensión de los contenidos.

3. Valoración del simulador VonSim8

El uso del simulador VonSim8 fue valorado de manera positiva, aunque con ciertos aspectos a mejorar. Los resultados fueron los siguientes:

```{r tablaevaluacion, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear los datos de la tabla
evaluacion <- data.frame(
  `Aspecto evaluado` = c(
    "Visualización de registros y memoria",
    "Conexión entre teoría y práctica",
    "Facilidad de uso e intuición",
    "Visualización de microoperaciones"
  ),
  Promedio = c(3.79, 4.14, 3.93, 3.57),
  Interpretación = c(
    "Buena valoración general, aunque algunos estudiantes señalaron dificultades para interpretar los cambios mostrados.",
    "El simulador facilitó la aplicación práctica de los contenidos teóricos.",
    "El simulador fue percibido como accesible y comprensible, aunque se sugiere optimizar la interfaz.",
    "Aspecto menos valorado, posiblemente por la complejidad visual o falta de familiaridad inicial."
  )
)

# Crear la tabla con formato dinámico
tabla <- kable(evaluacion,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Evaluación de aspectos clave del simulador VonSim8",
               col.names = c("Aspecto evaluado", "Promedio", "Interpretación"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "l", "l"))

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "3cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "5cm") %>%
    column_spec(3, width = "6cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(evaluacion)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas

} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "20em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "15em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Los resultados indican que el simulador cumplió adecuadamente su función pedagógica, ayudando a los estudiantes a comprender los procesos internos del procesador. No obstante, se observan oportunidades de mejora en la representación visual de las microoperaciones y en la claridad de las animaciones.

4. Análisis cualitativo de las respuestas abiertas
Aspectos más útiles o interesantes

Los estudiantes destacaron como elementos más valiosos:

   - La posibilidad de visualizar paso a paso la ejecución de instrucciones dentro del ciclo de instrucción.

   - La observación directa de los cambios en los registros y la memoria durante la ejecución.

   - La comprensión del funcionamiento interno del procesador y de las microoperaciones.

   - El carácter práctico e intuitivo del simulador y las actividades de aplicación.

**Aspectos más difíciles o confusos**

Entre las principales dificultades mencionadas se encuentran:

   - El funcionamiento de las banderas (flags) y su activación durante la ejecución.

   - La lectura y escritura en memoria, particularmente las animaciones del simulador.

   - El lenguaje ensamblador y las instrucciones de salto (JMP).

   - La interpretación de las microoperaciones, percibida por algunos como rápida o poco clara.

Estos comentarios sugieren que, si bien el contenido teórico fue bien comprendido, ciertos detalles técnicos del simulador requieren explicaciones adicionales o recursos interactivos complementarios.

5. Impacto percibido en el aprendizaje

En la pregunta final, donde se consultó cuánto mejoraron sus conocimientos sobre el ciclo de instrucción, los estudiantes otorgaron un promedio de 4.00/5.
Esto refleja que la mayoría percibió una mejora significativa en su comprensión del tema, atribuida a la combinación entre el material teórico, las actividades prácticas y el uso del simulador VonSim8.

6. Conclusiones generales

Los resultados de la encuesta permiten concluir que la experiencia educativa fue altamente positiva, tanto en lo pedagógico como en el uso de la tecnología. El diseño de la unidad, basado en la combinación de teoría, práctica y simulación, favoreció el aprendizaje significativo del ciclo de instrucción.

El simulador VonSim8 se consolidó como una herramienta didáctica eficaz para vincular los conceptos teóricos con su aplicación práctica, permitiendo a los estudiantes observar de forma dinámica el comportamiento de los registros, la memoria y las microoperaciones.
Sin embargo, se identificaron áreas de mejora relacionadas con la claridad de las animaciones, la representación de las banderas y la comprensión de la memoria.

En síntesis, los resultados confirman que la implementación del simulador VonSim8 y el enfoque didáctico adoptado contribuyen de manera efectiva al desarrollo de competencias conceptuales y procedimentales en el estudio de la arquitectura de computadoras.

### Entrevistas a docentes
Las entrevistas semiestructuradas realizadas a dos docentes especializados en la enseñanza de Arquitectura de Computadoras tuvieron como objetivo relevar sus percepciones, experiencias y necesidades en relación con el uso de herramientas de simulación, particularmente el simulador VonSim8. A continuación, se presenta un análisis detallado de los resultados obtenidos.

1. Experiencia previa de los docentes

Ambos docentes entrevistados cuentan con una amplia experiencia en la enseñanza de temas relacionados con la arquitectura de computadoras, destacando un promedio de más de 10 años en el área. En cuanto al uso de herramientas de simulación, ambos participantes indicaron haber utilizado previamente simuladores como Emu8086, Simple 8-bit Assembler Simulator y VonSim, aunque señalaron limitaciones en las herramientas existentes, como interfaces poco intuitivas y falta de soporte para funcionalidades avanzadas.

2. Valoración del material didáctico

Los docentes evaluaron positivamente el material didáctico asociado al simulador VonSim8, destacando los siguientes aspectos:

```{r tablaevaluaciondocentes, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear los datos de la tabla
evaluacion_docentes <- data.frame(
  `Aspecto evaluado` = c(
    "Claridad de las explicaciones teóricas",
    "Utilidad de los recursos visuales",
    "Ejemplos prácticos (MOV, ADD, SUB, JMP)",
    "Actividades propuestas"
  ),
  Promedio = c(4.20, 4.50, 4.30, 4.10),
  Interpretación = c(
    "Las explicaciones sobre el ciclo de instrucción fueron consideradas claras y completas.",
    "Las tablas, esquemas e imágenes fueron altamente valoradas como apoyo al aprendizaje.",
    "Los ejemplos facilitaron la conexión entre teoría y práctica.",
    "Las actividades fueron percibidas como útiles para consolidar los conceptos clave."
  )
)

# Crear la tabla con formato dinámico
tabla <- kable(evaluacion_docentes,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Evaluación de aspectos clave por los docentes",
               col.names = c("Aspecto evaluado", "Promedio", "Interpretación"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c"))

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "5.5cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(evaluacion_docentes)),
             extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "10em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "32em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

En conjunto, los docentes destacaron la calidad del material didáctico, especialmente los recursos visuales y los ejemplos prácticos, como elementos clave para la enseñanza.

3. Valoración del simulador VonSim8

El simulador VonSim8 fue valorado de manera positiva por los docentes, quienes resaltaron su utilidad pedagógica y su capacidad para facilitar la comprensión de conceptos complejos. Los resultados fueron los siguientes:

```{r, echo=FALSE, out.width = "100%", fig.cap="Evaluación del simulador educativo"}
library(knitr)
library(kableExtra)

# Crear la tabla de datos
tabla <- data.frame(
  "Aspecto evaluado" = c(
    "Visualización de registros y memoria",
    "Conexión entre teoría y práctica",
    "Facilidad de uso e intuición",
    "Representación gráfica del flujo de datos"
  ),
  "Promedio" = c(4.00, 4.40, 3.90, 4.10),
  "Interpretación" = c(
    "Buena valoración general, aunque se sugieren mejoras en la claridad de las animaciones.",
    "El simulador fue considerado eficaz para vincular los conceptos teóricos con su aplicación práctica.",
    "Aunque accesible, algunos docentes sugirieron optimizar la interfaz para estudiantes principiantes.",
    "La representación gráfica fue valorada como clara y didáctica, aunque con margen de mejora en detalles técnicos."
  )
)

# Crear la tabla con formato dinámico
tabla_kable <- kable(tabla,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Evaluación del simulador educativo",
               col.names = c("Aspecto evaluado", "Promedio", "Interpretación"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("l", "c", "l"))

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "2cm") %>%
    column_spec(3, width = "8cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tabla)),
             extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "20em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "5em") %>%
    column_spec(3, width = "30em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Los docentes coincidieron en que el simulador cumple adecuadamente su función pedagógica, aunque identificaron oportunidades de mejora en la interfaz y en la representación de microoperaciones.

4. Análisis cualitativo de las respuestas abiertas

**Aspectos más útiles o interesantes**

Los docentes destacaron como elementos más valiosos del simulador:

   - La visualización gráfica del ciclo de instrucción y el flujo de datos entre componentes.
   - La posibilidad de activar progresivamente instrucciones del repertorio x86, evitando la sobrecarga cognitiva.
   - La conexión entre teoría y práctica, facilitada por las simulaciones interactivas.

**Aspectos más difíciles o confusos**

Entre las principales dificultades mencionadas se encuentran:

   - La representación de las banderas (flags) y su activación durante la ejecución.
   - La claridad de las animaciones en la lectura y escritura de memoria.
   - La necesidad de mejorar la accesibilidad de la interfaz para estudiantes con poca experiencia.

Estos comentarios sugieren que, aunque el simulador es efectivo, ciertos detalles técnicos y de diseño requieren ajustes para optimizar su uso en el aula.

5. Impacto percibido en la enseñanza

Los docentes coincidieron en que el simulador VonSim8 tiene un impacto positivo en la enseñanza, destacando su capacidad para:

   - Mejorar la comprensión de conceptos abstractos como el ciclo de instrucción y las microoperaciones.
   - Incrementar la motivación de los estudiantes al ofrecer una experiencia práctica e interactiva.
   - Facilitar la enseñanza de temas avanzados como interrupciones y periféricos.

6. Conclusiones generales

Los resultados de las entrevistas permiten concluir que el simulador VonSim8 es una herramienta didáctica eficaz, valorada positivamente por los docentes por su capacidad para vincular teoría y práctica, y por su enfoque progresivo en la enseñanza de la arquitectura x86. Sin embargo, se identificaron áreas de mejora relacionadas con la interfaz, la representación de banderas y la claridad de las animaciones.

En síntesis, el simulador VonSim8 y el material didáctico asociado contribuyen de manera significativa al desarrollo de competencias conceptuales y procedimentales en el estudio de la arquitectura de computadoras, consolidándose como un recurso valioso para la enseñanza en este campo.


## Anexo D: Resultados de simulación xdevs {#anexoD}
Este anexo documenta la implementación del modelo DEVS del simulador VonSim8 desarrollado con la biblioteca xdevs.py (Python), así como los resultados experimentales obtenidos durante la ejecución de la instrucción MOV AL, BL.
El objetivo es proporcionar evidencia empírica que respalde la validación del modelo teórico presentado en el Capítulo 5, sección “Modelado con xDEVS del ciclo de instrucción MOV AL, BL”.

El código fuente completo se encuentra disponible en el repositorio público:
xdevs-vonsim8^[Repositorio: https://github.com/ruiz-jose/xdevs-vonsim8
].

```{python, eval=FALSE, tidy=TRUE, tidy.opts=list(width.cutoff=60)}
from xdevs.models import Atomic, Coupled, Port
from xdevs.sim import Coordinator


# ======================================================
# MODELOS ATÓMICOS: Registros y componentes individuales
# ======================================================

class SharedBus(Atomic):
    """
    Modelo atómico para el bus compartido.
    Garantiza acceso exclusivo mediante señales de control y 
    modela el retardo tau_bus.
    """
    
    def __init__(self, name: str = "BUS"):
        super().__init__(name)
        self.current_value: int = 0x00
        self.locked: bool = False
        self.requester: str = ""
        
        # Puertos de arbitraje
        self.req = Port(str, name="req") 
        # Identificador del componente solicitante
        self.add_in_port(self.req)
        self.grant = Port(bool, name="grant")
        self.add_out_port(self.grant)
        
        # Puertos de datos
        self.data_in = Port(int, name="data_in")
        self.add_in_port(self.data_in)
        self.data_out = Port(int, name="data_out")
        self.add_out_port(self.data_out)
        
        # Puerto de release
        self.release = Port(bool, name="release")
        self.add_in_port(self.release)
        
        self.pending_grant = False
        self.pending_data = False
    
    def initialize(self):
        self.passivate()
    
    def deltext(self, e: float):
        self.continuef(e)
        
        # Solicitud de acceso al bus
        if self.req and not self.req.empty():
            if not self.locked:
                self.requester = self.req.get()
                self.locked = True
                self.pending_grant = True
                self.hold_in("GRANTING", 1)  # tau_bus = 1 ciclo
        
        # Liberación del bus
        if self.release and not self.release.empty():
            if self.release.get():
                self.locked = False
                self.requester = ""
        
        # Recepción de datos
        if self.data_in and not self.data_in.empty():
            self.current_value = self.data_in.get() & 0xFF
            self.pending_data = True
            self.activate()
    
    def deltint(self):
        if self.pending_grant:
            self.pending_grant = False
        if self.pending_data:
            self.pending_data = False
        self.passivate()
    
    def lambdaf(self):
        if self.pending_grant:
            self.grant.add(True)
        if self.pending_data:
            self.data_out.add(self.current_value)
    
    def exit(self):
        pass


class Register(Atomic):
    """Modelo atómico genérico para un registro de 8 bits con
     señales indexadas."""
    
    def __init__(self, name: str, initial_value: int = 0x00):
        super().__init__(name)
        self.value: int = initial_value
        self.reg_name: str = name  
        # Nombre del registro (AL, BL, CL, DL)
        
        # Puertos de entrada/salida
        self.data_in = Port(int, name="data_in")
        self.add_in_port(self.data_in)
        self.enable_in = Port(str, name="enable_in")  
        # Recibe nombre de registro
        self.add_in_port(self.enable_in)
        self.enable_out = Port(str, name="enable_out") 
        # Recibe nombre de registro
        self.add_in_port(self.enable_out)
        
        self.data_out = Port(int, name="data_out")
        self.add_out_port(self.data_out)
        
        self.pending_write = False
        self.pending_read = False
        self.pending_value = 0x00
    
    def initialize(self):
        self.passivate()
    
    def deltext(self, e: float):
        self.continuef(e)
        
        # Capturar dato entrante (puede llegar antes del enable_in)
        if self.data_in and not self.data_in.empty():
            self.pending_value = self.data_in.get() & 0xFF
        
        # Procesar señales de habilitación indexadas
        if self.enable_in and not self.enable_in.empty():
            target_reg = self.enable_in.get()
            # Solo actuar si la señal es para este registro
            if target_reg == self.reg_name:
                self.pending_write = True
                self.activate()
        
        if self.enable_out and not self.enable_out.empty():
            target_reg = self.enable_out.get()
            # Solo actuar si la señal es para este registro
            if target_reg == self.reg_name:
                self.pending_read = True
                self.activate()
    
    def deltint(self):
        if self.pending_write:
            self.value = self.pending_value
            print(f"  [{self.name}] delta_int: Escritura completada.
            Valor={self.value:02X}")
            self.pending_write = False
        
        if self.pending_read:
            print(f"  [{self.name}] delta_int: Lectura completada.
             Valor={self.value:02X}")
            self.pending_read = False
        
        self.passivate()
    
    def lambdaf(self):
        if self.pending_read:
            print(f"  [{self.name}] lambda: Emitiendo dato
            ={self.value:02X} por data_out")
            self.data_out.add(self.value)
    
    def exit(self):
        pass


class SimpleRegister(Atomic):
    """Modelo atómico para registros simples (MBR, IR) con señales
     booleanas."""
    
    def __init__(self, name: str, initial_value: int = 0x00):
        super().__init__(name)
        self.value: int = initial_value
        
        # Puertos de entrada/salida
        self.data_in = Port(int, name="data_in")
        self.add_in_port(self.data_in)
        self.enable_in = Port(bool, name="enable_in")
        self.add_in_port(self.enable_in)
        self.enable_out = Port(bool, name="enable_out")
        self.add_in_port(self.enable_out)
        
        self.data_out = Port(int, name="data_out")
        self.add_out_port(self.data_out)
        
        self.pending_write = False
        self.pending_read = False
        self.pending_value = 0x00
    
    def initialize(self):
        self.passivate()
    
    def deltext(self, e: float):
        self.continuef(e)
        
        # Procesar señales de habilitación y datos
        if self.enable_in and not self.enable_in.empty():
            enabled = self.enable_in.get()
            if enabled and self.data_in and not self.data_in.empty():
                self.pending_value = self.data_in.get() & 0xFF
                self.pending_write = True
                self.activate()
        
        if self.enable_out and not self.enable_out.empty():
            enabled = self.enable_out.get()
            if enabled:
                self.pending_read = True
                self.activate()
        
        # Escritura directa sin señal enable
        if not self.enable_in and self.data_in and 
        not self.data_in.empty():
            self.pending_value = self.data_in.get() & 0xFF
            self.pending_write = True
            self.activate()
    
    def deltint(self):
        if self.pending_write:
            self.value = self.pending_value
            print(f"  [{self.name}] delta_int: Escritura completada.
            Valor={self.value:02X}")
            self.pending_write = False
        
        if self.pending_read:
            print(f"  [{self.name}] delta_int: Lectura completada.
            Valor={self.value:02X}")
            self.pending_read = False
        
        self.passivate()
    
    def lambdaf(self):
        if self.pending_read:
            print(f"  [{self.name}] lambda: Emitiendo 
            dato={self.value:02X} por data_out")
            self.data_out.add(self.value)
    
    def exit(self):
        pass


class InstructionPointer(Atomic):
    """Modelo atómico para el registro IP (Instruction Pointer)."""
    
    def __init__(self, name: str = "IP"):
        super().__init__(name)
        self.value: int = 0x00
        
        self.addr_out = Port(int, name="addr_out")
        self.add_out_port(self.addr_out)
        self.ip_write = Port(int, name="ip_write")
        self.add_in_port(self.ip_write)
        self.read_request = Port(bool, name="read_request")
        self.add_in_port(self.read_request)
        
        self.pending_output = False
        self.pending_increment = False
    
    def initialize(self):
        self.passivate()
    
    def deltext(self, e: float):
        self.continuef(e)
        
        if self.read_request and self.read_request.get():
            self.pending_output = True
            self.activate()
        
        if self.ip_write:
            increment = self.ip_write.get()
            if increment:
                self.pending_increment = True
                self.activate()
    
    def deltint(self):
        if self.pending_increment:
            old_val = self.value
            self.value = (self.value + 1) & 0xFF
            print(f"  [IP] delta_int: Incremento IP.
            {old_val:02X} → {self.value:02X}")
            self.pending_increment = False
        
        if self.pending_output:
            self.pending_output = False
        
        self.passivate()
    
    def lambdaf(self):
        if self.pending_output:
            print(f"  [IP] lambda: Emitiendo dirección IP=
            {self.value:02X} por addr_out")
            self.addr_out.add(self.value)
    
    def exit(self):
        pass


class MemoryAddressRegister(Atomic):
    """Modelo atómico para el registro MAR 
    (Memory Address Register)."""
    
    def __init__(self, name: str = "MAR"):
        super().__init__(name)
        self.address: int = 0x00
        
        self.addr_in = Port(int, name="addr_in")
        self.add_in_port(self.addr_in)
        self.addr_out = Port(int, name="addr_out")
        self.add_out_port(self.addr_out)
        
        self.pending_addr = None
    
    def initialize(self):
        self.passivate()
    
    def deltext(self, e: float):
        self.continuef(e)
        if self.addr_in:
            self.pending_addr = self.addr_in.get() & 0xFF
            self.activate()
    
    def deltint(self):
        if self.pending_addr is not None:
            self.address = self.pending_addr
            print(f"  [MAR] delta_int: Dirección almacenada. 
            MAR={self.address:02X}")
            self.pending_addr = None
        self.passivate()
    
    def lambdaf(self):
        if self.pending_addr is not None:
            print(f"  [MAR] lambda: Emitiendo dirección 
            MAR={self.pending_addr:02X} hacia MEM")
            self.addr_out.add(self.pending_addr)
    
    def exit(self):
        pass


class Memory(Atomic):
    """Modelo atómico para la memoria unificada."""
    
    def __init__(self, name: str = "MEM"):
        super().__init__(name)
        self.storage: dict[int, int] = {}
        self.pending_addr: int | None = None
        self.pending_read: bool = False
        
        self.addr = Port(int, name="addr")
        self.add_in_port(self.addr)
        self.rw = Port(bool, name="rw")  # True=read, False=write
        self.add_in_port(self.rw)
        self.data_in = Port(int, name="data_in")
        self.add_in_port(self.data_in)
        
        self.data_out = Port(int, name="data_out")
        self.add_out_port(self.data_out)
        
        self.pending_operation = None
    
    def initialize(self):
        # Cargar programa: MOV AL, BL (opcode 0x01)
        self.storage[0x00] = 0x01
        self.passivate()
    
    def deltext(self, e: float):
        self.continuef(e)
        
        # Capturar dirección
        if self.addr and not self.addr.empty():
            self.pending_addr = self.addr.get() & 0xFF
        
        # Capturar señal de lectura
        if self.rw and not self.rw.empty():
            self.pending_read = self.rw.get()
        
        # Si tenemos ambos, iniciar operación
        if self.pending_addr is not None and self.pending_read:
            self.pending_operation = ("read", self.pending_addr)
            print(f"  [MEM] delta_ext: Solicitud de lectura en 
            dirección {self.pending_addr:02X}")
            self.hold_in("READING", 1)  # tau_mem = 1
            self.pending_addr = None
            self.pending_read = False
    
    def deltint(self):
        if self.pending_operation:
            op_type, addr_val = self.pending_operation
            data = self.storage.get(addr_val, 0x00)
            print(f"  [MEM] delta_int: Lectura completada. 
            MEM[{addr_val:02X}]={data:02X}")
        self.pending_operation = None
        self.passivate()
    
    def lambdaf(self):
        if self.pending_operation and self.pending_operation[0] 
        == "read":
            addr_val = self.pending_operation[1]
            data = self.storage.get(addr_val, 0x00)
            print(f"  [MEM] lambda: Emitiendo dato={data:02X} 
            por data_out")
            self.data_out.add(data)
    
    def exit(self):
        pass


class ControlUnit(Atomic):
    """Modelo atómico para la Unidad de Control (UC)."""
    
    def __init__(self, name: str = "UC"):
        super().__init__(name)
        
        # Entradas
        self.ir_in = Port(int, name="ir_in")
        self.add_in_port(self.ir_in)
        
        # Salidas de control - Fase FETCH
        self.ip_read = Port(bool, name="ip_read")
        self.add_out_port(self.ip_read)
        self.ip_inc = Port(bool, name="ip_inc")
        self.add_out_port(self.ip_inc)
        self.mem_read = Port(bool, name="mem_read")
        self.add_out_port(self.mem_read)
        self.mbr_enable = Port(bool, name="mbr_enable")
        self.add_out_port(self.mbr_enable)
        self.ir_enable = Port(bool, name="ir_enable")
        self.add_out_port(self.ir_enable)
        self.ir_read = Port(bool, name="ir_read")
        self.add_out_port(self.ir_read)
        
        # Salidas de control - Fase EXECUTE 
        # (señales indexadas para REG_BANK)
        self.reg_enable_out = Port(str, name="reg_enable_out")
        # Nombre del registro: "AL", "BL", etc.
        self.add_out_port(self.reg_enable_out)
        self.reg_enable_in = Port(str, name="reg_enable_in")
        self.add_out_port(self.reg_enable_in)
        
        # Estado interno
        self.phase = "IDLE"
        self.instruction_code = 0x00
        self.micro_step = 0
        
        # Contadores para métricas
        self.total_cycles = 0
        self.fetch_cycles = 0
        self.execute_cycles = 0
        
        # Tabla de decodificación
        self.instruction_set = {
            0x01: {"opcode": "MOV", "dst": "AL", "src": "BL"}
        }
    
    def initialize(self):
        self.phase = "FETCH1"
        self.micro_step = 0
        # Contar el ciclo inicial
        self.total_cycles = 1
        self.fetch_cycles = 1
        self.hold_in(self.phase, 1)
    
    def deltint(self):
        # Máquina de estados de la UC
        if self.phase == "FETCH1":  # UC → IP
            print(f"\n{'-'*78}")
            print(f"  FASE FETCH - Paso 1/6: UC → IP 
            (solicita dirección)")
            print(f"{'-'*78}")
            self.phase = "FETCH2"
            cycles = 1
            # No sumar aquí porque ya se contó en initialize()
            self.hold_in(self.phase, cycles)
        
        elif self.phase == "FETCH2":  # IP → MAR
            print(f"\n{'-'*78}")
            print(f"  FASE FETCH - Paso 2/6: IP → MAR 
            (transfiere dirección)")
            print(f"{'-'*78}")
            self.phase = "FETCH3"
            cycles = 1
            self.fetch_cycles += cycles
            self.total_cycles += cycles
            self.hold_in(self.phase, cycles)
        
        elif self.phase == "FETCH3":  # UC → MEM; IP++
            print(f"\n{'-'*78}")
            print(f"  FASE FETCH - Paso 3/6: UC → MEM (mem_read);
            IP ← IP+1")
            print(f"{'-'*78}")
            self.phase = "FETCH4"
            cycles = 2
            self.fetch_cycles += cycles
            self.total_cycles += cycles
            self.hold_in(self.phase, cycles)
        
        elif self.phase == "FETCH4":  # MEM → MBR
            print(f"\n{'-'*78}")
            print(f"  FASE FETCH - Paso 4/6: MEM → MBR 
            (instrucción leída)")
            print(f"{'-'*78}")
            self.phase = "FETCH5"
            cycles = 1
            self.fetch_cycles += cycles
            self.total_cycles += cycles
            self.hold_in(self.phase, cycles)
        
        elif self.phase == "FETCH5":  # MBR → IR
            print(f"\n{'-'*78}")
            print(f"  FASE FETCH - Paso 5/6: MBR → IR 
            (carga instrucción)")
            print(f"{'-'*78}")
            self.phase = "FETCH6"
            cycles = 2
            self.fetch_cycles += cycles
            self.total_cycles += cycles
            self.hold_in(self.phase, cycles)
        
        elif self.phase == "FETCH6":  # IR → UC
            print(f"\n{'-'*78}")
            print(f"  FASE FETCH - Paso 6/6: IR → UC (recibe opcode)")
            print(f"{'-'*78}")
            # Transición directa a EXEC1 sin ciclo intermedio
            self.phase = "EXEC1"
            cycles = 1
            self.fetch_cycles += cycles
            self.total_cycles += cycles
            self.hold_in(self.phase, cycles)
        
        elif self.phase == "EXEC1":  # Decodificación
            print(f"\n{'-'*78}")
            print(f"  FASE EXECUTE - Paso 1/5: Decodificación")
            print(f"{'-'*78}")
            decoded = self.instruction_set.get(self.instruction_code, 
            {"opcode": "NOP", "dst": "", "src": ""})
            print(f"  [UC] Instrucción decodificada:
            {decoded['opcode']} {decoded['dst']},{decoded['src']}")
            print(f"  [UC] Microoperaciones planificadas: BL → 
            BUS → AL")
            self.phase = "EXEC2"
            cycles = 1
            self.execute_cycles += cycles
            self.total_cycles += cycles
            self.hold_in(self.phase, cycles)
        
        elif self.phase == "EXEC2":  # AL ← BUS
            print(f"\n{'-'*78}")
            print(f"  FASE EXECUTE - Paso 2/5: UC → 
            REG_BANK.enable_out(BL)")
            print(f"{'-'*78}")
            self.phase = "EXEC3"
            cycles = 1
            self.execute_cycles += cycles
            self.total_cycles += cycles
            self.hold_in(self.phase, cycles)
        
        elif self.phase == "EXEC3":
            print(f"\n{'-'*78}")
            print(f"  FASE EXECUTE - Paso 3/5: BUS ← BL 
            (dato disponible)")
            print(f"{'-'*78}")
            self.phase = "EXEC4"
            cycles = 2  
            # 2 ciclos: 1 para propagar en bus, 1 para estabilizar
            self.execute_cycles += cycles
            self.total_cycles += cycles
            self.hold_in(self.phase, cycles)
        
        elif self.phase == "EXEC4":
            print(f"\n{'-'*78}")
            print(f"  FASE EXECUTE - Paso 4/5: UC → 
            REG_BANK.enable_in(AL)")
            print(f"{'-'*78}")
            self.phase = "EXEC5"
            cycles = 1
            self.execute_cycles += cycles
            self.total_cycles += cycles
            self.hold_in(self.phase, cycles)
        
        elif self.phase == "EXEC5":
            print(f"\n{'-'*78}")
            print(f"  FASE EXECUTE - Paso 5/5: AL ← BUS 
            (captura completada)")
            print(f"{'-'*78}")
            # Incrementar contador del último ciclo
            cycles = 1
            self.execute_cycles += cycles
            self.total_cycles += cycles
            self.phase = "DONE"
            print(f"\n{'-'*78}")
            print(f"  Ciclo de instrucción MOV AL, BL completado")
            print(f"{'-'*78}")
            # Usar hold_in para contar el último ciclo,
            # luego passivate
            self.hold_in(self.phase, cycles)
        
        elif self.phase == "DONE":
            # Finalizar después del último ciclo 
            # (ya contado en EXEC5)
            self.passivate()
        
        else:
            self.passivate()
    
    def deltext(self, e: float):
        self.continuef(e)
        if self.ir_in:
            self.instruction_code = self.ir_in.get() & 0xFF
    
    def lambdaf(self):
        # Generar señales de control según la fase
        if self.phase == "FETCH1":
            self.ip_read.add(True)
        
        elif self.phase == "FETCH3":
            self.mem_read.add(True)
            self.ip_inc.add(True)
        
        elif self.phase == "FETCH4":
            self.mbr_enable.add(True)
        
        elif self.phase == "FETCH5":
            self.ir_enable.add(True)
        
        elif self.phase == "FETCH6":
            self.ir_read.add(True)
        
        elif self.phase == "EXEC2":
            self.reg_enable_out.add("BL")
        
        elif self.phase == "EXEC4":
            self.reg_enable_in.add("AL")
    
    def exit(self):
        pass


# =========================================================
# MODELO ACOPLADO: Banco de Registros (REG_BANK)
# =========================================================

class RegisterBank(Coupled):
    """
    Modelo acoplado para el banco de registros AL, BL, CL, DL.
    Actúa como mediador entre la UC y los registros individuales,
    gestionando las señales de habilitación indexadas y el bus interno.
    """
    
    def __init__(self, name: str = "REG_BANK"):
        super().__init__(name)
        
        # Crear registros atómicos individuales
        self.al = Register("AL", 0x01)
        self.bl = Register("BL", 0x0A)
        self.cl = Register("CL", 0x00)
        self.dl = Register("DL", 0x00)
        
        # Agregar como componentes
        self.add_component(self.al)
        self.add_component(self.bl)
        self.add_component(self.cl)
        self.add_component(self.dl)
        
        # Puertos de control desde UC (señales indexadas)
        self.reg_enable_in = Port(str, name="reg_enable_in")
        # Recibe nombre de registro destino
        self.add_in_port(self.reg_enable_in)
        self.reg_enable_out = Port(str, name="reg_enable_out")  
        # Recibe nombre de registro fuente
        self.add_in_port(self.reg_enable_out)
        
        # Acoplamientos para enable_in desde UC hacia registros
        self.add_coupling(self.reg_enable_in, self.al.enable_in)
        self.add_coupling(self.reg_enable_in, self.bl.enable_in)
        self.add_coupling(self.reg_enable_in, self.cl.enable_in)
        self.add_coupling(self.reg_enable_in, self.dl.enable_in)
        
        # Acoplamientos para enable_out desde UC hacia registros
        self.add_coupling(self.reg_enable_out, self.al.enable_out)
        self.add_coupling(self.reg_enable_out, self.bl.enable_out)
        self.add_coupling(self.reg_enable_out, self.cl.enable_out)
        self.add_coupling(self.reg_enable_out, self.dl.enable_out)
        
        # Bus interno: todos los registros pueden 
        # enviar/recibir datos
        # Cada registro fuente puede enviar al data_in de cualquier
        # registro destino
        for src_reg in [self.al, self.bl, self.cl, self.dl]:
            for dst_reg in [self.al, self.bl, self.cl, self.dl]:
                if src_reg != dst_reg:
                    self.add_coupling(src_reg.data_out, 
                    dst_reg.data_in)


# =========================================================
# MODELO ACOPLADO: Sistema completo VonSim8
# =========================================================

class VonSim8System(Coupled):
    """Modelo acoplado que integra todos los componentes del
    simulador VonSim8."""
    
    def __init__(self, name: str = "VonSim8"):
        super().__init__(name)
        
        # Crear componentes atómicos
        self.ip = InstructionPointer("IP")
        self.mar = MemoryAddressRegister("MAR")
        self.mem = Memory("MEM")
        self.mbr = SimpleRegister("MBR", 0x00)  # Usa SimpleRegister
        self.ir = SimpleRegister("IR", 0x00)    # Usa SimpleRegister
        self.uc = ControlUnit("UC")
        
        # Crear modelo acoplado: Banco de Registros
        # (incluye bus interno)
        self.reg_bank = RegisterBank("REG_BANK")
        
        # Contador de eventos DEVS
        self.devs_events = 0
        
        # Agregar componentes al modelo acoplado
        self.add_component(self.ip)
        self.add_component(self.mar)
        self.add_component(self.mem)
        self.add_component(self.mbr)
        self.add_component(self.ir)
        self.add_component(self.uc)
        self.add_component(self.reg_bank)
        
        # ==================================================
        # ACOPLAMIENTOS FASE FETCH
        # ==================================================
        # UC → IP
        self.add_coupling(self.uc.ip_read, self.ip.read_request)
        # IP → MAR
        self.add_coupling(self.ip.addr_out, self.mar.addr_in)
        # MAR → MEM
        self.add_coupling(self.mar.addr_out, self.mem.addr)
        # UC → MEM (read signal)
        self.add_coupling(self.uc.mem_read, self.mem.rw)
        # UC → IP (increment)
        self.add_coupling(self.uc.ip_inc, self.ip.ip_write)
        # MEM → MBR
        self.add_coupling(self.mem.data_out, self.mbr.data_in)
        # UC → MBR (enable write from MEM)
        self.add_coupling(self.uc.mbr_enable, self.mbr.enable_in)
        # MBR → IR
        self.add_coupling(self.mbr.data_out, self.ir.data_in)
        # UC → MBR (enable out to IR)
        self.add_coupling(self.uc.ir_enable, self.mbr.enable_out)
        # UC → IR (enable write from MBR)
        self.add_coupling(self.uc.ir_enable, self.ir.enable_in)
        # UC → IR (enable read to send to UC) - en FETCH6
        self.add_coupling(self.uc.ir_read, self.ir.enable_out)
        # IR data → UC
        self.add_coupling(self.ir.data_out, self.uc.ir_in)
        
        # ===================================================
        # ACOPLAMIENTOS FASE EXECUTE 
        # (con REG_BANK que contiene bus interno)
        # ===================================================
        # UC → REG_BANK (señales indexadas)
        self.add_coupling(self.uc.reg_enable_out, 
        self.reg_bank.reg_enable_out)
        self.add_coupling(self.uc.reg_enable_in, 
        self.reg_bank.reg_enable_in)


class CPUSystem(Coupled):
    """Wrapper para compatibilidad con el main anterior."""
    def __init__(self, name: str = "CPUEnvironment"):
        super().__init__(name)
        self.vonsim8 = VonSim8System("VonSim8")
        self.add_component(self.vonsim8)


if __name__ == "__main__":
    import time
    
    # Clase para contar eventos DEVS
    class EventCountingCoordinator(Coordinator):
        def __init__(self, model):
            super().__init__(model)
            self.event_count = 0
            
        def _inject_event_counter(self, model):
            """Inyecta contador en deltint y deltext de todos
            los modelos atómicos."""
            if hasattr(model, 'deltint'):
                original_deltint = model.deltint
                def counted_deltint():
                    self.event_count += 1
                    return original_deltint()
                model.deltint = counted_deltint
            
            if hasattr(model, 'deltext'):
                original_deltext = model.deltext
                def counted_deltext(e):
                    self.event_count += 1
                    return original_deltext(e)
                model.deltext = counted_deltext
            
            # Recursivamente para modelos acoplados
            if hasattr(model, 'components'):
                for comp in model.components:
                    self._inject_event_counter(comp)
        
        def initialize(self):
            """Override para inyectar contadores antes de 
            inicializar."""
            self._inject_event_counter(self.model)
            super().initialize()
    
    # ===============================================
    # ENCABEZADO
    # ===============================================
    print("\n" + "-" * 80)
    print(" " * 15 + "SIMULACIÓN DEVS - VONSIM8 (Von Neumann 8-bit)"
    + " " * 20 )
    print("-" * 80)
    print("  Instrucción: MOV AL, BL (opcode 0x01)")
    print("  Formalismo:  DEVS (Discrete Event System Specification)")
    print("-" * 80 + "\n")
    
    # ================================================
    # EJECUCIÓN
    # ================================================
    print("Ejecutando simulación...\n")
    
    env = CPUSystem("VonSim8Environment")
    coord = EventCountingCoordinator(env)
    coord.initialize()
    
    start_time = time.time()
    coord.simulate(num_iters=30)
    simulation_time = time.time() - start_time
    coord.exit()
    
    vonsim8 = env.vonsim8
    
    # ===============================================
    # RESULTADOS
    # ===============================================
    print("-" * 60)
    print("  RESULTADOS DE LA SIMULACIÓN")
    print("-" * 60)
    
    # Estado de registros (compacto)
    print(f"\n  Registros:")
    print(f"    IP:  0x00 → 0x{vonsim8.ip.value:02X}  ")
    print(f"    AL:  0x01 → 0x{vonsim8.reg_bank.al.value:02X} 
    {' Transferido' if vonsim8.reg_bank.al.value == 0x0A 
    else ' Error'}")
    print(f"    BL:  0x0A → 0x{vonsim8.reg_bank.bl.value:02X}  ")
    
    # Verificación compacta
    print()
    if vonsim8.reg_bank.al.value == 0x0A:
        print("  MOV AL,BL ejecutado correctamente")
    else:
        print("  ERROR en la transferencia")
    
    # Métricas compactas (valores calculados dinámicamente)
    print(f"\n  Métricas:")
    print(f" • CPI:         {vonsim8.uc.total_cycles} ciclos (FETCH:
    {vonsim8.uc.fetch_cycles} + EXECUTE: {vonsim8.uc.execute_cycles})")
    print(f" • Tiempo real: {simulation_time*1000:.2f} ms")
    print(f" • Eventos:     {coord.event_count} transiciones DEVS")
    print()
    
    # ====================================================
    # PIE DE PÁGINA
    # ====================================================
    print("-" * 80)
    print("Simulación completada | Arquitectura Von Neumann validada")
    print("-" * 80 + "\n")
```

Un ejemplo de resultado de la simulación es el siguiente:

------------------------------------------------------------------------------
               SIMULACIÓN DEVS - VONSIM8 (Von Neumann 8-bit)
------------------------------------------------------------------------------
  Instrucción: MOV AL, BL (opcode 0x01)
  Formalismo:  DEVS (Discrete Event System Specification)
------------------------------------------------------------------------------

Ejecutando simulación...

**FASE FETCH - Paso 1/6: UC → IP (solicita dirección)**

  - [IP] $\lambda$: Emitiendo dirección IP=00 por addr_out

  - [MAR] $\lambda$: Emitiendo dirección MAR=00 hacia MEM

  - [MAR] $\delta_{int}$: Dirección almacenada. MAR=00

**FASE FETCH - Paso 2/6: IP → MAR (transfiere dirección)**

  - [MEM] $\delta_{ext}$: Solicitud de lectura en dirección 00

**FASE FETCH - Paso 3/6: UC → MEM (mem_read); IP ← IP+1**

  - [IP] $\delta_{int}$: Incremento IP. 00 → 01

  - [MEM] $\lambda$: Emitiendo dato=01 por data_out

  - [MEM] $\delta_{int}$: Lectura completada. MEM[00]=01

  - [MBR] $\delta_{int}$: Escritura completada. Valor=01

**FASE FETCH - Paso 4/6: MEM → MBR (instrucción leída)**

**FASE FETCH - Paso 5/6: MBR → IR (carga instrucción)**

  - [MBR] $\lambda$: Emitiendo dato=01 por data_out

  - [MBR] $\delta_{int}$: Lectura completada. Valor=01

  - [IR] $\delta_{int}$: Escritura completada. Valor=01

**FASE FETCH - Paso 6/6: IR → UC (recibe opcode)**

  - [IR] $\lambda$: Emitiendo dato=01 por data_out

  - [IR] $\delta_{int}$: Lectura completada. Valor=01


**FASE EXECUTE - Paso 1/5: Decodificación**

  - [UC] Instrucción decodificada: MOV AL,BL

  - [UC] Microoperaciones planificadas: BL → BUS → AL

**FASE EXECUTE - Paso 2/5: UC → REG_BANK.enable_out(BL)**

  - [BL] $\lambda$: Emitiendo dato=0A por data_out

  - [BL] $\delta_{int}$: Lectura completada. Valor=0A

**FASE EXECUTE - Paso 3/5: BUS ← BL (dato disponible)**

**FASE EXECUTE - Paso 4/5: UC → REG_BANK.enable_in(AL)**

  - [AL] $\delta_{int}$: Escritura completada. Valor=0A

**FASE EXECUTE - Paso 5/5: AL ← BUS (captura completada)**

------------------------------------------------------------------------------
   Ciclo de instrucción MOV AL, BL completado
------------------------------------------------------------------------------
------------------------------------------------------------------------------
  RESULTADOS DE LA SIMULACIÓN
------------------------------------------------------------------------------

  Registros:

    - IP:  0x00 → 0x01

    - AL:  0x01 → 0x0A   Transferido

    - BL:  0x0A → 0x0A  

  MOV AL,BL ejecutado correctamente

  Métricas:

    * CPI:         14 ciclos (FETCH: 8 + EXECUTE: 6)

    * Tiempo real: 2.76 ms

    * Eventos:     45 transiciones DEVS

------------------------------------------------------------------------------
Simulación completada Arquitectura Von Neumann validada
------------------------------------------------------------------------------

El resultado de la simulación confirma que el modelo DEVS implementado en xdevs.py reproduce correctamente el ciclo de instrucción MOV AL, BL, validando así el enfoque teórico presentado en el Capítulo 5. Los registros involucrados (IP, AL, BL) muestran los valores esperados antes y después de la ejecución, y las métricas de rendimiento (CPI, tiempo real, eventos) proporcionan información adicional sobre la eficiencia del modelo.