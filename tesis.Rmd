---
title: 'Herramienta de simulación para dar soporte a la enseñanza de arquitectura de computadoras'
subtitle: "Tesis para optar al grado de Maestría en Sistemas de Información"
author: "Ruiz Jose Maria"
date: "2025" # o para fecha actual: "`r Sys.Date()`"
institution: "Universidad de Nacional de Entre Rios"
degree: "Maestría en Sistemas de Información"
advisor: "Director: Colombani Marcelo Alberto"
bibliography: [tesis.bib]
#biblio-style: apalike
biblio-style: ieeetr
link-citations: yes
site: bookdown::bookdown_site
output: bookdown::gitbook
github-repo: "ruiz-jose/Sim-x86-Tesis"
documentclass: book
fontsize: 14pt
lof: True
lot: True
---


# Resumen {-}

Existe un consenso creciente en el uso de herramientas de simulación en la enseñanza para procesos dinámicos complejos, como las operaciones intrínsecas de la computadora, que permiten representar de forma visual e interactiva la organización y arquitectura interna de la computadora, facilitando así la comprensión de su funcionamiento por parte de los alumnos y el desarrollo de los temas por parte del docente. En este contexto, los simuladores juegan una pieza clave en el campo de la Arquitectura de Computadoras, permitiendo conectar fundamentos teóricos con la experiencia práctica, simpliﬁcando abstracciones y haciendo más rica la labor docente.
La arquitectura x86 es ampliamente utilizada en computadoras de escritorio y servidores. Este documento pretende realizar una comparación de los simuladores x86 que más se adecuan en el dictado de la asignatura Arquitectura de Computadoras de la carrera Licenciatura en Sistemas, establecer los criterios de evaluación y evaluar los simuladores seleccionados de acuerdo con estos criterios.

La presente investigación surge en el marco del proyecto de investigación I/D novel PID-UNER 7065: “Enseñanza/aprendizaje de asignatura Arquitectura de Computadoras con herramientas de simulación de sistemas de cómputos”. El Proyecto es llevado a cabo en la Facultad de Ciencias de la Administración de la Universidad Nacional de Entre Ríos, se vincula directamente con la asignatura Arquitectura en Computadoras que se dicta en segundo año de la carrera Licenciatura en Sistemas perteneciente a la  Facultad de Ciencias de la Administración de la Universidad Nacional de Entre Ríos.

Palabras clave: x86, simulador, aprendizaje, enseñanza, arquitectura de computadoras.



# Agradecimientos {-}

Agradecimientos aquí.

<!--chapter:end:index.Rmd-->

# Introducción {#intro}
El uso cotidiano de dispositivos como computadoras personales, teléfonos móviles y relojes inteligentes está sustentado en arquitecturas computacionales específicas, cuya comprensión es fundamental para el desarrollo eficiente de soluciones informáticas.

Es esencial que los estudiantes de Arquitectura de Computadoras comprendan tanto la estructura como el funcionamiento interno de una computadora, y adquieran experiencia práctica con ellas. Para lograrlo, es fundamental disponer de un laboratorio bien equipado con el hardware adecuado y suficiente tiempo para que los estudiantes se familiaricen con las herramientas prácticas. En este contexto, se han desarrollado numerosos simuladores que facilitan la comprensión de la estructura y el funcionamiento de las computadoras, proporcionando valiosas experiencias de aprendizaje. Este trabajo se inscribe en dicha problemática educativa y busca contribuir con el desarrollo de una herramienta de simulación adaptada a las necesidades de la enseñanza de arquitectura de computadoras.

Esta tesis, inscrita en la Maestría en Sistemas de Información de la Facultad de Ciencias de la Administración, está directamente vinculada con el proyecto de investigación I/D novel PID-UNER 7065, titulado “Enseñanza/aprendizaje de Arquitectura de Computadoras con herramientas de simulación de sistemas de cómputo”, desarrollado en la Facultad de Ciencias de la Administración de la Universidad Nacional de Entre Ríos [@colombani_pid_2022].

La asignatura Arquitectura de Computadoras forma parte del plan de estudios de la carrera de Licenciatura en Sistemas, Universidad Nacional de Entre Ríos. Su objetivo es que los estudiantes comprendan la estructura y funcionamiento de las computadoras, y la ejecución lógica de un programa a nivel de instrucciones de máquina.

Para comprender los fundamentos de la arquitectura de computadoras, resulta necesario abordar su estructura básica y funcionamiento interno, comenzando por una descripción funcional general del sistema.

Desde una perspectiva funcional, una computadora es un sistema que capta datos de entrada, los procesa de acuerdo con instrucciones codificadas, y produce salidas a través de dispositivos periféricos o almacenamiento. Esta dinámica operativa constituye la base para comprender su arquitectura interna y los principios que rigen su diseño.

El procesamiento se realiza a través del procesador o CPU, y es en este componente donde los estudiantes encuentran mayor complejidad y dificultades para comprender su funcionamiento.

A pesar de que es posible explicar las partes del procesador, su funcionamiento, la interacción de sus componentes y enseñar lenguaje ensamblador mediante prácticas, los estudiantes suelen tener dificultades para lograr una comprensión completa del funcionamiento.

Sin embargo, la utilización de simuladores permite afianzar los conocimientos de los temas vistos en las clases teóricas, por ello, los simuladores deben ser simples, intuitivos y visualmente atractivos, para que los estudiantes puedan centrarse en los conceptos de arquitectura y no en el aprendizaje de la herramienta en sí.

La simulación es un término de uso diario en muchos contextos: medicina, militar, entretenimiento, educación, etc., debido a que permite ayudar a comprender cómo funciona un sistema, responder preguntas como "qué pasaría si", con el fin de brindar hipótesis sobre cómo o por qué ocurren ciertos fenómenos.

En este contexto, es necesario comprender con mayor profundidad qué se entiende por simulación y cómo esta técnica puede aplicarse en entornos educativos, se define simulación como el proceso de imitar el funcionamiento de un sistema a medida que avanza en el tiempo. Para llevar a cabo una simulación, es necesario construir un modelo conceptual que represente las características y comportamientos del sistema de interés. La simulación permite observar cómo dicho modelo evoluciona en el tiempo, replicando dinámicas reales o hipotéticas [@banks_discrete-event_2010; @law_simulation_2015; @robinson_simulation_2014].

Con los avances en el mundo digital, la simulación se ha convertido en una metodología de solución de problemas indispensable para ingenieros, docentes, diseñadores y gerentes. La complejidad intrínseca de los sistemas informáticos los hace difícil comprender y costosos de desarrollar sin utilizar simulación [@law_simulation_2015].

Muchas veces en el ámbito educativo, resulta difícil transmitir fundamentos teóricos de la organización y arquitectura interna de las computadoras debido a la complejidad de los procesos involucrados. Cuando se emplean exclusivamente métodos de enseñanza tradicionales —como pizarras, libros de texto o diapositivas—, estos resultan insuficientes para representar de manera efectiva las complejidades involucradas en la arquitectura de las computadoras [@lion_simuladores_2005; @contreras_uso_2010; @garcia-garcia_pbbcache_2020; @grossi2005simulador; @herruzo2002desarrollo; @Martinez1994; @concheiro2005simula3ms].

Es evidente la necesidad de utilizar nuevas tecnologías como recursos didácticos y medios de transferencia de conocimiento, ya que ayudan a los estudiantes a relacionar conceptos abstractos con realidades concretas. Estas tecnologías permiten situar al estudiante en un contexto que imita aspectos de la realidad, posibilitando la detección y análisis de problemáticas semejantes a las que se presentan en entornos reales. Este enfoque promueve un mejor entendimiento a través del trabajo exploratorio, la inferencia, el aprendizaje por descubrimiento y el desarrollo de habilidades [@nova_tool_2013; @mustafa_evaluating_2010; @garcia-carballeira_wepsim_2020; @prasad2016using].

Un simulador de arquitectura es una herramienta que imita el hardware de un sistema, representando sus aspectos arquitectónicos y funciones. Permiten realizar cambios, pruebas y ejecutar programas sin riesgo de dañar componentes ni depender de equipos físicos disponibles [@radivojevic_design_2011].

Algunas herramientas ofrecen una representación en forma visual e interactiva de la organización y arquitectura interna de la computadora, facilitando así la comprensión de su funcionamiento. En este sentido, los simuladores juegan una pieza clave en el campo de la Arquitectura de Computadores, permitiendo conectar fundamentos teóricos con la experiencia práctica, simpliﬁcando abstracciones y facilitando la labor docente [@nikolic_survey_2009; @hasan_survey_2012; @hennessy2017computer; @stallings_computer_2021].

Dentro del estudio de las arquitecturas de computadoras, la arquitectura x86 ocupa un lugar destacado debido a su amplia difusión y compatibilidad. A continuación, se presenta una breve evolución de esta arquitectura, que justifica su inclusión en el diseño de herramientas de simulación para la enseñanza. Comenzó con el procesador Intel 8086 en 1978 como una arquitectura de 16 bits. Evolucionó a una arquitectura de 32 bits con el procesador Intel 80386 en 1985 (i386 o x86-32) y posteriormente a 64 bits con las extensiones de AMD (AMD64) y su adopción por Intel (Intel 64) [@intel_64_2025; @amd_developer_2024].

A pesar de la aparición de nuevas arquitecturas como ARM o RISC-V, que serán analizadas comparativamente en capítulos posteriores, la arquitectura x86 conserva una alta relevancia en contextos educativos y profesionales. Por ello, se considera pertinente su inclusión como base para el desarrollo de herramientas de simulación.

Un procesador x86-64 mantiene la compatibilidad con los modos x86 existentes de 16 y 32 bits, y permite ejecutar aplicaciones de 16 y 32 bits, como así también de 64 bits. Esta compatibilidad hacia atrás protege las principales inversiones en aplicaciones y sistemas operativos desarrollados para la arquitectura x86 [@intel_64_2025; @amd_developer_2024; @abel_ibm_2000].

Por ello, la enseñanza de la arquitectura x86 es de gran relevancia en la asignatura Arquitecturas de Computadoras debido a los diferentes temas que aborda.

Como alternativa al equipamiento físico, los simuladores permiten suplir limitaciones de hardware y tiempo, brindando una experiencia de aprendizaje más accesible y replicable [@skrien_cpu_2001]. 

## Justificación
Los estudiantes y docentes de la asignatura de Arquitectura de Computadoras enfrentan múltiples desafíos a la hora de abordar los complejos conceptos teóricos inherentes a la arquitectura x86. Para los estudiantes, en particular, la introducción a la arquitectura de una computadora puede resultar abrumadora debido a la abstracción y el nivel de detalle técnico requerido. Por su parte, los docentes se ven limitados en la capacidad de ilustrar estos conceptos de manera gradual y progresiva debido a la falta de herramientas didácticas específicas para esta arquitectura. Ante estos desafíos, los simuladores juegan un papel crucial como herramientas de apoyo, al permitir la exploración y experimentación con los conceptos de forma visual e interactiva.

La necesidad de desarrollar un simulador específico para la arquitectura x86 se fundamenta en las limitaciones de los simuladores actuales, que no se adaptan de manera efectiva al plan de estudios específico de la asignatura Arquitectura de Computadoras, tal como se dicta en la Universidad Nacional de Entre Ríos. Aunque existen simuladores que apoyan la enseñanza de la arquitectura x86 en otros contextos [@radivojevic_design_2011; @nikolic_survey_2009], estos tienden a incluir una gran cantidad de contenidos preestablecidos. Si bien dichos contenidos son relevantes, introducir la arquitectura x86 en su totalidad desde las primeras instancias del curso puede resultar contraproducente para estudiantes principiantes, debido a la complejidad técnica y a la extensa cantidad de conceptos involucrados.

Esta tesis propone un enfoque alternativo: el desarrollo de una herramienta de simulación específicamente diseñada para apoyar la enseñanza de los contenidos de la asignatura Arquitectura de Computadoras. El sistema simulará una computadora basada en la arquitectura x86, ofreciendo una representación progresiva de su estructura y funcionamiento. Abordará de forma modular los principales componentes del sistema: la unidad central de procesamiento (CPU), la memoria principal, el módulo de entrada/salida (E/S) y los buses de comunicación.

Entre sus funcionalidades clave, permitirá:
- Visualizar en detalle cada una de las etapas del ciclo de ejecución de instrucciones (fetch y execute).
- Trabajar con un repertorio limitado y escalable de instrucciones en lenguaje ensamblador.
- Ejecutar programas de forma paso a paso o completa.
- Gestionar interrupciones básicas para simular la interacción con periféricos como teclado y pantalla.
- Evaluar el rendimiento de los programas a partir de métricas observables durante la simulación.

Estas características facilitarán una comprensión progresiva de la arquitectura x86 y promoverán una experiencia de aprendizaje alineada con los objetivos del curso.

```{r funcionalidadessimulador, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear los datos de la tabla
tablafuncionalidades <- data.frame(
  Componente = c("CPU", "Memoria", "E/S", "Instrucciones", "Evaluación"),
  `Funcionalidad Principal` = c(
    "Ciclo de instrucción, ejecución paso a paso",
    "Lectura/escritura en tiempo real",
    "Gestión básica de teclado/pantalla",
    "Conjunto limitado y ampliable",
    "Métricas de rendimiento"
  ),
  `Propósito Didáctico` = c(
    "Comprender la secuencia de ejecución",
    "Visualizar acceso a datos",
    "Simular interacción con periféricos",
    "Acompañar el avance del curso",
    "Analizar eficiencia de programas"
  )
)

tabla <- kable(tablafuncionalidades,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Funcionalidades principales del simulador propuesto",
               col.names = c("Componente", "Funcionalidad Principal", "Propósito Didáctico"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c"))

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "3cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "6cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tablafuncionalidades)),
             extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "12em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "28em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Contar con un simulador adaptado específicamente a los contenidos de esta asignatura no solo facilita el proceso de aprendizaje, al presentar los conceptos de manera progresiva y alineada con la currícula, sino que también permite una experiencia de aprendizaje contextualizada. Esto fomenta un aprendizaje significativo, en el cual los estudiantes pueden conectar teoría y práctica de manera efectiva a través de una herramienta diseñada para abordar de forma gradual y específica los conceptos fundamentales del curso.

Para garantizar que el simulador sea robusto, modular, flexible y fácil de modificar o ampliar, se explorará la utilización de técnicas formales de modelado y simulación, como las redes de Petri y DEVS (Discrete Event System Specification). Estas técnicas permiten una separación conceptual entre las capas de modelado y simulación, lo cual facilita tanto la comprensión del software como su adaptación. Además, estas metodologías permiten que las simulaciones escalen de forma transparente, posibilitando su ejecución en entornos de cómputo paralelo o distribuido sin necesidad de modificar el modelo, lo que representa una ventaja significativa en términos de escalabilidad [@peterson_petri_1981; @zeigler_theory_2000; @zeigler_theory_2018].

## Objetivos
El objetivo principal de esta tesis es desarrollar una herramienta de simulación centrada en la arquitectura x86, orientada a fortalecer los procesos de enseñanza y aprendizaje de la asignatura Arquitectura de Computadoras. La herramienta estará alineada con los contenidos y objetivos formativos establecidos en la currícula vigente. En función de este objetivo general, se plantean los siguientes objetivos específicos:

1. Estudiar y evaluar diferentes herramientas actuales de simulación destinadas a dar apoyo a la enseñanza de la arquitectura x86.
2. Diseñar e implementar una herramienta didáctica que facilite la enseñanza de los contenidos clave de la asignatura Arquitectura de Computadoras. Para ello, la herramienta deberá contemplar las siguientes funcionalidades:
    - Una visión global de la estructura y funcionamiento de la computadora.
    - Generación y ejecución de programas en ensamblador.
    - Repertorio de instrucciones x86 reducido y habilitado progresivamente.
    - Simulación visual e interactiva de micropasos de instrucciones.
    - Gestión de interrupciones y comunicación con periféricos.
    - Medidas de rendimiento de ejecución de programas.

## Metodología de desarrollo
La metodología de desarrollo de este simulador específico para la arquitectura x86 sigue una serie de etapas diseñadas para garantizar una progresión coherente y eficaz desde la fase de análisis hasta el diseño e implementación del simulador, de manera que se ajuste al plan de estudios de la asignatura Arquitectura de Computadoras en la Universidad Nacional de Entre Ríos.

1. Análisis de requerimientos: En esta etapa inicial, se identifican y definen los objetivos específicos del simulador, así como los requerimientos técnicos y pedagógicos necesarios para su alineación con la currícula. Este análisis establece una base sólida y clara para todas las fases subsecuentes del proyecto, asegurando que el simulador cumpla con las necesidades educativas y técnicas del curso.

2. Revisión y recopilación de información: Se realiza una investigación sistemática sobre los simuladores existentes que abordan la arquitectura x86, considerando su aplicabilidad en contextos educativos. Este paso incluye un análisis de las características, ventajas y limitaciones de los simuladores existentes, proporcionando una comprensión más profunda del contexto educativo y permitiendo identificar áreas de mejora en relación con el objetivo del proyecto.

3. Estudio comparativo: A partir de la información recopilada, se realiza un estudio comparativo detallado de las características de los simuladores disponibles en el mercado. Esta etapa busca evaluar cuáles de sus funcionalidades pueden adaptarse o modificarse y cuáles deberían excluirse, de acuerdo con los objetivos del simulador y las necesidades específicas del plan de estudios. Los hallazgos de este análisis comparativo constituirán una base sólida para orientar las decisiones de diseño del simulador.

4. Diseño y planificación del simulador: Con base en los hallazgos previos, se define la arquitectura, las funcionalidades y los módulos específicos del simulador. El diseño se enfoca en facilitar el aprendizaje progresivo de los estudiantes, implementando un repertorio de instrucciones que se habiliten a medida que avanzan en el curso. En esta etapa, se utilizan técnicas formales de modelado, como redes de Petri y DEVS (Discrete Event System Specification), para establecer una estructura modular, robusta y flexible que facilite tanto la comprensión como la modificación futura de la herramienta.

5. Construcción y desarrollo: En esta fase, se lleva a cabo la implementación del simulador de acuerdo con el diseño previamente definido. Cada funcionalidad se implementa y verifica de manera secuencial, asegurando su conformidad con los requerimientos técnicos y pedagógicos definidos. También se realizan pruebas parciales para asegurar la precisión y funcionalidad de cada módulo, lo que permite identificar y corregir errores tempranamente.

6. **Evaluación y ajuste**: Finalmente, se somete el simulador a una serie de pruebas con estudiantes o expertos en la materia para evaluar su efectividad en el aprendizaje de los conceptos de arquitectura de computadoras. Los resultados obtenidos en esta fase permiten realizar ajustes y optimizaciones necesarias, mejorando la herramienta y asegurando que cumpla con su propósito educativo de manera efectiva.

## Organización del documento
El resto de este documento se estructura de la siguiente manera:

- En el Capítulo (\@ref(arquitectura)), se presenta una descripción detallada de la arquitectura x86, definiendo sus características y el conjunto de instrucciones que la componen. Esta base teórica es fundamental para comprender los aspectos que se simularán en el proyecto.

- El Capítulo (\@ref(simulacion)) explora el papel de la simulación desde una perspectiva didáctica, enfatizando su valor como herramienta de apoyo en la enseñanza de Arquitectura de Computadoras. Aquí se revisan los beneficios de los simuladores en la enseñanza y los desafíos que ayudan a resolver en la formación de los estudiantes.

- En el Capítulo (\@ref(comparativa)), se realiza un análisis comparativo de los simuladores actuales, evaluándolos según criterios previamente establecidos. Este análisis permite identificar las limitaciones y fortalezas de cada simulador y establecer el contexto para la propuesta de esta tesis.

- Finalmente, en el Capítulo (\@ref(desarrollo)), se describe el desarrollo de un simulador específico que se ajusta a los objetivos de enseñanza y aprendizaje de la arquitectura x86 en el contexto de la currícula. Este simulador está diseñado como una herramienta práctica y accesible para facilitar la comprensión de conceptos complejos en la asignatura.

<!--chapter:end:01-intro.Rmd-->

# Arquitectura de computadoras {#arquitectura}
Este capítulo aborda los conceptos fundamentales de la arquitectura de computadoras, incluyendo las filosofías de diseño CISC y RISC, la evolución de la arquitectura x86 y una introducción al lenguaje ensamblador. Estos temas constituyen la base necesaria para comprender el funcionamiento interno de los sistemas informáticos.

## Introducción a la arquitectura de computadoras
La arquitectura de computadoras es una disciplina central en el campo de la informática que estudia el diseño, la organización y la interacción entre los componentes de un sistema computacional. Esta área abarca tanto aspectos de hardware como de software que interactúan directamente con él, proporcionando principios fundamentales para construir sistemas eficientes, robustos y adaptables. Comprender su funcionamiento resulta esencial para analizar cómo se implementan, optimizan y escalan los sistemas informáticos en diversos contextos tecnológicos [@stallings_computer_2021; @tanenbaum_structured_2016; @murdocca_principles_2000; @bryant2015computer].

Uno de los conceptos clave en esta disciplina es la distinción entre **arquitectura de computadoras** y **organización de computadoras**. La arquitectura se refiere a los elementos visibles para el programador, como el conjunto de instrucciones, los registros y los modos de direccionamiento. La organización, en cambio, se enfoca en los detalles físicos de implementación, tales como el diseño de circuitos y los ciclos de reloj necesarios para cada operación [@stallings_computer_2021; @tanenbaum_structured_2016; @murdocca_principles_2000; @hennessy2017computer; @bryant2015computer].

Distinguir esta diferencia es crucial para analizar cómo los diseños arquitectónicos han evolucionado en respuesta a las crecientes demandas de rendimiento, eficiencia energética y escalabilidad. En este sentido, arquitecturas como ARM y RISC-V se han consolidado en sistemas embebidos y dispositivos móviles debido a su simplicidad estructural y bajo consumo energético [@waterman_risc-v_2014; @harris2015digital; @null_essentials_2023]. En contraste, la arquitectura x86 ha adoptado un enfoque híbrido que combina características de CISC y RISC, permitiéndole adaptarse a los exigentes requerimientos del mercado [@bryant2015computer; @stallings_computer_2021; @patterson_computer_2014].

El análisis de una arquitectura de computadoras implica examinar múltiples dimensiones técnicas que inciden en su desempeño y aplicabilidad. Entre las más relevantes se encuentran:

- **Repertorio de instrucciones**: conjunto de operaciones que el procesador puede ejecutar directamente.
- **Capacidad de procesamiento**: determinada por el número de bits con los que opera la CPU (por ejemplo, 32 o 64 bits).
- **Modos de direccionamiento de memoria**: mecanismos mediante los cuales una instrucción accede a posiciones de memoria, como el direccionamiento directo, indirecto, segmentado o lineal.
- **Jerarquía de memoria y mecanismos de entrada/salida**: estructuras que influyen en la eficiencia del acceso a datos y en la interacción con dispositivos periféricos.
- **Grado de paralelismo**: capacidad de ejecutar múltiples instrucciones o tareas simultáneamente, ya sea a nivel de instrucción (ILP) o de procesos (TLP).

Estos dimensiones técnicas adquieren especial relevancia en sistemas contemporáneos aplicados a inteligencia artificial, internet de las cosas (IoT), computación en la nube y ciberseguridad, donde el equilibrio entre rendimiento, consumo energético y escalabilidad resulta determinante [@patterson_computer_2016; @harris2015digital; @belli2020iot].

Un componente esencial en el estudio de esta disciplina es la **arquitectura del conjunto de instrucciones (ISA, por sus siglas en inglés)**, que define la interfaz entre el hardware y el software [@hennessy2017computer]. La ISA especifica las operaciones disponibles, la codificación de las instrucciones y las formas de manipular los datos. Esta interfaz es fundamental para el diseño de compiladores, sistemas operativos y herramientas de simulación, ya que permite abstraer el funcionamiento del hardware a nivel lógico y facilita la portabilidad del software.

El diseño arquitectónico implica tomar decisiones que suponen compromisos (*trade-offs*), tales como la complejidad del hardware frente al rendimiento, o la eficiencia energética frente a la flexibilidad funcional. Estas decisiones determinan la aplicabilidad de una arquitectura en distintos dominios tecnológicos. Por ejemplo:

- La arquitectura **x86** resulta adecuada para entornos que requieren alto rendimiento y compatibilidad con software legado.
- La arquitectura **ARM** se prefiere en dispositivos móviles debido a su bajo consumo energético [@patterson_computer_2016; @harris2015digital; @belli2020iot].
- **RISC-V**, por su parte, destaca por su apertura, modularidad y flexibilidad, lo que la convierte en una alternativa atractiva para investigación, docencia y aplicaciones personalizadas [@patterson_computer_2017; @waterman_risc-v_2014].

En síntesis, el estudio de la arquitectura de computadoras permite comprender el funcionamiento interno de los sistemas, optimizar el desarrollo de soluciones tecnológicas complejas y fomentar la innovación en ingeniería de sistemas. Su enseñanza resulta fundamental en la formación en ciencias de la computación y disciplinas afines.

Desde una perspectiva educativa, el uso de herramientas de simulación contribuye a una comprensión progresiva de los conceptos arquitectónicos, al permitir experimentar con distintas arquitecturas y observar de forma interactiva el comportamiento del hardware [@akram2019survey; @menchonherramientas]. Esta dimensión didáctica adquiere especial importancia en el desarrollo de la herramienta propuesta en esta tesis, centrada en la arquitectura x86. Dicha arquitectura, ampliamente difundida en contextos académicos e industriales, también presenta desafíos significativos desde el punto de vista pedagógico, debido a su complejidad estructural y diversidad funcional.

## Arquitecturas Von Neumann y Harvard
Comprender las arquitecturas modernas requiere el análisis de dos modelos conceptuales fundamentales que sentaron las bases del diseño actual de sistemas computacionales: Von Neumann y Harvard. Estos modelos arquitectónicos no solo constituyen la base teórica de muchas arquitecturas contemporáneas, sino que también permiten identificar sus fortalezas, limitaciones y áreas de aplicación.

### Arquitectura Von Neumann
La arquitectura Von Neumann, formalizada por John von Neumann en 1945 en su influyente documento "First Draft of a Report on the EDVAC" [@vonneumann1945first], establece un modelo computacional en el cual tanto los datos como las instrucciones residen en una única memoria y comparten un mismo bus de comunicación. Esta arquitectura se caracteriza por sus cuatro componentes fundamentales: la unidad central de procesamiento (CPU), la unidad de control, la memoria y los dispositivos de entrada/salida. La unificación del espacio de memoria facilita el diseño del sistema y la programación, sin embargo, esta unificación también origina una limitación conocida como el ‘cuello de botella de Von Neumann’, que se refiere a la imposibilidad de acceder simultáneamente a datos e instrucciones debido al uso compartido del mismo bus, lo cual reduce la eficiencia del procesamiento, particularmente en aplicaciones con uso intensivo de datos [@hennessy2017computer; @stallings_computer_2021].

```{r vonneumann, echo=FALSE, fig.cap="Arquitectura Von Neumann", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/vonneumann.png")
```

### Arquitectura Harvard
Mientras la arquitectura Von Neumann se convertía en el paradigma dominante, paralelamente se desarrollaba un enfoque alternativo. La arquitectura Harvard tiene su origen en el diseño del Harvard Mark I, una computadora electromecánica desarrollada entre 1939 y 1944 durante la Segunda Guerra Mundial en la Universidad de Harvard bajo la dirección de Howard Aiken y con el apoyo de IBM [@ceruzzi_history_2003; @williams1998history]. El Harvard Mark I sentó las bases para un modelo arquitectónico diferente al de Von Neumann, caracterizado por una separación física entre instrucciones y datos.En este modelo, los datos y las instrucciones residen en memorias físicamente separadas, accedidas a través de buses independientes, lo cual mejora la eficiencia del procesamiento al eliminar la competencia por el bus entre instrucciones y datos. Esta organización evita el cuello de botella característico de Von Neumann y permite un acceso paralelo que incrementa el rendimiento en escenarios críticos para la eficiencia. A continuación, se presenta una comparación sistemática entre ambos modelos, a fin de comprender mejor sus implicancias técnicas y contextos de aplicación [@tanenbaum_structured_2016]. Debido a su eficiencia, esta arquitectura se ha adoptado ampliamente en sistemas embebidos, microcontroladores y procesadores de señal digital (DSP) [@noergaard2012embedded].

```{r harvard, echo=FALSE, fig.cap="Arquitectura Harvard", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/harvard.png")
```

### Comparativa entre Von Neumann y Harvard
Como señalan Stallings [@stallings_computer_2021] y Hennessy [@hennessy2017computer], la arquitectura Von Neumann continúa siendo una alternativa predominante cuando se priorizan la simplicidad del diseño, la flexibilidad en la asignación de memoria y la compatibilidad con software de propósito general, como ocurre en muchas computadoras personales y servidores contemporáneos. En cambio, la arquitectura Harvard ha demostrado ventajas significativas en aplicaciones que demandan procesamiento en tiempo real y eficiencia energética, como dispositivos móviles, microcontroladores y entornos de control industrial. La elección entre ambas arquitecturas responde, en última instancia, a requerimientos específicos del sistema, ya sea por su complejidad, restricciones energéticas o necesidades de rendimiento paralelo.

Para una comparación más sistemática, se pueden establecer criterios como tipo de memoria, estructura de buses, capacidad de acceso paralelo, casos de uso representativos, ventajas y limitaciones.

```{r, echo=FALSE, out.width = "100%", fig.cap="Comparación entre arquitecturas Von Neumann y Harvard"}
library(knitr)
library(kableExtra)

# Crear la tabla de datos
tabla <- data.frame(
  Característica = c("Memoria", "Buses", "Acceso simultáneo", "Ejemplo típico", "Ventaja principal", "Limitación principal"),
  "Von Neumann" = c("Única para datos e instrucciones", "Bus compartido", "No", "Intel x86", "Diseño más simple", "Cuello de botella"),
  "Harvard" = c("Separada para datos e instrucciones", "Buses independientes", "Sí", "AVR, PIC", "Mayor rendimiento", "Diseño más complejo")
)

tabla_kable <- kable(tabla,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Cuadro comparativo entre arquitecturas Von Neumann y Harvard",
               col.names = c("Característica", "Von Neumann", "Harvard"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c"))

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "5.5cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tabla)),
             extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "10em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "32em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Ambos modelos conceptuales han tenido una influencia decisiva en el diseño de arquitecturas contemporáneas. Mientras que el modelo Von Neumann ofrece un enfoque unificado que simplifica el desarrollo de software y hardware, la arquitectura Harvard destaca por su capacidad para mejorar el rendimiento mediante el acceso paralelo a instrucciones y datos. Esta distinción resulta crucial al analizar el diseño de arquitecturas modernas como x86, que constituye el foco de esta tesis. Comprender las implicancias de estas decisiones arquitectónicas es esencial para evaluar el impacto en el rendimiento, la eficiencia energética y la escalabilidad de los sistemas actuales.

El contraste entre estos dos modelos ha dado lugar a enfoques intermedios que buscan capitalizar las ventajas de ambos. Como resultado de esta evolución, emergen las denominadas arquitecturas híbridas, las cuales integran características de ambos modelos para optimizar el rendimiento y la flexibilidad del sistema.

### Arquitecturas híbridas
Muchas arquitecturas contemporáneas implementan un enfoque híbrido, también conocido como arquitectura Harvard modificada. Este modelo emplea memorias separadas para datos e instrucciones a nivel microarquitectónico a menudo mediante la utilización de memorias caché de nivel 1 (L1) separadas para instrucciones y datos. No obstante, desde la perspectiva del programador, el modelo de memoria se mantiene unificado, facilitando el desarrollo de software sin exponer la complejidad del diseño interno. Esta dualidad permite optimizar la implementación física del procesador sin complicar el modelo de programación [@hennessy2017computer; @null_essentials_2023; @patterson_computer_2017; @stallings_computer_2021].


```{r hibrida, echo=FALSE, fig.cap="Arquitectura Híbridas", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/hibrida.png")
```

Esta aproximación híbrida se implementa en arquitecturas modernas como ARM Cortex y los procesadores Intel Core, los cuales incorporan cachés separadas para instrucciones y datos con el objetivo de optimizar el rendimiento del pipeline, lo que facilita una mayor paralelización del procesamiento y reduce los conflictos en el acceso a memoria. A pesar de que el modelo de memoria visible para el programador se presenta como unificado, a nivel interno se implementan mecanismos característicos de la arquitectura Harvard, como el uso de memorias caché separadas para instrucciones y datos [@arm2021architecture; @intel_microarchitecture_2021].

La adopción de arquitecturas híbridas, como la Harvard modificada, ha permitido a los diseñadores combinar la flexibilidad del modelo Von Neumann con la eficiencia del modelo Harvard. Esta convergencia no solo optimiza el rendimiento de los sistemas, sino que también responde a las exigencias contemporáneas en términos de consumo energético y capacidad de procesamiento paralelo. En este sentido, la distinción entre ambos modelos continúa siendo un eje conceptual clave para comprender la evolución de las arquitecturas modernas y su adaptación a diferentes escenarios tecnológicos.

En síntesis, la comprensión de las arquitecturas fundamentales —Von Neumann, Harvard e híbridas— resulta esencial para el desarrollo de herramientas de simulación efectivas en la enseñanza de arquitectura de computadoras. Los conceptos explorados en esta sección proporcionan los fundamentos conceptuales esenciales para el diseño y desarrollo de la herramienta de simulación propuesta en esta tesis.

## Tipos de arquitecturas
El análisis de diversas arquitecturas de computadoras, y particularmente de sus repertorios de instrucciones (Instruction Set Architecture, ISA), es esencial para comprender sus ventajas, limitaciones y áreas de aplicación. Esta evaluación comparativa permite a los diseñadores y educadores seleccionar la ISA más adecuada para sus necesidades, considerando factores como la eficiencia energética, la complejidad del hardware, la compatibilidad y el soporte educativo.

Aunque arquitecturas como PowerPC, SPARC o MIPS desempeñaron un papel central en la evolución de la computación, su adopción ha disminuido significativamente en contextos industriales y académicos, debido al desplazamiento por plataformas con mayor soporte comercial y vigencia tecnológica [@stallings_computer_2021]. Su menor vigencia actual responde al surgimiento de arquitecturas más eficientes y con mejor respaldo comercial, como x86, ARM y RISC-V, que han captado la atención tanto del mercado como del ámbito educativo [@hennessy2017computer_riscv; @waterman_risc-v_2014; @null_essentials_2023; @arm_evolution_2025]. Por ello, esta sección se enfoca en aquellas arquitecturas que mantienen relevancia comercial o presentan un valor pedagógico significativo en el desarrollo de simuladores educativos.

### Arquitectura x86
La arquitectura x86, desarrollada inicialmente por Intel, ha dominado el mercado de computadoras de escritorio y servidores durante décadas, gracias a su evolución constante y soporte del ecosistema de software [@hennessy2017computer]. Su conjunto de instrucciones (ISA, por sus siglas en inglés Instruction Set Architecture) incluye una amplia gama de operaciones, lo que otorga flexibilidad, aunque complica el diseño del hardware. Este equilibrio entre compatibilidad y rendimiento hace que x86 sea una opción preferida para entornos donde la capacidad de procesamiento es prioritaria, como en servidores y estaciones de trabajo [@hennessy2017computer; @intel_whitepaper_2023].

### Arquitectura ARM
Reconocida por su alta eficiencia energética, la arquitectura ARM es la columna vertebral de dispositivos móviles y sistemas embebidos. Basada en el paradigma de conjunto de instrucciones reducidas (RISC), ARM simplifica el diseño del hardware y optimiza el consumo energético, características que la posicionan como una opción preferente para aplicaciones como smartphones y tablets. Aunque su rendimiento máximo en tareas de cómputo intensivo suele ser inferior al de x86, su equilibrio entre eficiencia energética y capacidad computacional resulta decisivo en mercados donde la autonomía y la disipación térmica son factores críticos, como los dispositivos móviles y el IoT [@patterson_computer_2014; @arm_evolution_2025].

### Arquitectura RISC-V
Como arquitectura de código abierto, RISC-V ofrece una alternativa personalizable a los modelos propietarios, destacándose en entornos académicos y de desarrollo especializado. Su ISA flexible permite a los desarrolladores personalizar sistemas según necesidades específicas, haciéndola especialmente atractiva para investigación, educación y aplicaciones embebidas. Basada en principios RISC, RISC-V combina eficiencia energética con un diseño de hardware simplificado, y su creciente ecosistema la posiciona como una fuerte competidora frente a arquitecturas establecidas como ARM. No obstante, RISC-V enfrenta desafíos para su adopción masiva, en parte debido a la falta de estándares unificados, la fragmentación de su ecosistema y la limitada presencia de proveedores comerciales consolidados, lo que dificulta su despliegue en entornos productivos críticos.[@hennessy2017computer_riscv; @waterman_risc-v_2014;  @harris2015digital; @patterson2016computer].

### Comparativa entre arquitecturas
Las características distintivas de cada arquitectura condicionan su idoneidad para diversas aplicaciones. Por ejemplo, mientras x86 sobresale en entornos de alto rendimiento, ARM domina en dispositivos móviles gracias a su eficiencia energética. Por su parte, arquitecturas como RISC-V han encontrado aplicaciones relevantes en sistemas embebidos, plataformas educativas y diseños personalizados, aunque su presencia comercial difiere notablemente. La selección adecuada de una arquitectura impacta significativamente en el éxito de un proyecto, desde el diseño hasta su implementación final. Además, comprender las diferencias entre estas arquitecturas, en particular sus repertorios de instrucciones y principios de diseño, resulta fundamental en el ámbito educativo, dado que facilita el desarrollo de herramientas didácticas que simulan sus principios operativos y ayudan a los estudiantes a visualizar el funcionamiento real de los sistemas computacionales [@patterson_computer_2014; @arm_evolution_2025].

```{r aplicacionessimulacion, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear los datos de la tabla
aplicaciones <- data.frame(
  Sector = c("Automotriz", "Aeroespacial", "Medicina", "Educación"),
  Aplicación = c(
    "Pruebas de colisión virtuales",
    "Simuladores de vuelo",
    "Simulación de cirugías",
    "Simuladores para arquitectura de computadoras"
  ),
  `Beneficio principal` = c(
    "Reducción de costos y aumento de seguridad",
    "Entrenamiento sin riesgo",
    "Entrenamiento sin comprometer pacientes",
    "Comprensión de procesos abstractos"
  )
)

# Crear la tabla con formato dinámico
tabla <- kable(aplicaciones,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Aplicaciones de la simulación en distintos sectores",
               col.names = c("Sector", "Aplicación", "Beneficio principal"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "l", "l"))

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "3cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "5cm") %>%
    column_spec(3, width = "6cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(aplicaciones)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas

} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "20em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "15em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

En el contexto de la enseñanza de arquitectura de computadoras, estas arquitecturas permiten abordar distintos niveles de complejidad y estilos de diseño, lo que resulta clave para la construcción de simuladores educativos efectivos.

## Repertorio de instrucciones
El repertorio de instrucciones, o Instruction Set Architecture (ISA), es el conjunto de operaciones que un procesador puede ejecutar, incluyendo su representación binaria y el conjunto de reglas que definen la interacción entre el software y el hardware. El ISA define la interfaz entre el hardware y el software, abarcando instrucciones aritméticas, lógicas, de control y de manipulación de datos, así como los modos de direccionamiento y los formatos de instrucción. Por su influencia directa en el rendimiento, la eficiencia energética y la versatilidad del sistema, el ISA constituye un componente esencial en el diseño de arquitecturas de computadoras [@hennessy2017computer; @null_essentials_2023; @stallings_computer_2021].

### Características clave del ISA
Entre las características fundamentales a considerar en el diseño de un repertorio de instrucciones se encuentran las siguientes [@hennessy2017computer]:

  - **Tipos de operandos**: representan los datos que las instrucciones pueden manipular, como enteros, números en punto flotante, caracteres y direcciones de memoria. Un ISA eficiente debe soportar una amplia variedad de operandos para maximizar su versatilidad.
  - **Tipos de operaciones**: incluyen las operaciones que el procesador puede realizar, como aritméticas (suma, resta), lógicas (AND, OR), de control (saltos, llamadas a subrutinas) y de manipulación de datos (almacenamiento, carga). Diversos autores destacan que un ISA bien diseñado debe lograr un equilibrio entre funcionalidad, simplicidad y eficiencia de implementación, aspectos fundamentales en el diseño de arquitecturas modernas [@hennessy2017computer; @null_essentials_2023].
  - **Modos de direccionamiento**: determinan cómo se especifican los operandos en las instrucciones. Entre los modos más comunes se encuentran el inmediato, directo, indirecto, mediante registros, con desplazamiento y basado en pila. Cada uno ofrece distintos niveles de eficiencia, flexibilidad y complejidad, siendo fundamentales para optimizar el acceso a datos y la ejecución de instrucciones.
  - **Formato de las instrucciones**: que definen las reglas para acceder a los operandos dentro de las instrucciones, se exploran con mayor detalle en la siguiente subsección.

```{r repInstCaracteristicas, echo=FALSE, fig.cap="Características repertorio de instrucciones", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/isa.png")
```

El diseño de un repertorio de instrucciones eficiente y versátil es un desafío complejo que requiere un equilibrio entre funcionalidad, rendimiento y facilidad de uso. La selección adecuada de operandos, operaciones y modos de direccionamiento, junto con un formato de instrucción bien estructurado, son aspectos fundamentales para lograr una arquitectura de computadoras efectiva y adaptable a diversas aplicaciones. Estas características no solo definen las capacidades funcionales de un procesador, sino que también condicionan la manera en que las instrucciones interactúan con la memoria y los registros. A continuación, se profundiza en los modos de direccionamiento, uno de los elementos que más influye en la flexibilidad y eficiencia del repertorio de instrucciones.

### Modos de direccionamiento
Los modos de direccionamiento definen los mecanismos mediante los cuales una instrucción especifica la ubicación de sus operandos, permitiendo así al procesador acceder a los datos en memoria o registros en tiempo de ejecución. A continuación, se describen los modos de direccionamiento más comúnmente implementados en las arquitecturas modernas [@stallings_computer_2021; @hennessy2017computer]:

  a) **Inmediato**: el operando está directamente incluido en la instrucción, permitiendo acceso rápido a valores constantes. Es eficiente para operaciones simples, aunque limitado a operandos pequeños.
  b) **Directo**: la instrucción contiene la dirección de memoria del operando. Es fácil de usar, pero está restringido por el rango de direcciones accesibles.
  c) **Indirecto**: la instrucción apunta a una dirección que contiene la ubicación real del operando, lo que amplía el rango de direcciones a costa de un acceso adicional a memoria.
  d) **Registro**: el operando se encuentra en un registro del procesador, proporcionando acceso extremadamente rápido, pero limitado por la cantidad de registros disponibles.
  e) **Registro Indirecto**: similar al modo indirecto, pero la dirección efectiva se obtiene a partir del contenido de un registro, lo que ofrece un buen equilibrio entre velocidad de acceso y capacidad de direccionamiento.
  f) **Con Desplazamiento**: combina una dirección base con un valor de desplazamiento, ideal para estructuras como arrays y matrices.
  g) **Pila**: el operando está en la parte superior de la pila, útil para gestionar subrutinas y el paso de parámetros.

Para complementar la descripción anterior, la Figura \@ref(fig:ModDir) presenta una representación esquemática de los modos de direccionamiento, mostrando gráficamente cómo se calcula la dirección efectiva (EA) en cada caso [@stallings_computer_2021].

```{r ModDir, echo=FALSE, fig.cap="Modos de direccionamiento ", fig.align = 'center', out.width="60%"}
knitr::include_graphics(path = "images/modosdireccionamiento.png")
```

  - A = contenido de un campo de dirección en la instrucción
  - R = contenido de un campo de dirección en la instrucción que referencia a un registro
  - EA = dirección real (efectiva) de la posición que contiene el operando que se referencia

La tabla \@ref(tab:tabmoddir) detalla el cálculo de la dirección para cada modo de direccionamiento.

```{r tabmoddir, echo=FALSE, message=FALSE, warning=FALSE, table.pos='htbp'}
library(knitr)
library(kableExtra)
library(magrittr)

# Crear los datos de la tabla
tabmoddir <- data.frame(
  `Modo` = c("Inmediato", "Directo", "Indirecto", "Registro",
             "Indirecto con registro", "Con desplazamiento", "Pila"),
  `Algoritmo` = c("Operando \u2190 A", "EA \u2190 A", "EA \u2190 (A)",
                  "EA \u2190 R", "EA \u2190 (R)", "EA \u2190 A + (R)",
                  "EA \u2190 puntero de pila"),
  `Ventaja` = c("No referencia a memoria",
                "Es sencillo", "Espacio de direcciones grande",
                "No referencia a memoria",
                "Espacio de direcciones grande",
                "Flexibilidad",
                "No referencia a memoria"),
  `Desventaja` = c(
    "Operando de magnitud limitada",
    "Espacio de direcciones limitado",
    "Referencias múltiples a memoria",
    "Número limitado de registros",
    "Referencia extra a memoria",
    "Complejidad",
    "Aplicabilidad limitada"
  )
)

# Crear la tabla con formato dinámico
tabla_moddir <- kable(tabmoddir,
                      format = ifelse(knitr::is_latex_output(), "latex", "html"), # nolint
                      caption = "Modos de direccionamiento básicos",
                      col.names = c("Modo", "Algoritmo", "Ventaja", "Desventaja"), # nolint: line_length_linter.
                      booktabs = TRUE,
                      escape = FALSE)

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  tabla_moddir %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tabmoddir)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.

} else {
  tabla_moddir %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "20em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

### Formato de las instrucciones
El formato de las instrucciones especifica la disposición y codificación de los elementos que conforman una instrucción, como el código de operación (opcode), los operandos, los modos de direccionamiento y otros campos auxiliares. Esta organización impacta directamente en la facilidad de decodificación y en el rendimiento del procesador. Este formato afecta la rapidez de decodificación y la eficiencia general del procesador [@hennessy2017computer; @tanenbaum_structured_2016]:

- **Longitud de la instrucción**: puede ser fija o variable. Las instrucciones de longitud fija permiten una decodificación más rápida y simplifican la lógica de control del procesador. En cambio, las instrucciones de longitud variable permiten una codificación más eficiente del espacio de memoria, a costa de una mayor complejidad en la etapa de decodificación.
- **Cantidad de operandos**: las instrucciones pueden trabajar con diferentes números de operandos (de 0 a 3 o más). Una mayor cantidad de operandos incrementa la expresividad de las instrucciones, pero también puede derivar en una mayor complejidad de codificación y en un mayor uso de recursos del procesador.
- **Campos de instrucción**: incluyen el opcode y campos adicionales como operandos, modos de direccionamiento y flags de condición. Estos campos determinan cuántas y qué tipo de operaciones puede ejecutar el procesador en un ciclo de reloj.

La Figura \@ref(fig:forminst)  muestra un ejemplo representativo de formato de instrucción, donde se visualizan los campos que la componen y su disposición en el código binario.

```{r forminst, echo=FALSE, fig.cap="Formato de instrucciones ", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/formatoinst.png")
```

### Comparativa de repertorios de instrucciones

La siguiente tabla \@ref(tab:comparativaISA) resume las características principales de los repertorios de instrucciones en tres arquitecturas ampliamente utilizadas: x86, ARM y RISC-V. Se consideran aspectos como la longitud de las instrucciones, la cantidad de operandos, su complejidad y los modos de direccionamiento que permiten.

```{r comparativaISA, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear los datos de la tabla
isa_comparativa <- data.frame(
  Arquitectura = c("x86", "ARM", "RISC-V"),
  `Longitud instrucción` = c("Variable", "Fija (32 bits)", "Fija (32 bits)"),
  `Nº operandos` = c("0–3+", "3", "3"),
  `Tipos de operandos` = c("Complejos", "Simples", "Simples"),
  `Modos de direccionamiento` = c("Muchos", "Limitados", "Extensible")
)

tabla <- kable(isa_comparativa,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Comparativa de repertorios de instrucciones reales",
               col.names = c("Arquitectura", "Longitud instrucción", "Nº operandos", "Tipos de operandos", "Modos de direccionamiento"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c", "c", "c"))

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "3cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:5, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(isa_comparativa)),
             extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "20em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:5, width = "15em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

## Filosofías CISC y RISC
El diseño del repertorio de instrucciones es una decisión estratégica clave en la arquitectura de procesadores, ya que determina no solo el rendimiento del sistema, sino también la complejidad del hardware y del software, en particular del compilador. Dos de las filosofías más influyentes en este campo son **CISC (Complex Instruction Set Computing)** y **RISC (Reduced Instruction Set Computing)**. Mientras que **CISC** prioriza la reducción del número de instrucciones necesarias para realizar tareas complejas mediante operaciones multifuncionales, **RISC** simplifica el conjunto de instrucciones con el objetivo de maximizar la velocidad y la eficiencia energética. En esta sección se analizan ambos enfoques y sus implicaciones en el diseño de procesadores [@hennessy2017computer; @patterson_computer_2014].

El debate entre las filosofías CISC y RISC se remonta a fines de la década de 1970, cuando se comenzaron a cuestionar los beneficios reales de los repertorios de instrucciones complejos. Mientras las primeras generaciones de computadoras buscaban reducir el número de instrucciones por programa, investigaciones posteriores demostraron que un conjunto reducido y eficiente de instrucciones podía mejorar significativamente el rendimiento al simplificar la ejecución y optimizar el uso del hardware.

La evolución de los procesadores ha llevado a un enfoque más equilibrado, donde las arquitecturas modernas combinan elementos de ambas filosofías. Las arquitecturas modernas tienden a incorporar elementos de ambas filosofías. Por ejemplo, x86 adopta técnicas de ejecución interna propias de RISC para aumentar su rendimiento, mientras que procesadores RISC como ARM han introducido extensiones complejas para tareas específicas, acercándose parcialmente al enfoque CISC [@hennessy2017computer; @patterson_computer_2014].

### CISC
Las arquitecturas **CISC**, como la **x86**, se caracterizan por su enfoque en reducir el número de instrucciones requeridas para completar operaciones complejas. Esto se logra mediante la inclusión de instrucciones que combinan múltiples operaciones en un solo ciclo. Como resultado, los programadores necesitan escribir menos líneas de código para alcanzar un objetivo específico.

Sin embargo, este diseño implica ciertas desventajas. La **decodificación** y **ejecución** de instrucciones CISC requiere un hardware considerablemente más complejo, y las instrucciones de longitud variable, típicas de estas arquitecturas, pueden aumentar el tiempo de decodificación. Esto genera cuellos de botella en el pipeline y limita el rendimiento.

Un ejemplo representativo es la arquitectura x86, que ha incorporado técnicas internas de ejecución similares a RISC —como la descomposición de instrucciones mediante microcódigo— con el fin de mejorar el rendimiento sin abandonar su repertorio complejo. Utiliza microcódigo para descomponer las instrucciones complejas en operaciones más simples, parecidas a las de un procesador RISC. Aunque esta estrategia mejora la eficiencia de ejecución en algunos casos, el diseño sigue siendo más costoso en términos de consumo energético y complejidad [@patterson_computer_2014].

En consecuencia, el diseño del repertorio de instrucciones —incluyendo operaciones, modos de direccionamiento y formatos— constituye la interfaz crítica entre hardware y software, afectando tanto la eficiencia de ejecución como la expresividad de los programas. Su diseño influye directamente en la eficiencia del procesamiento y en la forma en que los programas interactúan con la arquitectura subyacente, lo que refuerza su relevancia en el estudio de la arquitectura de computadoras.

### RISC {#RISC}
Las arquitecturas basadas en RISC, en contraste con CISC, se caracterizan por emplear instrucciones simples y de longitud fija. Esta simplificación facilita la decodificación y permite que muchas instrucciones se ejecuten en un solo ciclo de reloj. Además, esta filosofía favorece la implementación de técnicas avanzadas como el pipelining y la predicción de ramas, optimizando así el rendimiento.

A nivel de hardware, RISC prioriza la eficiencia energética, una característica crucial en dispositivos móviles y sistemas embebidos. Por ello, procesadores como los basados en ARM han dominado estos mercados, especialmente en dispositivos móviles, debido a su bajo consumo energético. La simplicidad y el bajo CPI (ciclos por instrucción) han sido factores determinantes en su adopción [@hennessy2017computer_riscv].

### Comparativa entre CISC y RISC
Las diferencias entre CISC y RISC son evidentes tanto a nivel de diseño como de implementación. En las arquitecturas RISC, las instrucciones tienen una longitud fija, lo que simplifica la decodificación, reduce la latencia y mejora la predictibilidad del rendimiento. Además, este formato mejora la eficiencia del uso de la memoria caché, al ocupar menos espacio y facilitar accesos más rápidos.

En cambio, las arquitecturas CISC, como x86, emplean instrucciones de longitud variable, lo que les permite ofrecer una mayor flexibilidad y un repertorio más amplio de operaciones. Sin embargo, esta flexibilidad conlleva un mayor tiempo de decodificación y una complejidad adicional en la implementación del pipeline. Esto puede causar problemas como interrupciones en el flujo debido a errores de predicción de ramas, aunque se mitiguen mediante técnicas avanzadas como la predicción dinámica de saltos y el prefetching [@tanenbaum_structured_2016].

Por ejemplo, en RISC, los modos de direccionamiento son simples y permiten un acceso más rápido a los operandos, reduciendo la latencia en el pipeline [@stallings_computer_2021]. En CISC, los modos de direccionamiento más complejos proporcionan flexibilidad a costa de una mayor latencia, lo que impacta negativamente en el rendimiento general del sistema.

#### Ejemplos de instrucciones
Para ilustrar la diferencia entre ambas filosofías, se presenta el siguiente ejemplo: cargar dos valores de memoria, sumarlos y almacenar el resultado en una dirección de memoria.

Una arquitectura bajo la filosofia RISC es RISC-V, que utiliza instrucciones simples y de longitud fija. En este caso, la instrucción para cargar un valor de memoria en un registro es `lw` (load word), y la instrucción para almacenar el resultado es `sw` (store word). La suma se realiza con la instrucción `add`.:

```{r  code0, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
    # Cargar el valor de mem1 en el registro t0 (R1)
    lw t0, 0(mem1)      # t0 = MEM[mem1]

    # Cargar el valor de mem2 en el registro t1 (R2)
    lw t1, 0(mem2)      # t1 = MEM[mem2]

    # Sumar los registros t0 y t1, guardar el resultado en t2 (R3)
    add t2, t0, t1      # t2 = t0 + t1

    # Guardar el resultado en mem1
    sw t2, 0(mem1)      # MEM[mem1] = t2
  \\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
    # Cargar el valor de mem1 en el registro t0 (R1)
    lw t0, 0(mem1)      # t0 = MEM[mem1]

    # Cargar el valor de mem2 en el registro t1 (R2)
    lw t1, 0(mem2)      # t1 = MEM[mem2]

    # Sumar los registros t0 y t1, guardar el resultado en t2 (R3)
    add t2, t0, t1      # t2 = t0 + t1

    # Guardar el resultado en mem1
    sw t2, 0(mem1)      # MEM[mem1] = t2
  ```")
}
```

Una arquitectura bajo la filosofia CISC es x86, que utiliza instrucciones más complejas y de longitud variable. En este caso, la instrucción para cargar un valor de memoria en un registro es `MOV`, y la instrucción para almacenar el resultado es también `MOV`. La suma se realiza con la instrucción `ADD`:

```{r  code1, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
  ; Cargar el valor almacenado en mem1 en el registro EAX
  MOV EAX, [mem1]

  ; Sumar el valor almacenado en mem2 al registro EAX
  ADD EAX, [mem2]

  ; Guardar el resultado de la suma de vuelta en mem1
  MOV [mem1], EAX
  \\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
  ; Cargar el valor almacenado en mem1 en el registro EAX
  MOV EAX, [mem1]

  ; Sumar el valor almacenado en mem2 al registro EAX
  ADD EAX, [mem2]

  ; Guardar el resultado de la suma de vuelta en mem1
  MOV [mem1], EAX
  ```")
}
```

La tabla \@ref(tab:ciscrisc) sintetiza las principales diferencias estructurales y operativas entre las filosofías CISC y RISC, destacando sus implicancias en el diseño del hardware y el rendimiento general del sistema.

```{r ciscrisc, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

ciscrisc <- data.frame(
  Aspecto = c("Objetivo principal",
              "Tipo de instrucciones",
              "Decodificación y ejecución",
              "Longitud de instrucciones",
              "Eficiencia energética",
              "Modos de direccionamiento"),
  CISC = c("Minimizar el número de instrucciones para operaciones complejas",
           "Instrucciones complejas, longitud variable",
           "Requiere hardware más complejo, posibles cuellos de botella en el pipeline", # nolint: line_length_linter.
           "Longitud variable, puede aumentar el tiempo de decodificación",
           "Menor eficiencia energética en comparación con RISC",
           "Flexibilidad a costa de mayor latencia"),
  RISC = c("Simplificar el conjunto de instrucciones para optimizar velocidad y eficiencia energética", # nolint: line_length_linter.
           "Instrucciones simples, longitud fija",
           "Decodificación más sencilla, facilita el uso de técnicas avanzadas como pipelining", # nolint: line_length_linter.
           "Longitud fija, simplifica la decodificación y mejora la predictibilidad del rendimiento", # nolint: line_length_linter.
           "Mayor eficiencia energética, especialmente en dispositivos móviles",
           "Acceso más rápido a los operandos, menor latencia")
)

# Crear la tabla con formato dinámico
tabla <- kable(ciscrisc,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Comparativa entre CISC y RISC",
               col.names = c("Aspecto", "CISC", "RISC"),
               booktabs = TRUE,
               escape = FALSE)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "5cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(ciscrisc)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "20em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

#### Convergencia de filosofías
A pesar de sus diferencias, las arquitecturas modernas tienden a integrar características de ambas filosofías. Por ejemplo, los procesadores x86 adoptan técnicas propias de RISC para mejorar la eficiencia energética y el rendimiento. Esta convergencia refleja cómo los avances en diseño de procesadores buscan combinar lo mejor de cada enfoque, maximizando la flexibilidad y la eficiencia para adaptarse a las necesidades actuales y futuras del mercado.

La Figura \@ref(fig:convergen) muestras la convergencia entre estas dos filosofías:

```{r convergen, echo=FALSE, fig.cap="Convergencia de filosofías", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/convergen.png")
```

En síntesis, las filosofías CISC y RISC representan enfoques contrastantes pero complementarios en el diseño de arquitecturas de procesadores. Su comprensión no solo es esencial para analizar el rendimiento y la eficiencia energética de los sistemas modernos, sino también para formar una base sólida en la enseñanza de arquitectura de computadoras, especialmente en contextos donde se emplean simuladores didácticos.

## Arquitectura x86
La arquitectura x86, reconocida por su amplia adopción en computadoras personales, estaciones de trabajo y servidores, se introdujo en 1978 con el procesador Intel 8086, basado en una arquitectura de 16 bits. Desde entonces, ha evolucionado en capacidad y complejidad, con hitos clave como la introducción del Intel 80386 (32 bits) en 1985 y la extensión a 64 bits con AMD64 en 2003. Esta evolución ha permitido mejoras significativas en el rendimiento, el direccionamiento de memoria y la compatibilidad con aplicaciones exigentes. [@stallings_computer_2021; @intel_64_2025; @amd_developer_2024; @abel_ibm_2000; @brey_intel_microprocessors; @intel8086manual].

```{r x86, echo=FALSE, fig.cap="Diagrama esquemático microprocesador Intel 8086", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/x86.png")
```

### Evolución de la arquitectura x86
Uno de los pilares del éxito de la arquitectura x86 ha sido su retrocompatibilidad, permitiendo la ejecución de aplicaciones de 16, 32 y 64 bits en un mismo sistema. Dicha propiedad no solo ha garantizado la continuidad del ecosistema x86, sino que también ha protegido las inversiones en software y sistemas operativos, una característica fundamental en entornos empresariales y académicos.

A continuación, se presenta la tabla \@ref(tab:hitosx86) que resume los hitos clave en la evolución de los procesadores x86:

```{r hitosx86, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

hitosx86 <- data.frame(
  Procesador = c("Intel 8086", "Intel 80386", "AMD64"),
  `Año de Lanzamiento` = c(1978, 1985, 2003),
  `Número de Bits` = c(16, 32, 64),
  `Nuevas Características` = c(
    "Arquitectura inicial",
    "Memoria virtual",
    "Extensiones de 64 bits"
  )
)

# Crear la tabla con formato dinámico
tabla <- kable(hitosx86,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Hitos en la evolución x86",
               col.names = c("Procesador", "Año de Lanzamiento", "Número de Bits", "Extensiones de 64 bits"), # nolint
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c", "l"))

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE) %>%
    column_spec(2:4, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(hitosx86)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "18em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

La tabla \@ref(tab:evolucionx86) muestra cómo la evolución de x86 ha estado marcada por avances tecnológicos que han impulsado la informática hacia nuevas fronteras:

```{r evolucionx86, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

evolucionx86 <- data.frame(
  Año = c(1978, 1982, 1985, 1989, 1993, 1995, 2003, 2006),
Procesador = c("Intel 8086", "Intel 80286", "Intel 80386", "Intel 80486", "Intel Pentium", "Intel Pentium Pro", "AMD64", "Intel Core"), # nolint
`Innovación_Principal`  = c("Introducción de la arquitectura x86, 16 bits",
                            "Modos de operación adicionales",
                            "Arquitectura de 32 bits, memoria virtual",
                            "Unidad de punto flotante integrada, mejor caché",
                            "Ejecución superescalar, predicción de saltos",
                            "Ejecución fuera de orden, caché L2 integrada",
                            "Extensiones a 64 bits, mayor acceso a memoria",
                            "Optimización de rendimiento y eficiencia energética") # nolint: line_length_linter.
)

# Crear la tabla con formato dinámico
tabla <- kable(evolucionx86,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Línea de Tiempo de la Evolución de la Arquitectura x86", # nolint
               col.names = c("Año", "Procesador", "Innovación"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "l"))

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "2cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "3.5cm", border_right = TRUE) %>%
    column_spec(3, width = "9cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(evolucionx86)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "20em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

###  Repertorio de instrucciones x86
La arquitectura x86 destaca por su complejidad y flexibilidad, reflejada en un repertorio de instrucciones extenso y de longitud variable. Esto contrasta con arquitecturas RISC, donde predominan instrucciones de longitud fija y decodificación sencilla [@hennessy2017computer; @brey_intel_microprocessors]. Aunque esta flexibilidad implica una mayor capacidad expresiva y compatibilidad hacia atrás, también introduce desafíos de diseño, tales como la necesidad de decodificadores complejos, técnicas de predicción de instrucciones y ejecución fuera de orden para lograr un rendimiento competitivo. 

#### Estructura de una instrucción x86
Una instrucción típica de x86 puede incluir los siguientes componentes [@stallings_computer_2021]:

  - **Prefijos**: modifican la operación principal de la instrucción. Por ejemplo, el prefijo `0x66` cambia el tamaño del operando.
  - **Código de operación (Opcode)**: indica la operación a realizar. Por ejemplo, `0x89` corresponde `MOV`.
  - **Modificadores de dirección (ModR/M y SIB)**: definen registros y direccionamiento. El byte **SIB** (Scale, Index, Base) es especialmente útil para operaciones complejas, como el acceso a matrices.
  - **Desplazamiento e inmediato**: Agregan flexibilidad en el manejo de datos, aunque aumentan la complejidad.

```{r FormatoInst, echo=FALSE, fig.cap="Formato de instrucciones del Pentium x86", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/formatoinstruccionx86.png")
```

Un ejemplo típico de instrucción es:

```{r  code2, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
  ; Carga en el registro AX el valor almacenado en la dirección de memoria
  ; que resulta de sumar el contenido de los registros BX y SI más el desplazamiento 16.
  MOV AX, [BX+SI+16]
  \\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
    ; Carga en el registro AX el valor almacenado en la dirección de memoria
    ; que resulta de sumar el contenido de los registros BX y SI más el desplazamiento 16.
    MOV AX, [BX+SI+16]
  ```")
}
```

Esta instrucción utiliza varios componentes, que el procesador debe decodificar antes de ejecutarla. Aunque esta flexibilidad es una ventaja en términos de funcionalidad, requiere técnicas avanzadas, como predicción de saltos y paralelización, para mantener la eficiencia en procesadores modernos [@hennessy2017computer; @patterson_computer_2014; @brey_intel_microprocessors].

## Lenguaje máquina y lenguaje ensamblador
El lenguaje máquina es el conjunto de instrucciones que un procesador puede entender y ejecutar directamente. Cada procesador tiene su propio conjunto de instrucciones, que se representan en forma de números binarios. Estas instrucciones son específicas para cada arquitectura y están diseñadas para realizar operaciones básicas como sumar, restar, mover datos entre registros y acceder a la memoria. El lenguaje máquina es el nivel más bajo de programación y está compuesto por secuencias de bits que representan operaciones y operandos específicos del procesador
[@irvine2011assembly; @hennessy2017computer].

El procesador ejecuta directamente las instrucciones codificadas en lenguaje máquina, sin requerir traducción desde niveles superiores de abstracción. Sin embargo, la escritura manual de código en lenguaje máquina es un proceso extremadamente laborioso, propenso a errores y difícil de mantener. Cada instrucción debe representarse como una cadena precisa de ceros y unos. Esta codificación depende de las reglas específicas del procesador, que incluyen los modos de direccionamiento, los formatos de instrucción y la organización de la memoria [@irvine2011assembly; @stallings_computer_2021; @tanenbaum_structured_2016; @null_essentials_2023].

Por ejemplo, si un estudiante o desarrollador deseara sumar dos números en lenguaje máquina, tendría que especificar manualmente cada secuencia binaria correspondiente a la operación de suma, así como las direcciones de memoria donde se encuentran los operandos. Este enfoque no solo es tedioso, sino que también aumenta la probabilidad de errores, especialmente cuando se requiere modificar o depurar el código.

Ante las limitaciones del lenguaje máquina en términos de legibilidad y mantenibilidad, se desarrolló un lenguaje de bajo nivel con mayor legibilidad que el lenguaje máquina que permitiera al programador escribir instrucciones de forma más comprensible: el lenguaje ensamblador. Este lenguaje permite a los programadores escribir instrucciones más comprensibles mediante mnemónicos simbólicos, que actúan como representaciones legibles de las instrucciones en lenguaje máquina. Cada arquitectura de procesador define su propio conjunto de instrucciones (ISA, Instruction Set Architecture), lo que implica que el lenguaje ensamblador asociado debe ajustarse a la codificación binaria, modos de direccionamiento y sintaxis específicos de dicha ISA [@stallings_computer_2021].

En el ámbito educativo, el lenguaje ensamblador se destaca como una herramienta fundamental para comprender cómo se comunican el software y el hardware [@null_essentials_2023; @tanenbaum_structured_2016]. Permite a los estudiantes visualizar la ejecución de instrucciones individuales, analizar el uso de registros y explorar la estructura de la memoria, convirtiéndose en un recurso valioso para este propósito.

Un programa en lenguaje ensamblador suele estar compuesto por instrucciones que especifican un mnemónico, uno o más operandos, y eventualmente el modo de direccionamiento. Por ejemplo:

```{r  code3, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
  ; Carga el valor inmediato 5 en el registro AX.
  MOV AX, 5  

  ; Sumar los registros BX y AX, guarda el resultado en AX.
  ADD AX, BX 
  \\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
  ; Carga el valor inmediato 5 en el registro AX.
  MOV AX, 5  

  ; Sumar los registros BX y AX, guarda el resultado en AX.
  ADD AX, BX 
  ```")
}
```

Estas líneas indican que el valor 5 se mueve al registro AX y luego se suma el contenido de BX. A través de este tipo de instrucciones, el estudiante puede visualizar de forma explícita cómo opera el procesador sobre sus registros y memoria.

### Ensamblador
El ensamblador es un programa que traduce las instrucciones simbólicas escritas en lenguaje ensamblador a lenguaje máquina, es decir, las convierte en las secuencias binarias que el procesador puede interpretar y ejecutar. Este proceso de traducción es prácticamente directo, ya que existe una correspondencia uno a uno entre las instrucciones en ensamblador y las instrucciones en lenguaje máquina [@stallings_computer_2021; @tanenbaum_structured_2016]. En contraste, los lenguajes de programación de alto nivel, como C o Python, suelen generar múltiples instrucciones máquina por cada línea de código fuente, lo que los distancia más de la arquitectura subyacente [@hennessy2017computer].

La Figura \@ref(fig:ensambla) muestra el proceso de traducción de un programa en lenguaje ensamblador a lenguaje máquina. En este proceso, el ensamblador toma cada línea de código en ensamblador y la convierte en su representación binaria correspondiente, generando así un archivo ejecutable que puede ser cargado y ejecutado por el procesador.

```{r ensambla, echo=FALSE, fig.cap="Proceso de ensamblado", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/ensamblador.png")
```

### Ensambladores x86
En el caso de la arquitectura x86, los programadores pueden elegir entre diversos ensambladores, como TASM (Turbo Assembler) [@tasm], MASM (Microsoft Macro Assembler) [@masm] y NASM (Netwide Assembler) [@nasm]. Aunque cada ensamblador tiene características y sintaxis particulares, todos comparten el objetivo fundamental de convertir las instrucciones ensamblador en código binario ejecutable por los procesadores x86 [@hyde2010art].

A continuación, se presenta una tabla comparativa \@ref(tab:ensambladores) que resume las principales características de tres ensambladores ampliamente utilizados en la arquitectura x86. La información compilada permite visualizar diferencias relevantes en términos de sintaxis, compatibilidad, funcionalidades adicionales y contexto de uso, lo que resulta particularmente útil al momento de seleccionar herramientas adecuadas para entornos educativos o de desarrollo de bajo nivel.

```{r ensambladores, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear un data frame con la información de los ensambladores
ensambladores <- data.frame(
  Característica = c("Desarrollador", "Año de lanzamiento", "Sistema operativo",
                     "Sintaxis", "Soporte de macros", "Compatibilidad",
                     "Capacidades adicionales", "Licencia", "Uso actual"),
  TASM = c("Borland", "1985", "MS-DOS, Windows",
           "Sintaxis similar a Intel con extensiones",
           "Macros y directivas avanzadas",
           "Compatibilidad con x86 antiguo",
           "Integración con herramientas Borland",
           "Comercial",
           "Menos común, usado en entornos heredados"),
  MASM = c("Microsoft", "1981", "MS-DOS, Windows",
           "Sintaxis de Intel con soporte avanzado",
           "Macros y directivas extensivas",
           "Compatibilidad con x86 antiguo",
           "Integración con Visual Studio",
           "Comercial",
           "Ampliamente usado en desarrollo Windows"),
  NASM = c("Simon Tatham et al.", "1996", "Multiplataforma (Windows, Linux, macOS)", # nolint: line_length_linter.
           "Sintaxis de Intel, modular y extensible",
           "Macros avanzadas y preprocesamiento",
           "Compatibilidad con x86, x86-64 y otros",
           "Soporte para múltiples formatos (binario, ELF, etc.)",
           "Código abierto",
           "Popular en sistemas y software libre"),
  stringsAsFactors = FALSE
)


# Crear la tabla con formato dinámico
tabla <- kable(ensambladores,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Comparación de ensambladores arquitectura x86",
               col.names = c("Característica", "TASM", "MASM", "NASM"), # nolint
               booktabs = TRUE,
               escape = FALSE)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "3cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(ensambladores)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "18em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

<!--chapter:end:02-arquitectura.Rmd-->

# Simulación {#simulacion}
En este capítulo se analiza el papel de la simulación desde una perspectiva didáctica, destacando su relevancia como herramienta de apoyo en la enseñanza de Arquitectura de Computadoras. Se abordan los beneficios que ofrecen los simuladores en el proceso educativo y los desafíos que ayudan a superar en la formación de los estudiantes.

## Introducción a la simulación
La simulación constituye una herramienta esencial en múltiples dominios, incluidos la medicina, la defensa, el entretenimiento y particularmente la educación, debido a su capacidad para representar procesos complejos y facilitar la toma de decisiones en entornos seguros y controlados. Su principal valor radica en su capacidad para modelar sistemas complejos, generar hipótesis, realizar análisis predictivos y explorar escenarios de manera segura y eficiente.

Banks define la simulación como el proceso de replicar el comportamiento de un sistema a lo largo del tiempo mediante un modelo conceptual que representa sus características y dinámicas principales [@banks_discrete-event_2010]. Estos modelos evolucionan simulando las interacciones entre sus componentes, lo que permite estudiar su respuesta ante diferentes variables y escenarios [@robinson_simulation_2014].

La posibilidad de analizar sistemas complejos sin intervenir directamente en ellos convierte a la simulación en una herramienta indispensable en el contexto actual, marcado por el avance de la tecnología y la creciente complejidad de los sistemas. Además, la simulación permite optimizar diseños, prever comportamientos y reducir los costos de desarrollo antes de implementar soluciones reales [@law_simulation_2015; @zeigler_theory_2000].

### Aplicaciones de la simulación en la industria
En sectores como la industria automotriz, la simulación es fundamental para el diseño y prueba de sistemas de seguridad, como airbags y frenos. Gracias a modelos virtuales, se realizan pruebas de colisión y análisis de rendimiento sin necesidad de recurrir a costosas pruebas físicas. Asimismo, la simulación permite optimizar diseños de motores, analizar el flujo aerodinámico y prever el comportamiento de materiales en condiciones extremas, contribuyendo a mejorar tanto la eficiencia como la seguridad de los vehículos [@stork_towards_2008].

En la aviación, los simuladores de vuelo son esenciales para entrenar pilotos, replicando condiciones reales de vuelo sin riesgos. Durante el diseño de aeronaves, estas herramientas permiten evaluar la aerodinámica y el rendimiento en diversos entornos, reduciendo significativamente el tiempo y los costos de desarrollo mientras incrementan la seguridad [@jentsch_simulation_2017].

Estos principios generales encuentran aplicaciones concretas en diversos sectores industriales, donde la simulación cumple un papel clave tanto en el diseño como en el entrenamiento, la evaluación y la toma de decisiones.

```{r , echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear los datos de la tabla
aplicaciones <- data.frame(
  Sector = c("Automotriz", "Aeroespacial", "Medicina", "Educación"),
  Aplicación = c(
    "Pruebas de colisión virtuales",
    "Simuladores de vuelo",
    "Simulación de cirugías",
    "Simuladores para arquitectura de computadoras"
  ),
  `Beneficio principal` = c(
    "Reducción de costos y aumento de seguridad",
    "Entrenamiento sin riesgo",
    "Entrenamiento sin comprometer pacientes",
    "Comprensión de procesos abstractos"
  )
)

# Crear la tabla con formato dinámico
tabla <- kable(aplicaciones,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Aplicaciones de la simulación en distintos sectores",
               col.names = c("Sector", "Aplicación", "Beneficio principal"),
               booktabs = TRUE,
               escape = FALSE)

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "3cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "6cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(aplicaciones)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas

} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "20em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "15em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Estos ejemplos ilustran cómo la simulación contribuye significativamente a la optimización de procesos, la reducción de riesgos y la mejora continua en el desarrollo de sistemas complejos. Su uso no solo ha transformado sectores productivos, sino que también ofrece un modelo replicable en contextos educativos especializados, como la enseñanza de arquitectura de computadoras.

## Simulación en la educación
En contextos educativos, la simulación se ha consolidado como una estrategia pedagógica eficaz para facilitar la comprensión de fenómenos complejos, especialmente en disciplinas que requieren alto nivel de abstracción y razonamiento sistémico. A través de simuladores, los estudiantes pueden interactuar con sistemas virtuales y experimentar escenarios realistas, lo que mejora la comprensión de ideas abstractas y favorece la aplicación práctica de conocimientos teóricos [@lion_simuladores_2005].

En contraste con enfoques instruccionales tradicionales centrados en la transmisión de información, los simuladores favorecen metodologías activas basadas en el aprendizaje por descubrimiento, la resolución de problemas y la construcción significativa del conocimiento, las herramientas de simulación integran tecnologías que vinculan conceptos teóricos con situaciones reales. Esto promueve una pedagogía interactiva, basada en la resolución de problemas y el aprendizaje por descubrimiento, estimulando la exploración y el razonamiento inferencial [@contreras_uso_2010].

En definitiva, la simulación enriquece la experiencia de aprendizaje al proporcionar una plataforma dinámica y participativa que facilita tanto la experimentación como la asimilación profunda de los contenidos.

### El rol de la simulación en la enseñanza de Arquitectura de Computadoras
En la carrera de Licenciatura en Sistemas, la asignatura Arquitectura de Computadoras persigue varios objetivos esenciales:
- Comprender la estructura y funcionamiento de las computadoras.
- Conocer las diferentes arquitecturas de sistemas microprocesadores.
- Evaluar medidas de rendimiento y comparar arquitecturas.
- Analizar el impacto de la tecnología de las computadoras en contextos sociales y económicos.

Enseñar los fundamentos teóricos de la organización y arquitectura interna de las computadoras puede ser un reto debido a la complejidad de los procesos involucrados. Los estudiantes necesitan desarrollar altos niveles de abstracción para construir modelos mentales que les permitan entender conceptos como la ejecución de instrucciones, la gestión de memoria o la interacción entre componentes del sistema.

En este contexto, los simuladores se configuran como mediadores didácticos que permiten representar gráficamente procesos abstractos, facilitando la manipulación de parámetros y el análisis de resultados en un entorno seguro, repetible y sin restricciones físicas. Estas herramientas permiten a los alumnos experimentar con configuraciones y parámetros, observar su impacto en el rendimiento del sistema y explorar escenarios hipotéticos sin necesidad de hardware físico.

Además, la simulación actúa como un puente entre la teoría y la práctica, facilitando que los docentes refuercen conceptos abstractos con experiencias concretas. En conjunto, estas ventajas hacen de la simulación una metodología pedagógica invaluable, promoviendo la experimentación y el aprendizaje activo en la enseñanza de Arquitectura de Computadoras [@skrien_cpu_2001; @garcia-garcia_pbbcache_2020; @nova_tool_2013].

## El Formalismo DEVS (Discrete Event System Specification)
El formalismo DEVS es una metodología modular y jerárquica que permite modelar y analizar sistemas representables como sistemas de eventos discretos, continuos o híbridos. Desarrollado por Bernard P. Zeigler en la década de 1970, este enfoque amplía el concepto de las máquinas de Moore al añadir una estructura que permite representar el comportamiento de sistemas mediante eventos temporizados que provocan cambios de estado, capturando así tanto la dinámica interna como las interacciones externas del sistema [@zeigler_theory_2000].

### Estructura del formalismo DEVS
El formalismo DEVS se basa en la representación de sistemas como una colección de componentes que interactúan entre sí a través de eventos. Cada componente tiene un estado interno y puede recibir eventos externos que provocan cambios en su estado. Estos eventos pueden ser temporizados, lo que significa que el sistema puede reaccionar a eventos en momentos específicos, o pueden ser desencadenados por condiciones específicas.
Esta estructura permite capturar tanto el comportamiento interno como la interacción externa del sistema modelado, ver figura \@ref(fig:devs). 

```{r devs, echo=FALSE, fig.cap="Relación entre modelos atómicos y modelos acoplados en DEVS", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/devs.png")
```

DEVS describe el comportamiento de un sistema real utilizando eventos de entrada y salida, así como transiciones entre estados definidos. Un sistema en este formalismo se compone de dos tipos principales de modelos:

- **Modelos atómicos**: representan las unidades fundamentales de comportamiento.
- **Modelos acoplados**: integran modelos atómicos y/o otros modelos acoplados, permitiendo la construcción jerárquica de sistemas más complejos.

Esta organización modular facilita el análisis y la gestión de sistemas, permitiendo probar subsistemas de manera aislada antes de integrarlos en un modelo completo.

La siguiente figura \@ref(fig:acoplado) ilustra la organización modular del formalismo DEVS, mostrando cómo se integran modelos atómicos dentro de modelos acoplados:

```{r acoplado, echo=FALSE, fig.cap="Modelo acoplado en DEVS", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/acoplado.png")
```

### Aplicaciones del formalismo DEVS
"El formalismo DEVS encuentra aplicación en diversos ámbitos, como las redes de comunicación [@fujimoto2001parallel], donde permite simular el enrutamiento de paquetes y la congestión de redes; en entornos de manufactura [@zeigler_theory_2000], donde se modelan flujos de producción y control de calidad; y en sistemas de transporte, para la optimización de flujos vehiculares [@barros1997modeling]. También se utiliza en la simulación de sistemas biológicos, como la propagación de enfermedades o el comportamiento de poblaciones [@zeigler2004continuity]. En el ámbito de la educación, DEVS se ha implementado en simuladores para la enseñanza de arquitectura de computadoras, permitiendo a los estudiantes explorar y comprender conceptos complejos mediante la visualización y manipulación de modelos [@calvo2010simulador].

Estas aplicaciones destacan su versatilidad para optimizar sistemas complejos en escenarios del mundo real.

### DEVS en la enseñanza de la Arquitectura de Computadoras
La implementación de entornos de simulación basados en DEVS en la enseñanza de arquitectura de computadoras aporta múltiples ventajas que enriquecen el proceso de aprendizaje:

- **Representación visual**: ofrece diagramas y representaciones dinámicas que ayudan a los estudiantes a visualizar y comprender procesos internos, como la ejecución de instrucciones y la gestión de recursos.
- **Interactividad**: permite modificar configuraciones y parámetros, fomentando la experimentación y mostrando el impacto directo de estas variables en el rendimiento del sistema.
- **Exploración de escenarios**: posibilita simular escenarios hipotéticos y evaluar el comportamiento de sistemas complejos sin la necesidad de hardware físico.

Estas funcionalidades enriquecen la experiencia educativa al integrar la teoría con la práctica y fomentar una participación activa en el análisis de los principios fundamentales de la arquitectura computacional. Al adoptar DEVS como parte del entorno educativo, se potencia la capacidad de los estudiantes para abordar problemas complejos y explorar soluciones innovadoras [@calvo_valdes_simulador_2010].

En conclusión, el formalismo DEVS no solo es una herramienta valiosa para el modelado y análisis de sistemas, sino que también representa un recurso poderoso para facilitar la enseñanza de conceptos complejos, como los que se encuentran en la arquitectura de computadoras.

<!--chapter:end:03-simulacion.Rmd-->

# Comparativa de simuladores {#comparativa}
Este capítulo presenta un análisis comparativo de simuladores basados en la arquitectura x86, con el objetivo de determinar su adecuación para su integración en la asignatura Arquitectura de Computadoras de la Licenciatura en Sistemas de Información.

La selección y evaluación de estos simuladores se fundamenta en criterios específicos diseñados para medir su efectividad en un entorno educativo. El objetivo principal es identificar las herramientas que mejor respalden el proceso de enseñanza y aprendizaje. Los criterios definidos abarcan aspectos clave para la enseñanza de arquitectura de computadoras: facilidad de uso, funcionalidades del entorno de programación, calidad de los recursos de apoyo, mecanismos de ejecución de programas, precisión en la emulación de la arquitectura x86, características técnicas del software y su alineación con los contenidos curriculares.

Los resultados de esta investigación fueron publicados en el XVII Congreso de Tecnología en Educación y Educación en Tecnología (2022), en el trabajo titulado Herramientas de software para dar soporte en la enseñanza y aprendizaje de la arquitectura x86 [@colombani_herramientas_2022].

## Estudios similares
Existen antecedentes de estudios comparativos que evalúan simuladores aplicados a la enseñanza en cursos de arquitectura de computadoras:
  - “A survey and evaluation of simulators suitable for teaching courses in computer architecture and organization”, 2009  [@nikolic_survey_2009]: este estudio analiza simuladores considerando dos categorías principales. La primera, relacionada con las características de simulación, incluye criterios como granularidad, usabilidad, disponibilidad, presentación visual y flujo de simulación. La segunda categoría evalúa la cobertura de los contenidos establecidos en los planes de estudio.
  - “Survey and evaluation of simulators suitable for teaching for computer architecture and organization Supporting undergraduate students at Sir Syed University of Engineering & Technology”, 2012 [@hasan_survey_2012]: este trabajo evalúa aspectos como la usabilidad, disponibilidad, fundamentos de arquitectura informática, jerarquía de sistemas de memoria, comunicación e interfaz, y diseño de sistemas de procesadores.

A diferencia de los estudios mencionados, este trabajo propone una evaluación centrada exclusivamente en simuladores de arquitectura x86, mediante el uso de criterios diseñados ad hoc para analizar tanto las funcionalidades de simulación como su adecuación a los contenidos específicos de la asignatura Arquitectura de Computadoras dictada en la Licenciatura en Sistemas de la Universidad Nacional de Entre Ríos.

## Simuladores bajo análisis
Un simulador de arquitectura es una herramienta de software que emula el hardware de un sistema de cómputo, permitiendo representar aspectos arquitectónicos y funcionales del mismo. Estos simuladores ofrecen un entorno controlado para realizar pruebas, modificaciones y ejecución de programas sin riesgo de dañar componentes físicos o enfrentar limitaciones de hardware [@radivojevic_design_2011].

Algunos simuladores destacan por proporcionar una representación visual e interactiva de la organización y arquitectura interna de una computadora, facilitando la comprensión de su funcionamiento. Algunos ejemplos relevantes de simuladores son: Assembly Debugger (x86), Simple 8-bit Assembler Simulator, Microprocessor Simulator, Simulador de ensamblador de 16 bits y Emu8086. Estas herramientas juegan un papel fundamental en el aprendizaje de la arquitectura de computadoras, al conectar conceptos teóricos con experiencias prácticas y simplificar abstracciones complejas, además de servir como soporte en la labor docente [@nikolic_survey_2009; @hasan_survey_2012; @hennessy2017computer ;@stallings_computer_2021; @behrooz_computer_2005].

## Criterios de evaluación
Los criterios de evaluación se definieron con el objetivo de realizar un análisis integral y sistemático de los simuladores seleccionados. A continuación, se presentan estos criterios junto con sus respectivos indicadores y escalas:

- **Usabilidad**: evalúa la facilidad de uso del simulador.
  - **Indicadores**: 
    - Facilidad de aprendizaje (tiempo necesario para familiarizarse con la herramienta).
    - Interfaz de usuario (claridad y organización).
    - Documentación y ayuda (accesibilidad y calidad de tutoriales y guías).
  - **Escala**: Difícil - Media - Fácil.

- **Editor**: analiza las funcionalidades para escribir y depurar código ensamblador.
  - **Indicadores**: 
    - Capacidad de edición (resaltado de sintaxis, puntos de interrupción, etc.).
    - Manejo de errores de sintaxis.
    - Opciones de almacenamiento (guardar y cargar programas).
  - **Escala**: Baja - Media - Alta.

- **Documentación**: valora la disponibilidad y calidad de los recursos de aprendizaje proporcionados.
  - **Indicadores**: 
    - Manual de usuario.
    - Tutoriales de aprendizaje.
    - Exhaustividad en la descripción del repertorio de instrucciones.
  - **Escala**: Mínima - Media - Completa.

- **Ejecución de simulación**: mide la facilidad para controlar y observar la ejecución de programas.
  - **Indicadores**: 
    - Control de simulación (pausa, reanudación, retroceso).
    - Visualización del flujo de ejecución.
    - Configurabilidad (ajuste de parámetros como la velocidad del reloj).
  - **Escala**: Baja - Media - Alta.

- **Nivel de especificación de la Organización y Arquitectura del sistema simulado**: determina la precisión en la representación de la arquitectura x86.
  - **Indicadores**: 
    - Fidelidad en la representación de la arquitectura.
    - Completitud del conjunto de instrucciones implementadas.
    - Inclusión y funcionalidad de memoria y módulos de E/S.
  - **Escala**: Mínima - Media - Completa.

- **Características del producto software**: evalúa las propiedades generales del simulador.
  - **Indicadores**: 
    - Tipo de licencia (open source o privativa).
    - Frecuencia de actualizaciones.
    - Plataforma (aplicación web o de escritorio)
  - **Escala**: Mala - Buena - Muy buena.

- **Cobertura de los contenidos preestablecidos en la currícula**: mide el grado en que el simulador abarca los contenidos de la asignatura.
  - **Indicadores**: 
    - Alineación con los tópicos del currículum.
    - Profundidad en el tratamiento de los temas.
  - **Escala**: Baja - Media - Alta.


La Tabla \@ref(tab:criterios) resume los criterios, indicadores y escalas utilizadas.

```{r criterios, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear los datos de la tabla
criterios <- data.frame(
  Criterio = c(
    "Usabilidad",
    "Funcionalidad del editor",
    "Calidad de la documentación",
    "Ejecución de simulación",
    "Especificación de arquitectura x86",
    "Propiedades técnicas y de distribución",
    "Alineación con contenidos curriculares"
  ),
  Indicadores = c(
    "Facilidad de aprendizaje, interfaz, documentación",
    "Sintaxis, manejo de errores, guardar/cargar",
    "Manuales, tutoriales, repertorio de instrucciones",
    "Control de simulación, visualización del flujo, configurabilidad",
    "Fidelidad de la arquitectura, repertorio, memoria y E/S",
    "Licencia, actualizaciones, plataforma",
    "Cobertura de tópicos, profundidad del tratamiento"
  ),
  Escala = c(
    "Difícil - Media - Fácil",
    "Baja - Media - Alta",
    "Mínima - Media - Completa",
    "Baja - Media - Alta",
    "Mínima - Media - Completa",
    "Mala - Buena - Muy buena",
    "Baja - Media - Alta"
  )
)


tabla <- kable(criterios,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Criterios e indicadores de evaluación de simuladores",
               col.names = c("Criterio", "Indicadores", "Escala"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "l", "l"))

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "6cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(criterios)),
             extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "20em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "15em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

## Selección de simuladores
Mediante una exploración exhaustiva de fuentes disponibles en línea, foros académicos y repositorios educativos, se identificaron los siguientes simuladores de arquitectura x86: Assembly Debugger (x86), Simple 8-bit Assembler Simulator, Microprocessor Simulator, Simulador de ensamblador de 16 bits, Emu8086, VonSim, Orga1 y Qsim. Estos simuladores fueron seleccionados por su relevancia en el ámbito educativo y su potencial para facilitar la enseñanza de la arquitectura x86.

La selección se basó en una evaluación preliminar que consideró el tiempo necesario para su análisis y el grado de cumplimiento de los criterios definidos, priorizando aquellos simuladores que ofrecieran un balance adecuado entre funcionalidad, usabilidad, documentación y alineación con los contenidos curriculares de la asignatura Arquitectura de Computadoras. De esta preselección, se eligieron tres herramientas que, a priori, cumplían con la mayor cantidad de criterios evaluativos: **Emu8086**, **VonSim** y **Simple 8-bit Assembler Simulator**.

```{r simuladores, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)
simbolo <- function(x) {
  if (knitr::is_latex_output()) {
    gsub("1", "\\\\checkmark", gsub("0", "\\\\ding{55}", x))
  } else {
    gsub("1", "✔", gsub("0", "✗", x))
  }
}

# Crear los datos de la tabla
simuladores <- data.frame(
  Simulador = c(
    "Assembly Debugger (x86)",
    "Simple 8-bit Assembler Simulator",
    "Microprocessor Simulator",
    "Simulador de ensamblador de 16 bits",
    "Emu8086",
    "VonSim",
    "Orga1",
    "Qsim"
  ),
  `Exploración Previa` = simbolo(c("1", "1", "1", "1", "1", "1", "1", "1")),
  `Evaluación Final` = simbolo(c("0", "1", "0", "0", "1", "1", "0", "0"))
)


tabla <- kable(simuladores,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Proceso de selección de simuladores",
               col.names = c("Simulador", "Exploración Previa", "Evaluación Final"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c"))


if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(simuladores)),
             extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "20em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "15em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

## Participantes en la evaluación
La evaluación fue llevada a cabo por un equipo conformado por tres docentes de la asignatura Arquitectura de Computadoras —Marcelo A. Colombani, José M. Ruiz y Amalia G. Delduca—, quienes aportaron su experiencia en el uso pedagógico de simuladores. Asimismo, se contó con la participación de un asesor externo, Marcelo A. Falappa, quien aportó una perspectiva independiente y validó tanto la metodología como los resultados obtenidos.

## Análisis comparativo
A continuación, se presenta un análisis detallado de los simuladores seleccionados, basado en los criterios previamente establecidos:

### Simple 8-bit Assembler Simulator
- **Usabilidad**: Nivel medio. Todos los componentes se muestran en una sola pantalla, lo que puede resultar abrumador para usuarios principiantes.
- **Editor**: Nivel bajo. Incluye notificaciones de errores de sintaxis al ensamblar, pero carece de resaltado de sintaxis, puntos de interrupción (breakpoints) y opciones para guardar o cargar programas.
- **Documentación**: Nivel mínimo. Consta solo de un manual de instrucciones implementadas.
- **Ejecución de simulación**: Nivel medio. Permite ajustar la velocidad del reloj de la CPU y proporciona controles básicos de simulación.
- **Nivel de especificación**: Nivel mínimo. Simplifica la arquitectura x86 a un CPU de 8 bits con 256 bytes de memoria y sin soporte para operaciones de entrada/salida (IN/OUT).
- **Desarrollo del producto**: Nivel bueno. Licencia MIT, última actualización en 2015, desarrollado como una plataforma web.
- **Cobertura de contenidos**: Nivel bajo. No incluye memoria independiente para módulos de entrada y salida, rutinas de interrupciones ni representación visual del ciclo de instrucción.

### VonSim
- **Usabilidad**: Nivel medio. Utiliza solapas para presentar los componentes, lo que puede ser confuso para usuarios iniciales.
- **Editor**: Nivel medio. Proporciona notificaciones de errores de sintaxis, resaltado de código y puntos de interrupción mediante software.
- **Documentación**: Nivel medio. Incluye un manual de uso y un tutorial interactivo.
- **Ejecución de simulación**: Nivel medio. Permite ajustar la velocidad del reloj de la CPU y ofrece controles básicos de simulación.
- **Nivel de especificación**: Nivel medio. Representa una simplificación del procesador 8088 con arquitectura de 16 bits y memoria direccionable de 16 KiB.
- **Desarrollo del producto**: Nivel muy bueno. Licencia GNU Affero General Public License v3.0, última versión en 2020, con amplia evidencia de uso académico.
- **Cobertura de contenidos**: Nivel medio. Implementa dispositivos internos y externos, pero carece de visualización del ciclo de instrucción y métricas de rendimiento.

### Emu8086
- **Usabilidad**: Nivel fácil. Inicialmente muestra el editor y permite activar los componentes del simulador a medida que se cargan programas.
- **Editor**: Nivel alto. Incluye notificaciones de errores de sintaxis, resaltado de código, puntos de interrupción y opciones para guardar/cargar programas.
- **Documentación**: Nivel completo. Ofrece un manual de instrucciones con ejemplos, un tutorial de aprendizaje y una guía de uso detallada.
- **Ejecución de simulación**: Nivel alto. Proporciona control avanzado de la simulación, como retroceder una instrucción ("step back").
- **Nivel de especificación**: Nivel completo. Detalla la arquitectura del procesador 8086, con memoria direccionable de 1 MiB y soporte para interrupciones de software y hardware.
- **Desarrollo del producto**: Nivel bueno. Licencia privativa, última actualización en 2023, desarrollado para plataformas de escritorio.
- **Cobertura de contenidos**: Nivel alto. Emula el arranque (bootstrapping) de una IBM PC desde un disco flexible (floppy disk) y soporta todos los modos de direccionamiento.

```{r tabla-comparativa-criterios, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

tabla_comparativa <- data.frame(
  `Criterio de Evaluación` = c("Usabilidad", "Editor", "Documentación", "Ejecución de simulación", 
                             "Nivel de especificación x86", "Características del producto", 
                             "Cobertura de contenidos"),
  `Simple 8 bit` = c("Medio", "Bajo", "Mínima", "Medio", "Mínima", "Buena", "Baja"),
  VonSim = c("Medio", "Medio", "Media", "Medio", "Media", "Muy buena", "Media"),
  Emu8086 = c("Fácil", "Alto", "Completa", "Alta", "Completa", "Buena", "Alta")
)

tabla <- kable(tabla_comparativa,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Comparativa según criterios de evaluación preestablecidos",
               col.names = c("Criterio de Evaluación", "Simple 8 bit", "VonSim", "Emu8086"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("l", "c", "c", "c"))

tabla <- kable(tabla_comparativa,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Comparativa según criterios de evaluación preestablecidos",
               col.names = c("Criterio de Evaluación", "Simple 8 bit", "VonSim", "Emu8086"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c", "c"))

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tabla_comparativa)),
             extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "20em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "15em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

## Resultados
La asignatura promueve el uso de simuladores para apoyar la enseñanza y el aprendizaje, permitiendo aplicar los contenidos desarrollados en máquinas reales. Emu8086 es la herramienta más adecuada para esta finalidad, ya que facilita la implementación de programas en hardware real. Sin embargo, su dependencia de MS-DOS complica su ejecución en sistemas operativos actuales, requiriendo el uso de emuladores de MS-DOS, lo que añade complejidad al proceso de enseñanza y aprendizaje.

Desde 2018, la asignatura utiliza la versión 4.08 de Emu8086. La herramienta tiene un periodo de evaluación gratuito de 14 días, después del cual se debe adquirir una licencia. Esto es un inconveniente, ya que se busca que los estudiantes puedan acceder a las herramientas de forma libre y gratuita.

Utilizar lenguaje NASM (Netwide Assembler) garantiza soporte tanto para Linux como Windows a través de herramientas libres como GCC (GNU Compiler Collection), generando programas para la arquitectura x86 de 16, 32 y 64 bits.

Emu8086 destaca por su interfaz dinámica, que muestra componentes como la pila, flags, teclado y pantalla solo cuando son necesarios, a diferencia de otros simuladores que presentan todos sus componentes desde el inicio.

Emu8086 sobresale particularmente en los aspectos vinculados a la edición, documentación y control de la ejecución. Su editor permite establecer puntos de ruptura, retroceder una instrucción, y guardar o recuperar programas desde la interfaz. Además, ofrece una documentación extensa, que incluye un repertorio de instrucciones con ejemplos, un tutorial para el aprendizaje del lenguaje ensamblador y un manual detallado del entorno de desarrollo. Estas características lo posicionan como una herramienta completa en términos de acompañamiento a los procesos de enseñanza y aprendizaje.

En el criterio de evaluación cuatro, Emu8086 se destaca por ofrecer una mayor cantidad de controladores para gestionar el flujo de ejecución, como la capacidad de retroceder la ejecución de una instrucción y recargar el programa actual.

En cuanto al nivel de especificación, Emu8086 representa con gran precisión la arquitectura x86, incluyendo soporte para interrupciones del sistema operativo MS-DOS. Esta característica permite simular de manera realista programas que podrían ejecutarse en un entorno compatible, constituyendo una ventaja significativa frente a los otros simuladores analizados.

En el criterio de evaluación seis VonSim se destaca del resto debido a que es licencia libre y posee una comunidad que respalda el proyecto.

En cuanto al último criterio, ninguna de las herramientas evaluadas cubre todos los contenidos que se pretende desarrollar con la ayuda de una herramienta, quedando excluido pasos del ciclo de instrucción y medidas de rendimientos (tiempo de CPU y CPI: ciclo por instrucción).

A partir del análisis comparativo, se destacan las siguientes observaciones clave:

- **Emu8086** presenta la interfaz más intuitiva y completa, con amplia documentación y una simulación precisa de la arquitectura x86. Sin embargo, su licencia privativa y la necesidad de emuladores para su ejecución en sistemas actuales constituyen limitaciones relevantes.
- **VonSim**, con su licencia libre y actualización reciente, representa una alternativa interesante desde una perspectiva de software abierto, aunque su cobertura de contenidos y nivel de especificación son limitados en comparación.
- **Simple 8-bit Assembler Simulator** resulta insuficiente para cubrir los objetivos curriculares de la asignatura, debido a su bajo nivel de complejidad, escasa documentación y capacidades limitadas de simulación.

En conclusión, si bien cada simulador ofrece ventajas puntuales, ninguno logra satisfacer plenamente los requerimientos pedagógicos y técnicos de la asignatura en su totalidad. Por ello, se recomienda continuar utilizando Emu8086 de manera transitoria, mientras se avanza en el desarrollo de un simulador propio que integre sus fortalezas, opere con licencia libre y sea compatible con entornos modernos. Esta iniciativa permitirá una mayor adecuación curricular, accesibilidad tecnológica y sostenibilidad en el tiempo.

### Publicación
Este análisis comparativo fue publicado en el XVII Congreso de Tecnología en Educación y Educación en Tecnología (2022), bajo el título "Herramientas de software para dar soporte en la enseñanza y aprendizaje de la arquitectura x86"[@colombani_herramientas_2022].

Además, durante este proceso se estableció contacto con un desarrollador de VonSim, logrando implementar mejoras significativas, como animaciones de ejecución y documentación en línea, disponibles en su última versión publicada en agosto de 2023.

<!--chapter:end:04-comparativa.Rmd-->

# Diseño y Construcción del Simulador {#desarrollo}
En este capítulo se describe el diseño y desarrollo de una herramienta de simulación específica para la arquitectura x86, orientada a facilitar la enseñanza de los principios de arquitectura de computadoras. Se detalla la justificación del diseño, los pasos seguidos para su construcción y los métodos utilizados para validar su funcionalidad.

En el capítulo anterior se analizaron y evaluaron las herramientas de simulación existentes para la arquitectura x86. Esta revisión exhaustiva permitió identificar las limitaciones de las soluciones actuales y fundamentar la necesidad de desarrollar una herramienta específica (véase el capítulo \@ref(comparativa)).

A partir de esta necesidad, se establecieron un conjunto de requisitos funcionales y pedagógicos que guiaron de manera integral el diseño, la implementación y la validación del simulador. Estos requisitos no solo responden a las limitaciones observadas en herramientas existentes, sino que se alinean con los objetivos educativos previamente definidos.

## Requisitos de la herramienta y su fundamentación
Esta sección expone los requisitos que orientaron el diseño del simulador, clasificados en dos dimensiones complementarias: pedagógica y funcional. La primera se vincula con los objetivos formativos definidos en el capítulo introductorio (\@ref(intro)), mientras que la segunda refiere a las características técnicas necesarias para garantizar su implementación eficaz. Su definición se apoyó en principios pedagógicos y técnicos, y se complementó con una validación empírica basada en entrevistas semiestructuradas a docentes expertos. Este proceso permitió identificar necesidades concretas del aula, así como carencias en las herramientas existentes (ver Anexo A \@ref(anexoA)). La aplicación de una metodología cualitativa, centrada en entrevistas semiestructuradas a docentes expertos, permitió identificar necesidades auténticas del aula y carencias específicas en las herramientas existentes. Estos hallazgos aportaron una base empírica rigurosa para la formulación técnica y pedagógica de los requisitos que guían el diseño del simulador [@huberman2019qualitative].

1. **Visualización de la estructura general de la computadora:**
Incluir una representación gráfica de la arquitectura básica de la computadora —compuesta por CPU, buses, memoria y dispositivos de entrada/salida— durante la ejecución de los programas. La visualización debe destacar los componentes activos en cada etapa del ciclo de ejecución, facilitando una comprensión sistémica e integrada del funcionamiento de la computadora. El uso de representaciones gráficas como recurso didáctico está respaldado por estudios que demuestran su efectividad para facilitar la comprensión de conceptos abstractos en disciplinas técnicas [@sorva2013visualizations]. La Figura \@ref(fig:diagramasimulador) presenta un diagrama estructural que representa los principales módulos del simulador y sus interacciones. Este recurso visual permite integrar, de forma esquemática, los componentes funcionales implementados y su correspondencia con los objetivos pedagógicos definidos.

```{r diagramasimulador, echo=FALSE, fig.cap="Estructura del simulador y componentes funcionales", fig.align = 'center', out.width = "90%"}
knitr::include_graphics("images/estructurasimulador.png")
```

2. **Soporte para la generación y ejecución de programas en ensamblador:**
Incorporar la posibilidad de ejecutar programas escritos en lenguaje ensamblador tanto de forma paso a paso como en ejecución continua. Esta funcionalidad posibilita el análisis detallado de cada instrucción, fortaleciendo competencias en trazado y depuración de código ensamblador, fundamentales para comprender la relación entre software y hardware.
La inclusión de un editor de ensamblador con resaltado de sintaxis y autocompletado mejora la experiencia del usuario, facilitando la escritura y comprensión del código. Esta funcionalidad se basa en principios de diseño de interfaces que promueven la usabilidad y la accesibilidad [@w3c_accessibility_2021]. El editor debe permitir al usuario escribir, editar y guardar programas en ensamblador, así como ejecutar estos programas dentro del simulador. La incorporación de entornos de desarrollo integrados (IDEs) en contextos educativos ha demostrado ser eficaz para la enseñanza de lenguajes de programación, según diversos estudios [@mccracken2001does].

```{r editor, echo=FALSE, fig.cap="Editor ensamblador", fig.align = 'center', out.width = "90%"}
knitr::include_graphics("images/editor.png")
```

3. **Repertorio reducido de instrucciones con activación progresiva:**
Se selecciona un subconjunto esencial del conjunto de instrucciones x86, el cual se habilita en etapas secuenciales del proceso de enseñanza, en correspondencia con el avance de los contenidos curriculares. Esta decisión se fundamenta en principios de la psicología cognitiva que sugieren que la introducción escalonada de contenidos técnicos mejora la retención y reduce la sobrecarga cognitiva [@nationalacademies2018how]. Esta estrategia también se encuentra respaldada por autores como Hasan [@hasan_survey_2012], Null y Lobur [@null_essentials_2023], y Stallings [@stallings_computer_2021], quienes proponen abordajes similares en la enseñanza de arquitecturas complejas.
    ```{r activacionprogresiva, echo=FALSE, message=FALSE, warning=FALSE}
    library(knitr)
    library(kableExtra)

    # Crear los datos de la tabla de activación progresiva
    activacionprogresiva <- data.frame(
      Fase = c("Inicial", "Intermedia", "Avanzada"),
      `Instrucciones activadas` = c(
        "MOV, ADD, SUB, HLT",
        "CMP, JMP, JZ, JC",
        "CALL, RET, INT, IRET, CLI, STI, IN, OUT, POP, PUSH, INC, DEC, AND, OR"
      ),
      `Objetivo didáctico` = c(
        "Comprensión del ciclo de instrucción básico",
        "Introducción a control de flujo",
        "Manejo de periféricos e interrupciones"
      )
    )

    tabla_activacion <- kable(activacionprogresiva,
                  format = ifelse(knitr::is_latex_output(), "latex", "html"),
                  caption = "Activación progresiva del repertorio de instrucciones",
                  col.names = c("Fase", "Instrucciones activadas", "Objetivo didáctico"),
                  booktabs = TRUE,
                  escape = FALSE,
                  align = c("c", "c", "c"))

    if (knitr::is_latex_output()) {
      tabla_activacion %>%
        kable_styling(
          latex_options = c("scale_down", "hold_position"),
          font_size = 10,
          position = "right"
        ) %>%
        column_spec(1, width = "2cm", bold = TRUE, border_right = TRUE) %>%
        column_spec(2, width = "4cm") %>%
        column_spec(3, width = "6cm") %>%
        row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
        row_spec(seq_len(nrow(activacionprogresiva)),
                 extra_latex_after = "\\addlinespace[10pt]")
    } else {
      tabla_activacion %>%
        kable_styling(
          bootstrap_options = c("striped", "hover", "condensed", "responsive"),
          full_width = FALSE,
          position = "center"
        ) %>%
        column_spec(1, width = "12em", bold = TRUE, border_right = TRUE) %>%
        column_spec(2:3, width = "28em") %>%
        row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
    }
    ```
Una vez establecido el repertorio esencial, se plantea avanzar hacia una comprensión más profunda del ciclo de instrucción mediante su representación en el nivel microarquitectónico. Esta representación incluirá la visualización dinámica de registros activos y señales de control, en correspondencia directa con la ejecución de cada instrucción. Este enfoque promueve el desarrollo progresivo de competencias, al mitigar la sobrecarga cognitiva que implicaría abordar de forma prematura el repertorio completo de instrucciones. La activación progresiva del repertorio se fundamenta en teorías de aprendizaje que sugieren que la exposición gradual a nuevos conceptos mejora la comprensión y retención [@sweller2010cognitive]. Además, esta estrategia se alinea con las recomendaciones de autores como Null y Lobur [@null_essentials_2023], quienes destacan la importancia de introducir los conceptos de forma escalonada para facilitar el aprendizaje efectivo.

4. **Simulación visual e interactiva de micropasos de instrucciones:**
Se implementa una visualización interactiva del flujo de datos basada en el modelo de Nivel de Transferencia entre Registros (Register Transfer Level, RTL). Este enfoque permite representar con precisión el desplazamiento de datos entre registros, buses y unidades funcionales del procesador, así como las señales de control involucradas en cada fase del ciclo de instrucción [@ASMVisualizer2025; @harris2015digital]. Stallings [@stallings_computer_2021] propone utilizar el modelo RTL para representar el ciclo de instrucción, desde la captura (fetch) hasta la ejecución (execute), facilitando la visualización del recorrido de datos y de las señales de control en cada etapa del proceso. 
Como complemento a la descripción anterior, la Figura \@ref(fig:cicloinstruccion) ilustra un ciclo de instrucción típico utilizando la operación MOV AL, BL como ejemplo. Esta representación facilita la identificación de las etapas *fetch*, *decode* y *execute*, así como los registros que participan activamente en cada fase.

```{r cicloinstruccion, echo=FALSE, fig.cap="Ciclo de instrucción: captación y ejecución", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/cicloinstruccion.png")
```
    
5. **Gestión básica de interrupciones y periféricos:**
Incluir un vector de interrupciones predefinido que simule eventos externos, como la entrada de datos mediante teclado o la salida de información a través de un monitor. Estas interacciones permiten emular situaciones reales de asincronía, esenciales para la comprensión de mecanismos como la interrupción del flujo de ejecución. Esta funcionalidad tiene un alto valor pedagógico, ya que permite al estudiante explorar de forma interactiva conceptos fundamentales como la asincronía, el manejo de eventos y la interrupción del flujo secuencial de ejecución, los cuales son característicos del diseño de arquitecturas modernas y fundamentales para comprender el funcionamiento de sistemas reales. Su inclusión se alinea con las recomendaciones de autores como Null y Lobur [@null_essentials_2023], quienes destacan el valor de abordar estos conceptos en etapas tempranas de la formación. Además, se incorpora un módulo genérico de entrada/salida programada (Programmed Input/Output, PIO), que actúa como interfaz entre la CPU y los dispositivos periféricos. Este módulo permite simular operaciones mediante instrucciones como IN y OUT, facilitando la interacción del estudiante con dispositivos representados gráficamente, como interruptores y teclas. De esta forma, se promueve una comprensión más tangible de los mecanismos subyacentes al intercambio de información entre el procesador y los dispositivos externos.

```{r perifericos, echo=FALSE, fig.cap="Módulo genérico de entrada/salida programada", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/perifericos.png")
```

6. **Métricas de rendimiento:**
Incluir indicadores clave como tiempo de ciclo, tiempo de CPU y ciclos por instrucción (CPI), generados automáticamente a partir de la ejecución de los programas. stos indicadores permiten al estudiante analizar cuantitativamente la eficiencia de la ejecución de un programa, facilitando comparaciones entre diferentes implementaciones. Su inclusión apunta a fortalecer la comprensión de aspectos clave del rendimiento del procesador, promoviendo una formación integral que contemple tanto aspectos funcionales como métricos del comportamiento del sistema [@hennessy2017computer].

```{r metricas, echo=FALSE, fig.cap="Métricas de rendimiento", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/metricas.png")
```

7. **Interfaz intuitiva y experiencia de usuario:**
Diseñar una interfaz gráfica de usuario (GUI) intuitiva, accesible y coherente con principios de usabilidad. La organización visual debe facilitar la navegación, la comprensión del flujo de datos y la ejecución de tareas pedagógicas sin distracciones. Se recomienda el uso de colores, etiquetas y animaciones para reforzar el aprendizaje visual, especialmente para representar cambios de estado del sistema y flujos de control [@w3c_accessibility_2021].

8. **Documentación y recursos de apoyo:**
Proporcionar documentación clara y accesible que explique el funcionamiento del simulador, sus componentes y las instrucciones disponibles. Esta documentación debe incluir ejemplos prácticos, guías de uso y recursos adicionales para facilitar la comprensión y el aprendizaje autónomo. La inclusión de tutoriales interactivos y ejemplos prácticos es fundamental para guiar al estudiante en el uso efectivo del simulador, promoviendo un aprendizaje activo y reflexivo [@bonwell1991active].

```{r documentacion, echo=FALSE, fig.cap="Documentación on line", fig.align = 'center', out.width = "90%"}
knitr::include_graphics("images/documentacion.png")
```

Estos requisitos funcionales y pedagógicos se fundamentan en principios de diseño instruccional y psicología cognitiva, y fueron validados mediante entrevistas con docentes expertos en la materia. A través de reuniones y talleres de validación donde se analizaron prototipos tempranos y necesidades concretas del aula, garantizando así su relevancia didáctica y su adecuación al contexto educativo de la asignatura Arquitectura de Computadoras.

En conjunto, estos requisitos orientan el diseño del simulador para maximizar su impacto pedagógico y su utilidad como recurso de apoyo a la enseñanza de arquitectura x86. En la siguiente sección se describe cómo fueron implementados funcionalmente estos requisitos, detallando su correspondencia con la estructura modular del simulador. La Tabla \@ref(tab:requisitosresumen) resume los principales requisitos funcionales del simulador, junto con los componentes específicos que los implementan.

```{r requisitosresumen, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear los datos de la tabla de requisitos y fundamento
requisitosresumen <- data.frame(
  Requisito = c(
    "Visualización de estructura",
    "Ejecución de programas en ensamblador",
    "Repertorio progresivo de instrucciones",
    "Simulación visual de micropasos",
    "Módulo de Entrada/Salida + Vector de interrupciones"
  ),
  Fundamento = c(
    "Comprensión sistémica del hardware",
    "Desarrollo de competencias en lenguaje ensamblador",
    "Disminución de sobrecarga cognitiva",
    "Comprensión del flujo interno de datos",
    "Simulación de asincronía real"
  )
)

tabla_requisitos <- kable(requisitosresumen,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Resumen de requisitos funcionales y su fundamentación pedagógica",
               col.names = c("Requisito", "Fundamento pedagógico"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c"))

if (knitr::is_latex_output()) {
      tabla_requisitos %>%
        kable_styling(
          latex_options = c("scale_down", "hold_position"),
          font_size = 10
        ) %>%
        column_spec(1, width = "5cm", bold = TRUE, border_right = TRUE) %>%
        column_spec(2, width = "8cm") %>%
        row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
        row_spec(seq_len(nrow(requisitosresumen)),
                 extra_latex_after = "\\addlinespace[10pt]")
    } else {
      tabla_requisitos %>%
        kable_styling(
          bootstrap_options = c("striped", "hover", "condensed", "responsive"),
          full_width = FALSE,
          position = "center"
        ) %>%
        column_spec(1, width = "16em", bold = TRUE, border_right = TRUE) %>%
        column_spec(2, width = "32em") %>%
        row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
    }
```

### Fundamentación de los requisitos del simulador
A partir de los requisitos funcionales detallados anteriormente, se llevó a cabo un proceso colaborativo de análisis con docentes^[Docentes: Marcelo A. Colombani y Amalia G. Delduca] de la asignatura Arquitectura de Computadoras, quienes aportaron su experiencia docente para identificar los elementos de la arquitectura x86 que resultaban prioritarios para representar, simplificar o adaptar en función de los objetivos pedagógicos del simulador. Este análisis condujo a la elección de una arquitectura simplificada de 8 bits, cuyas características se describen más adelante, justificado por su valor didáctico: una arquitectura de 8 bits permite reducir significativamente la complejidad del modelo, sin comprometer la enseñanza de conceptos fundamentales como el ciclo de instrucción, la manipulación de registros o el manejo de interrupciones, permitiendo representar procesos clave con mayor claridad y menor carga cognitiva. La menor cantidad de líneas de datos, registros y operaciones simplifica la visualización de procesos como la ejecución de instrucciones, el flujo de datos y el manejo de interrupciones, favoreciendo la comprensión por parte del estudiante en etapas iniciales del aprendizaje.

La arquitectura x86 se caracteriza por su elevada complejidad, derivada de su extenso repertorio de instrucciones y sus múltiples características avanzadas. Frente a este panorama, el diseño del simulador adopta un enfoque instruccional basado en tres principios pedagógicos clave:

- **Reducir la carga cognitiva**: la simplificación del repertorio y de los componentes permite a los estudiantes enfocarse en principios fundamentales.
- **Aprendizaje progresivo**: se adopta un enfoque escalonado, empezando con un modelo simplificado y avanzando hacia representaciones más completas de x86.
- **Claridad pedagógica**: las prácticas son manejables en términos de tiempo y esfuerzo, favoreciendo un aprendizaje activo, centrado en la resolución progresiva de problemas y libre de sobrecarga cognitiva excesiva.

### Beneficios de la simplificación
El diseño del simulador contribuye a:

- **Comprensión fundamental**: los estudiantes pueden enfocarse en el ciclo de instrucciones, interacción de componentes y flujo básico de datos.
- **Análisis crítico**: comparar el modelo simplificado con x86 real fomenta un aprendizaje reflexivo y profundo.
- **Experimentación práctica**: proporciona un entorno accesible para explorar conceptos y corregir errores.

Diversos autores como Patterson & Hennessy [@hennessy2017computer], Tanenbaum [@tanenbaum_structured_2016] y Null [@null_essentials_2023]  coinciden en que el uso de arquitecturas simplificadas, como las de 8 bits, permite a los estudiantes centrarse en los conceptos fundamentales de la arquitectura de computadores sin verse abrumados por la complejidad técnica de arquitecturas reales. Este enfoque hace posible observar la transferencia de datos entre registros y la activación de señales de control en cada etapa, favoreciendo la comprensión del funcionamiento interno del procesador.
El modelo propuesto adopta una arquitectura simplificada de 8 bits, inspirada en los principios de la arquitectura x86 [@intel_microarchitecture_2021], y diseñada con un repertorio reducido de instrucciones. La elección de una arquitectura de 8 bits obedece a criterios pedagógicos, ya que simplifica el modelo sin sacrificar los principios fundamentales del repertorio x86, facilitando así la comprensión progresiva de sus componentes [@patt2019introduction; @majid1999design; @morlan_sap1_2021 ; @Guald_2015_thesis; @silber_tinycpu].

En síntesis, la definición de estos requisitos busca integrar aspectos funcionales, pedagógicos y técnicos en una herramienta que no solo simule el comportamiento del sistema, sino que facilite activamente los procesos de enseñanza y aprendizaje en arquitectura de computadoras. La articulación entre visualización, ejecución progresiva y análisis de rendimiento proporciona un entorno didáctico rico que responde tanto a las necesidades del aula como a los desafíos de la disciplina.

## Diseño del Simulador
El simulador implementado adopta la arquitectura de Von Neumann, reconocida por su simplicidad conceptual y operativa. En este modelo, los datos y las instrucciones comparten una única memoria, lo que permite tratar las instrucciones como datos. Esta característica facilita técnicas como la ejecución dinámica y la optimización del rendimiento [@stallings_computer_2021].

VonSim^[VonSim: https://vonsim.github.io/] sirvió como referencia por su enfoque educativo e interfaz intuitiva. Sobre esta base se desarrolló VonSim8^[VonSim8: https://ruiz-jose.github.io/VonSim8/], adaptado para operar con registros y memoria de 8 bits y diseñado para el aprendizaje progresivo [@vonsim].

La arquitectura detallada de VonSim, con su amplio repertorio de instrucciones y componentes, ofrece una visión integral del sistema. Sin embargo, dicha riqueza funcional puede abrumar a estudiantes en etapas iniciales. Por esta razón, VonSim8 introduce una simplificación estrategica, con el objetivo de reducir la carga cognitiva en etapas iniciales, facilitando así una apropiación gradual de los conceptos fundamentales. A partir de esta base, se introdujeron diversas modificaciones en los componentes, instrucciones y funcionalidades del simulador, priorizando aquellos aspectos conceptuales que se abordan en el programa de la asignatura.

VonSim [@vonsim] es una herramienta diseñada específicamente para la enseñanza y el aprendizaje de la arquitectura y organización de computadoras. Sus principales características la posicionan como una solución educativa integral:

**Características técnicas y pedagógicas de VonSim:**

1. **Entorno integrado de desarrollo y simulación:** Proporciona un entorno completo que incluye editor de código ensamblador con resaltado de sintaxis y un simulador para la ejecución de programas, facilitando el proceso de aprendizaje práctico [@vonsim].

2. **Fundamento en arquitectura real:** Se basa en el procesador Intel 8088, proporcionando una referencia histórica y técnicamente relevante para el estudio de la evolución de las arquitecturas de computadoras [@intel8086manual].

3. **Componentes esenciales para el estudio:** Incluye cuatro registros multipropósito de 16 bits, memoria principal de 32 kB, bus de direcciones de 16 bits y bus de datos de 8 bits, abarcando los elementos fundamentales para la comprensión de la arquitectura von Neumann [@stallings_computer_2021].

4. **Gestión completa de interrupciones:** Implementa tanto interrupciones por software (entrada/salida de datos) como interrupciones por hardware mediante un controlador de interrupciones programable (PIC), cubriendo aspectos fundamentales de la operación del sistema [@hennessy2017computer].

5. **Simulación de periféricos:** Incorpora dispositivos como reloj, llaves, LEDs e impresora Centronics, inspirados en los especificados por la familia iAPX 88 de Intel, permitiendo simular interacciones complejas con el sistema.

6. **Enfoque pedagógico mediante simplificaciones estratégicas:** No pretende ser un emulador fiel del 8088, sino una herramienta educativa que implementa simplificaciones deliberadas (repertorio de instrucciones reducido y codificación simplificada) para facilitar la comprensión en contextos educativos [@patt2019introduction].

7. **Desarrollo académico especializado:** Creado por Facundo Quiroga, Manuel Bustos Berrondo y Juan Martín Seery, con colaboración de Andoni Zubimendi y César Estrebou, específicamente para las cátedras de Organización de Computadoras y Arquitectura de Computadoras de la Facultad de Informática de la Universidad Nacional de La Plata, garantizando su alineación con objetivos curriculares específicos.

8. **Fundamento en experiencia previa:** Se apoya en el simulador MSX88, desarrollado en 1988 por Rubén de Diego Martínez para la Universidad Politécnica de Madrid, aprovechando décadas de experiencia acumulada en simuladores educativos.

9. **Accesibilidad y sostenibilidad:** Distribuido bajo licencia GNU Affero General Public License v3.0 con código fuente disponible en GitHub, y documentación bajo licencia CC BY-SA 4.0, facilitando su estudio, modificación y mejora continua [@opensource_licensing_2024].

En síntesis, VonSim constituye una herramienta robusta y accesible que simplifica y facilita el aprendizaje de conceptos complejos de arquitectura de computadoras mediante simulación práctica y una interfaz pedagógicamente orientada.

Las modificaciones principales de VonSim8, alineadas con objetivos pedagógicos, incluyen:


El registro de estado contiene los siguientes flags o banderas:
Z = cero (Zero)
C = acarreo (Carry)
S = signo (Sign)
O = desbordamiento (Overflow)
I = interrupción (Interrupt)

### Flags

El registro `FLAGS` es un registro de 8 bits que contiene las _flags_ mostradas en la siguiente tabla. Este registro no es directamente accesible por el usuario, pero puede ser modificado por las operaciones de la ALU y pueden realizarse saltos condicionales en base a sus valores.

| Bit # | Abreviatura | Descripción            |
| :---: | :---------: | :--------------------- |
|   0   |    `Z`     | _Flag_ de cero         |
|   1   |    `C`     | _Flag_ de acarreo      |
|   2   |    `O`     | _Flag_ de overflow     | 
|   3   |    `S`     | _Flag_ de signo        |
|   4   |    `I`     | _Flag_ de interrupción |

El resto de bits del registro de estado están reservados.

Del registro de estado del simulador original se ocultaron las banderas O y S ya que en los primeros ejercicios de ensamblador no se requiere su uso ya que se trabaja solamente con números enteros positivos, posteriormente las mismas se pueden habilitar en el menu configuración del simulador. 

```{r banderas, echo=FALSE, fig.cap="Registro de estado", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/flags.png")
```

El flag de interrupcion I solo se muestra cuando el programa lo requiere, por ejemplo, al ejecutar una instrucción de interrupción como `INT` o `IRET`. Esto permite a los estudiantes observar cómo se activa y desactiva este flag en función de las operaciones realizadas.

```{r banderaI, echo=FALSE, fig.cap="Registro de estado I", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/flagi.png")
```

Se modifico el menu de los controles del simulador.
```{r controles, echo=FALSE, fig.cap="Controles del simulador", fig.align = 'center', out.width = "85%"}    
knitr::include_graphics(path = "images/controles.png")
```

Se eliminaron los registros de 16 bits y se redujo el tamaño de los registros a 8 bits, lo que simplifica la representación y manipulación de datos. Esta decisión se fundamenta en la necesidad de reducir la complejidad del modelo para facilitar la comprensión de los conceptos fundamentales de la arquitectura de computadoras. Tambien se unifico el criterio del diseño de los registro, ahora todos los registros tienen una entrada y una salida independiente, lo que permite una visualización más clara de cómo se transfieren los datos entre los registros y la ALU (Unidad Aritmético Lógica). Esta modificación es esencial para comprender el flujo de datos en el ciclo de instrucción y la interacción entre los componentes del procesador. Tambien se ocultaron los registros registro SP y  (`ri` e `id`) que se habilitan automaticamente al ejecutar una instrucción que requiera su uso. 

```{r registros, echo=FALSE, fig.cap="Registro de 8 bits", fig.align = 'center', out.width = "85%"}    
knitr::include_graphics(path = "images/registros.png")
```

Se elimino el uso de los registros temporales de la ALU (`left` y `rigth`).
Por una cuestion de diseño del simulador algunos registros tienen la entrada y salida de manera horizontal y otros vertical, pero su funcionamiento es el mismo.

```{r leftrigth, echo=FALSE, fig.cap="Eliminación registro temporales left y rigth", fig.align = 'center', out.width = "85%"}    
knitr::include_graphics(path = "images/leftrigth.png")
```

La memoria principal se modela como una matriz de 16×16 expresada en hexadecimal, lo que permite almacenar hasta 256 bytes de datos.

```{r memoriacomp, echo=FALSE, fig.cap="Memoria principal", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/memoriacomp.png")
```

Resaldo de la direccion de memoria apuntada por el registro IP.

```{r resaltadoip, echo=FALSE, fig.cap="Resaltado registro IP", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/resaltadoip.png")
```

Cuando el progrma tiene instrucciones INT o de manejo de pila se resalta en memoria el el vector de interrucciones, 8 posiciones de memoria desde ` 0x00` a ` 0x07` y la dirección apuntada por el registro SP:

```{r resaltadointsp, echo=FALSE, fig.cap="Resaltado vector de interrupciones y registro SP", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/resaltadointsp.png")
```

Visor de instrucciones y datos del programa en memoria, pudiendo ver la instruccion y su tamaño en bytes que ocupa en memoria, ademas la etiqueta asociada a los datos.

```{r visorprog, echo=FALSE, fig.cap="Resaltado vector de interrupciones y registro SP", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/visorprog.png")
```

En el VonSim cuando se escribe un programa en el editor del simulador es obligatorio que la sección de codigo inicie con la directiva `org 0x2000h`, porque el simulador comienza a ejecutar la primer instrucción del programa a partir de la dirección de memoria `0x2000h`, esto se indica al comienzo del programa mediante la directiva `org 0x2000h` y los datos del programa generalmente se cargan a partir de la dirección de memoria `0x1000h` mediante la directiva `org 0x1000h`.

En VonSim8 no es obligatorio la directiva `org` para indicar la dirección de inicio del programa sino opcional, por default si el programa no tiene la directiva `org` la primer instruccion del programa comienza a cargarse en la dirección `0x00h`, y en caso que el programa tenga instrucciones de interrupcion `INT` el programa se cargará a partir de la direccion `0x08h` para dejar espacio al vector de interrupciones.
VonSim8 tambien permite cargar el programa de manera similar como VonSim pero en utilizar la directiva `org 0x2000h` utiliza org `0x20h` y el simulador comienza a ejecutar la instruccion que se encuentra en la dirección `0x20h` de la memoria vez de cargar en la posicion ya que el simulador asigna automáticamente la dirección 0x00 al primer byte del programa. Esto simplifica la escritura de programas y evita errores comunes relacionados con la asignación manual de direcciones.

Pero si el programa requiere una dirección de inicio específica, se puede utilizar la directiva `org` para establecerla. Por ejemplo, `org 0x20h` indicaría que el programa debe comenzar en la dirección 0x20 de la memoria. Por compatibilidad con el simulador VonSim, se mantiene la directiva `org` para aquellos usuarios que deseen especificar una dirección de inicio diferente a la predeterminada. Sino se especifica la directiva `org` en el programa el simulador comienza a ejecutar el programa desde la dirección `0x00h`, en caso de que el programa tenga instrucciones de interrupción `INT`, el simulador asigna automáticamente la dirección `0x08h` al primer byte del programa, dejando espacio para el vector de interrupciones.

El simulador tiene predefinido el vector de interrupción en ciertas posiciones de reservadas de memoria, dentro de dicho vector encontraremos las rutinas del sistema predefinidas para interactuar con el teclado y monitor. 
En el caso de las interrupciones por software, esta es dada por el operando de la instrucción `INT` número. Una vez interrumpido, el procesador ejecutará la rutina de interrupción asociada a ese número de interrupción. La dirección de comienzo de esta rutina estará almacenada en el vector de interrupciones. Este vector ocupa las celdas `00h` hasta `07h` de la memoria principal, y cada elemento del vector tiene 1 byte de largo -- el primer elemento se encuentra en `0h`, el segundo en `1h`, el tercero en `2h`, y así. Cada elemento corresponde con la dirección de inicio de la rutina de interrupción.

Específicamente, el procesador:

1. obtiene el número de la interrupción (0-7),
2. apila el registro `FLAGS`,
3. inhabilita las interrupciones `IF=0`,
4. apila el registro `IP`,
5. obtiene la dirección de la rutina de interrupción del vector de interrupciones,
6. modifica el `IP` para que apunte a la dirección de la rutina de interrupción.

El simulador implementas las interrupciones por software mediante la instrucción `INT <n>`. Estos números son:

- `INT 0`: termina la ejecución del programa, equivalente a la instrucción `HLT`;
- `INT 6`: lee un carácter del teclado;
- `INT 7`: escribe una cadena de caracteres en pantalla.

### Requisitos funcionales del simulador VonSim8

1. Simplificación del repertorio instruccional para una introducción gradual;

2. Reducción a registros y memoria de 8 bits, coherente con la escala de enseñanza;

3. Interfaz gráfica esquemática que muestra el flujo de ejecución;

4. Funciones interactivas para observar explícitamente el ciclo de instrucción y la interacción de componentes.


Las modificaciones implementadas se alinean con los contenidos curriculares de la asignatura y están fundamentadas en los principios del aprendizaje activo [@bonwell1991active].


### Estructura del VonSim8
Esta sección describe la estructura del simulador VonSims8, el diseño de los registros fue concebido para facilitar la comprensión de los modos de direccionamiento y del ciclo de instrucción, ambos considerados fundamentos clave en el estudio de la Arquitectura de Computadoras [@stallings_computer_2021]. Se describe en la siguiente tabla \@ref(tab:estructuravonsim8) los componentes principales del simulador, junto con sus características y funcionalidades específicas. Esta tabla proporciona una visión general de la arquitectura del simulador, destacando los elementos clave que componen su estructura y su propósito pedagógico.:

```{r estructuravonsim8, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear el data frame con los datos del cuadro
estructuravonsim8 <- data.frame(
  `Componente` = c("Arquitectura",
                   "Registros",
                   "",
                   "",
                   "Memoria",
                   "Puertos"),
  `Características` = c("Von Neumann, memoria compartida para datos e instrucciones.", # nolint
                        "4 registros de propósito general de 8 bits (`AL`, `BL`, `CL` y `DL`).", # nolint
                        if (knitr::is_latex_output()) {
                          "6 registros de propósito específico:\\begin{itemize} \\item `IP` (Instruction Pointer) \\item `IR` (Instruction Register) \\item `SP` (Stack Pointer) \\item `RS` (registro de estado) \\item `MAR` (Memory Address Register) \\item `MBR` (Memory Buffer Register) \\end{itemize}" # nolint: line_length_linter.
                        } else {
                          "6 registros de propósito específico:<ul><li>`IP` (Instruction Pointer)</li><li>`IR` (Instruction Register)</li><li>`SP` (Stack Pointer)</li><li>`RS` (registro de estado)</li><li>`MAR` (Memory Address Register)</li><li>`MBR` (Memory Buffer Register)</li></ul>" # nolint: line_length_linter.
                        },
                        "Los registros de propósito general pueden ser accedidos y modificados por el programador. Los específicos son gestionados por la CPU.", # nolint
                        "Memoria principal de 256 bytes, direccionada por un bus de direcciones de 8 bits. Cada posición de memoria almacena un byte. La memoria se organiza en celdas de 16 bits, con una dirección inicial de `0x00` y una dirección final de `0xFF`.", # nolint        
                        if (knitr::is_latex_output()) {
                          "Puertos de la CPU:\\begin{itemize} \\item 8 bits de direcciones de memoria (bus de direcciones, con su respectivo buffer \\texttt{MAR}) \\item 8 bits de datos (bus de datos, con su respectivo buffer \\texttt{MBR}) \\item 1 bit para la señal de lectura \\texttt{rd} \\item 1 bit para la señal de escritura \\texttt{wr} \\item 1 bit para indicar si la escritura es a un módulo de entrada/salida o a memoria principal \\texttt{IO/M} \\item 1 bit para la petición de interrupción \\texttt{INTR} \\item 1 bit para la señal de acknowledge de interrupción \\texttt{INTA} \\end{itemize}"
                        } else {
                          "Puertos de la CPU:<ul><li>8 bits de direcciones de memoria (bus de direcciones, con su respectivo buffer <code>MAR</code>)</li><li>8 bits de datos (bus de datos, con su respectivo buffer <code>MBR</code>)</li><li>1 bit para la señal de lectura <code>rd</code></li><li>1 bit para la señal de escritura <code>wr</code></li><li>1 bit para indicar si la escritura es a un módulo de entrada/salida o a memoria principal <code>IO/M</code></li><li>1 bit para la petición de interrupción <code>INTR</code></li><li>1 bit para la señal de acknowledge de interrupción <code>INTA</code></li></ul>"
                        }, # nolint: line_length_linter.
  stringsAsFactors = FALSE
)

# Crear la tabla con formato dinámico
tabla <- kable(estructuravonsim8,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Estructura VonSim8",
               col.names = c("Componente", "Características"),
               booktabs = TRUE,
               escape = FALSE)

# Mostrar la tabla en formato adecuado según el tipo de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "9cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(estructuravonsim8)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "25em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "40em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Dentro de los registros específicos que no pueden ser accedidos por el usuario, se encuentra el registro `SP` (_stack pointer_) para el funcionamiento de la pila, el registro `FLAGS` (_flags register_), el `IP` (_instruction pointer_) que almacena la dirección de la próxima instrucción a ejecutar, el `IR` (_instruction register_) que almacena el byte de la instrucción que se está analizando/decodificando en un instante dado. También hay 2 registros dedicados a la transferencia de información entre la CPU y la memoria principal: el `MAR` (_memory address register_) encargado de almacenar direcciones de memoria, y el `MBR` (_memory buffer register_) que almacena el byte que se quiere propagar o se ha recibido por el bus de datos.

Además, dos registros específicos que sirven de intermediarios para realizar ejecutar instrucciones, como pueden ser el `ri` para almacenar una dirección temporal, el `id` para almacenar un dato temporal. 

## Unidad de Control

La unidad de control es responsable de coordinar todas las operaciones de la CPU. Se encarga de:

- **Decodificación de instrucciones**: Interpreta el código de operación de cada instrucción
- **Generación de señales de control**: Activa las señales necesarias para ejecutar microoperaciones
- **Secuenciación**: Controla el orden de ejecución de las operaciones

### Memoria de Control

Para una comprensión más profunda de cómo funciona la unidad de control, puedes visualizar la memoria de control que muestra las microinstrucciones y microoperaciones de cada instrucción.

### Secuenciador

El secuenciador complementa la memoria de control mostrando cómo se controla la secuencia de microoperaciones y las señales de control generadas en cada fase del ciclo de instrucción.

## Instrucciones
El simulador VonSim8 implementa un repertorio reducido de instrucciones, diseñado para facilitar la comprensión de los conceptos fundamentales de la arquitectura de computadoras. Este repertorio incluye instrucciones aritméticas, lógicas, de transferencia de datos y control de flujo, permitiendo a los estudiantes familiarizarse con las operaciones básicas sin abrumarse con la complejidad del conjunto completo de instrucciones x86.

El repertorio de instrucciones incluye operaciones aritméticas, lógicas, de transferencia de datos y control de flujo. Las instrucciones poseen una longitud variable (1, 2 o 3 bytes) y admiten diversos modos de direccionamiento: registro a registro, directo, indirecto e inmediato.

## ALU

La ALU (_Arithmetic Logic Unit_) permite realizar operaciones aritméticas y lógicas de 8 bits. Las operaciones disponibles son: `ADD`, `INC`, `SUB`, `DEC`, `NEG`, `NOT`, `AND` y `OR`. Todas estas operaciones modifican el registro `FLAGS`.

### Flags

El registro `FLAGS` es un registro de 8 bits que contiene las _flags_ mostradas en la siguiente tabla. Este registro no es directamente accesible por el usuario, pero puede ser modificado por las operaciones de la ALU y pueden realizarse saltos condicionales en base a sus valores.

| Bit # | Abreviatura | Descripción            |
| :---: | :---------: | :--------------------- |
|   0   |    `CF`     | _Flag_ de acarreo      |
|   6   |    `ZF`     | _Flag_ de cero         |
|   7   |    `SF`     | _Flag_ de signo        |
|   9   |    `IF`     | _Flag_ de interrupción |
|  11   |    `OF`     | _Flag_ de overflow     |

El resto de bits están reservados / no se utilizan.

## Pila

El procesador implementa la pila como método de almacenamiento accesible por el usuario y por la misma CPU para su correcto funcionamiento. Esta es del estilo _Last In, First Out_ (LIFO), es decir, el último elemento en entrar es el primero en salir. La pila se encuentra en la memoria principal, comenzando en la dirección más alta de la misma (`FFh`) y creciendo hacia las direcciones más bajas (`FEh`, `FCh`, etc.). El tope de la pila se guarda en el registro `SP`. Todos los elementos de la pila son de 8 bits.

## Subrutinas

El procesador también implementa subrutinas. Estas son pequeños fragmentos de código que pueden ser llamados desde cualquier parte del programa. Para ello, se utiliza la instrucción [`CALL`](./instructions/call). Esta instrucción almacena el `IP` en la [pila](#pila), y luego realiza un salto a la dirección de la subrutina, modificando el `IP` para que este apunte a la primera instrucción de la subrutina. Para volver de la subrutina, se utiliza la instrucción [`RET`](./instructions/ret), que desapila la dirección apilada previamente por `CALL` y restaura el `IP`, volviendo a el punto de ejecución posterior a la llamada a la subrutina.

Ejemplo de subrutina:

```vonsim
      mov al, 1
      mov bl, 2
      mov cl, 3
      call sum3
      ; ax = 6
      hlt

      ; suma al, bl y cl
      sum3: add al, bl
            add al, cl
            ret
```

## Interrupciones

El procesador admite interrupciones por hardware y por software, que pueden ser emitidas por el PIC o por la instrucción `INT` respectivamente. Para ejecutar interrupciones por hardware, el procesador debe estar habilitado para recibir interrupciones. Esto es, `IF=1` (la _flag_ de interrupciones activada).

Ambas interrupciones deben propocionar un número de interrupción. En el caso de las interrupciones por software, esta es dada por el operando de la instrucción `INT`. En el caso de las interrupciones por hardware, esta es dada por el PIC. El número de interrupción debe ser un número entre `0` y `7`.

Una vez interrumpido, el procesador ejecutará la rutina de interrupción asociada a ese número de interrupción. La dirección de comienzo de esta rutina estará almacenada en el vector de interrupciones. Este vector ocupa las celdas `00h` hasta `07h` de la memoria principal, y cada elemento del vector tiene 1 byte de largo -- el primer elemento se encuentra en `0h`, el segundo en `1h`, el tercero en `2h`, y así. Cada elemento corresponde con la dirección de inicio de la rutina de interrupción.

Específicamente, el procesador:

1. obtiene el número de la interrupción (0-7),
2. apila el registro `FLAGS`,
3. inhabilita las interrupciones `IF=0`,
4. apila el registro `IP`,
5. obtiene la dirección de la rutina de interrupción del vector de interrupciones,
6. modifica el `IP` para que apunte a la dirección de la rutina de interrupción.

Y así se comienza a ejecutar la rutina de interrupción. Estas tienen el mismo formato que una subrutina salvo que terminan en `IRET` en vez de `RET`.

### Llamadas al sistema

El simulador permite realizar llamadas al sistema o _syscalls_. En el simulador, estas llamadas son realizadas idénticamente a las interrupciones. Así, para realizar una _syscall_ basta con interrumpir a la CPU con el número de interrupción correspondiente. Estos números son:

- `INT 0`: termina la ejecución del programa, equivalente a la instrucción `HLT`;
- `INT 6`: lee un carácter del teclado;
- `INT 7`: escribe una cadena de caracteres en pantalla.

Las direcciones del vector de interrupciones asociadas a estos números están protegidas por el sistema, impidiendo que el usuario las modifique.

El contenido de estas rutinas se encuentran almacenadas en el monitor del sistemaen las direcciones `A0h`, `B0h` y `C0h` respectivamente.



La Figura \@ref(fig:esquemavonsim8) presenta una visión esquemática de la arquitectura general del simulador. En ella se distinguen los flujos de datos y de control, representando gráficamente la interacción entre los distintos módulos funcionales durante la ejecución de programas. Dicha representación facilita la comprensión estructural del sistema y su analogía con una arquitectura computacional real, simplificada para fines educativos.

```{r esquemavonsim8, echo=FALSE, fig.cap="Arquitectura general del simulador", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/esquemavonsim8.png")
```

La memoria principal se modela como una matriz de 16×16 expresada en hexadecimal, lo que permite almacenar hasta 256 bytes de datos. Esta capacidad es suficiente para la mayoría de los programas de ejemplo utilizados en el curso, y su diseño simplificado facilita la comprensión de los conceptos fundamentales de la memoria en una computadora.

```{r memoria, echo=FALSE, fig.cap="Memoria principal", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/memoria.png")
```

El bus de datos, direcciones y control se implementa como un conjunto de líneas que permiten la comunicación entre los distintos componentes del sistema. Este bus es esencial para el intercambio de información entre la CPU, la memoria y los dispositivos de entrada/salida, y su diseño modular permite una fácil expansión en futuras versiones del simulador.

```{r buses, echo=FALSE, fig.cap="Buses", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/buses.png")
```

Dentro de los buses interno de la CPU se incluyen circulos que representan circuitos multiplexores, que son componentes clave en la selección de datos y direcciones durante el ciclo de instrucción. Estos multiplexores permiten dirigir las señales adecuadas a los registros y a la ALU (Unidad Aritmético Lógica), facilitando así el flujo de datos dentro del procesador. Un multiplexor (MUX) es un conmutador digital que conecta datos de una de n fuentes a la salida. Están dotados de entradas de control capaces de seleccionar una, y solo una, de las entradas de datos para permitir su transmisión desde la entrada seleccionada hacia dicha salida

El simulador incluye la representación de un teclado y una pantalla con el objetivo de emular la interacción básica entre el usuario y el sistema. El teclado se modela como un vector de 16 posiciones, cada una capaz de almacenar un carácter ASCII. La pantalla, por su parte, se representa como una matriz de 16×16 que permite visualizar caracteres, facilitando así la comprensión del manejo de entrada y salida de datos en una arquitectura computacional simplificada.

```{r tecladopantalla, echo=FALSE, fig.cap="Teclado y pantalla", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/tecladopantalla.png")
```

La elección de estos bloques funcionales responde tanto a la necesidad de modelar componentes esenciales de una computadora real como a criterios pedagógicos de modularidad y claridad conceptual. La Tabla \@ref(tab:bloquesfuncionales) resume los principales bloques que conforman la arquitectura simulada, junto con una breve descripción de su funcionalidad.

```{r bloquesfuncionales, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

bloquesfuncionales <- data.frame(
  Bloque = c("Unidad Central de Procesamiento (CPU)",
             "Memoria",
             "Sistema de Entrada/Salida (E/S)",
             "Bus de datos, direcciones y control"),
  Descripción = c("Simulación de registros, unidad de control (UC) y unidad aritmético-lógica (ALU).", # nolint
                  "Estructura de memoria y simulación de operaciones de lectura y escritura.", # nolint
                  "Interacción con periféricos y manejo de interrupciones.",
                  "Modelado de la comunicación entre componentes.")
)

# Crear la tabla con formato dinámico
tabla <- kable(bloquesfuncionales,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Bloques funcionales principales",
               col.names = c("Bloque Funcional", "Descripción"),
               booktabs = TRUE,
               escape = FALSE)

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "9cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(bloquesfuncionales)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "25em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "40em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

### Repertorio de instruciones
El repertorio de instrucciones se diseñó como una abstracción deliberada inspirada en la arquitectura x86, con el objetivo de optimizar los procesos de enseñanza y aprendizaje en entornos educativos. En una etapa inicial del proceso de enseñanza, se incluyen únicamente aquellas instrucciones esenciales que permiten introducir progresivamente los contenidos básicos de la asignatura Arquitectura de Computadoras. Este enfoque progresivo permite introducir los conceptos fundamentales de manera accesible, minimizando la complejidad innecesaria que podría obstaculizar la comprensión en las etapas iniciales del aprendizaje [@hennessy2017computer; @tanenbaum_structured_2016]. La Tabla \@ref(tab:setreducido) muestra un conjunto reducido de instrucciones que abarca las operaciones más frecuentes y pertinentes para una etapa introductoria de aprendizaje. Este repertorio se centra en las instrucciones de transferencia y procesamiento de datos, así como en las instrucciones de control de flujo, permitiendo al estudiante familiarizarse con los conceptos básicos de la arquitectura x86 sin la complejidad adicional de un repertorio completo.  

Las instrucciones del simulador VonSim8 se dividen en dos categorías principales: las instrucciones de transferencia y procesamiento de datos, y las instrucciones de control de flujo. Las primeras permiten mover datos entre registros y memoria, realizar operaciones aritméticas y lógicas, y manipular el contenido de los registros. Las segundas permiten alterar el flujo de ejecución del programa mediante saltos condicionales e incondicionales, así como la detención del procesador.

Para facilitar el aprendizaje de la programación en ensamblador e introducir el ciclo de instruccion se propone el siguente repertorio de instrucciones, luego cuando se avance sobre los modulos de entrada y salida de acuerdo al programa de estudio de la asignatura Arquitectura de Computadoras [@cd023_25_programa2025].

```{r setreducido, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear los datos
setreducido <- data.frame(
  Instrucciones = c(
    "Transferencia de datos",
    "Procesamiento de datos",
    "",
    "",
    "Control de flujo",
    "",
    "",
    ""
  ),
  `Nemónico` = c(
    "MOV ",
    "ADD",
    "SUB",
    "CMP",
    "JMP",
    "JZ ",
    "JC ",
    "HLT"
  ),
  Acción = c(
   "Copiar",
  "Sumar",
  "Restar",
  "Comparar",
  "Salto incondicional ",
  "Salto condicional si Z=1",
  "Salto condicional si C=1",
  "Detiene CPU"
  )
)

# Crear la tabla con formato dinámico
tabla <- kable(setreducido,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Tabla de instrucciones de VonSim8",
               col.names = c("Instrucciones", "nemónico", "Acción"), # nolint: line_length_linter.
               booktabs = TRUE,
               escape = FALSE)


# Mostrar la tabla en formato adecuado según el tipo de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>% # nolint: line_length_linter.
    column_spec(2, width = "4cm") %>%
    column_spec(3, width = "6cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(setreducido)), extra_latex_after = "\\addlinespace[8pt]") # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "25em", bold = TRUE) %>% # nolint: line_length_linter.
    column_spec(2, width = "15em") %>%
    column_spec(3, width = "25em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

En base a las entrevistas con los docentes y el análisis de los contenidos del curso, a continuación se establece para cada categorías de instrucciones su uso pedagógico esperado:

- **Transferencia y procesamiento de datos**: Instrucciones que permiten mover datos entre registros y memoria y realizar operaciones aritméticas. Estas instrucciones son fundamentales para la comprensión del flujo de datos en una arquitectura computacional mostrando como se llevan a cabo operaciones aritméticas como de lenguaje de alto nivel como Python: 

```python
x=2
y=3
z=0
z = x + y
```

Su traduccion a ensamblador sería:

```{r  codearit, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
  x db 2
  y db 3
  z db 0
  mov AL, x   ;Se carga el valor de x (2) en AL
  add AL, y   ;Se suma el valor de y (3) a AL (2) = 5
  mov z, AL   ;Se guarda el valor del registro AL (5) en z 
  hlt\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
    x db 2
    y db 3
    z db 0
    mov AL, x   ;Se carga el valor de x (2) en AL
    add AL, y   ;Se suma el valor de y (3) a AL (2) = 5
    mov z, AL   ;Se guarda el valor del registro AL (5) en z 
    hlt
    ```")
}
```

- **Control de flujo**: Instrucciones que permiten alterar el flujo de ejecución del programa mediante saltos condicionales e incondicionales, así como la detención del procesador. Estas instrucciones son esenciales para comprender cómo se controlan las decisiones y el flujo de ejecución en un programa. Por ejemplo, permiten implementar estructuras condicionales similares a las de lenguajes de alto nivel como Python:

```python
x=2
y=3
z=0
if x == y:
  z = y  + x
```

Su traduccion a ensamblador sería:

```{r  codeifZ, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
x db 2 
y db 3
z db 0
          mov AL, x
          cmp AL, y
   	      jz EsIgual
  	      jmp Fin
EsIgual:  add AL, y
          mov z, AL 
Fin:      hlt\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
x db 2 
y db 3
z db 0
          mov AL, x
          cmp AL, y
   	      jz EsIgual
  	      jmp Fin
EsIgual:  add AL, y
          mov z, AL 
Fin:      hlt ```")
}
```

```python
x=2
y=3
z=0
if x < y:
  z = y  + x
```

Su traduccion a ensamblador sería:

```{r  codeifC, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
x db 2 
y db 3
z db 0
          mov AL, x
          cmp AL, y
   	      jc EsMenor
  	      jmp Fin
EsMenor:  add AL, y
          mov z, AL 
Fin:      hlt\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
x db 2 
y db 3
z db 0
          mov AL, x
          cmp AL, y
   	      jc EsMenor
  	      jmp Fin
EsMenor:  add AL, y
          mov z, AL 
Fin:      hlt ```")
}
```

Por ejemplo, la estructura iterativa `while` en Python:

```python
x = 0
suma = 0

while x < 10:
    suma = suma + x
    x = x + 1
```


Su traduccion a ensamblador sería:

```{r  codewhile, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
x     db 1   
suma  db 0   
Condicion:  cmp x, 10 
            jc Bucle   		; si x < 10  salta a etiqueta Bucle:
            jmp FinBucle      ; si no salta a la etiqueta FinBucle:
Bucle:      mov BL, x
            add suma, BL
            add x, 1
            jmp Condicion      ; salta a Condicion:
FinBucle: 	hlt
\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
x     db 1   
suma  db 0   
Condicion:  cmp x, 10 
    	      jc Bucle   		; si x < 10  salta a etiqueta Bucle:
            jmp FinBucle      ; si no salta a la etiqueta FinBucle:
Bucle:      mov BL, x
    	      add suma, BL
	          add x, 1
    	      jmp Condicion      ; salta a Condicion:
FinBucle: 	hlt ```")
}
```

Tratamiento de vectores: El simulador permite trabajar con vectores y matrices, lo que facilita la comprensión de cómo se manejan estructuras de datos más complejas en una arquitectura computacional. Por ejemplo, el siguiente código en Python busca el máximo de un vector:

```python
# Búsqueda del máximo en un vector
vector = [5, 2, 10, 4, 5, 0, 4, 8, 1, 9]
maximo = 0

for i in range(len(vector)):
    if vector[i] > maximo:
        maximo = vector[i]
```

Su traduccion a ensamblador sería:

```{r codevector, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
max     db 0
vector  db 5, 2, 10, 4, 5, 0, 4, 8, 1, 9
            mov CL, 0 ; contador
            mov BL, offset vector  ; obtiene la dirección del primer elemento del vector
Condicion:  cmp CL, 10 
            jc Bucle          ; si x < 10  salta a etiqueta Bucle
            jmp FinBucle      ; si no salta a la etiqueta FinBucle
Bucle:      mov AL, [BL]      ; AL = vector[indice] 
            cmp AL, max
            jc Proximo        ; si AL < max, salta a Proximo
            mov max, AL       ; si no, actualiza max
Proximo:    add BL, 1         ; BL = BL + 1 
            add CL, 1         ; CL = CL + 1            
            jmp Condicion 
FinBucle: 	hlt
\\end{lstlisting}
  ")
} else {
  cat("
    ```assembly
max     db 0
vector  db 5, 2, 10, 4, 5, 0, 4, 8, 1, 9
            mov CL, 0 ; contador
            mov BL, offset vector  ; obtiene la dirección del primer elemento del vector
Condicion:  cmp CL, 10 
            jc Bucle          ; si x < 10  salta a etiqueta Bucle
            jmp FinBucle      ; si no salta a la etiqueta FinBucle
Bucle:      mov AL, [BL]      ; AL = vector[indice] 
            cmp AL, max
            jc Proximo        ; si AL < max, salta a Proximo
            mov max, AL       ; si no, actualiza max
Proximo:    add BL, 1         ; BL = BL + 1 
            add CL, 1         ; CL = CL + 1         
	  	      jmp Condicion 
FinBucle: 	hlt```")
}
```

Estas instrucciones permiten a los estudiantes comprender cómo se ejecutan las operaciones aritméticas en la computadora, cómo se transfieren los datos entre registros y memoria, y cómo se controla el flujo de ejecución de un programa.
Estas categorías de instrucciones se seleccionaron cuidadosamente para proporcionar una base sólida en los conceptos fundamentales de la arquitectura x86, permitiendo a los estudiantes familiarizarse con las operaciones más comunes y relevantes sin la complejidad adicional de un repertorio completo.
Estas categorías se alinean con los objetivos pedagógicos del curso, permitiendo a los estudiantes familiarizarse con los conceptos básicos de la arquitectura x86 sin la complejidad adicional de un repertorio completo. 

A traves de la implementación de estas instrucciones, el simulador VonSim8 busca proporcionar una experiencia de aprendizaje que facilite la comprensión de los principios fundamentales de la arquitectura de computadores, al tiempo que se minimiza la carga cognitiva en las etapas iniciales del aprendizaje. Permite al alumno entender como se ejecutan los operaciones artimeticas en la computadora, como se transfieren los datos entre registros y memoria, y como se controla el flujo de ejecución de un programa.

### Formato de instrucciones
Las instrucciones del simulador VonSim8 se definen con un formato de 1 a 3 bytes, donde el primer byte contiene el código de operación (opcode) y los siguientes bytes pueden contener operandos adicionales según el modo de direccionamiento utilizado. El opcode determina la operación a realizar, mientras que los operandos especifican los datos o registros involucrados en la operación.

```{r formatoinst, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

formatoinst <- data.frame(
  Tipo = c("Transferencia y procesamiento", "Control"),
  Operandos = c("2", "1 / cero"),
  Ejemplo = c("MOV operando-destino, operando-fuente", "JMP operando / HLT"),
  stringsAsFactors = FALSE
)

tabla_kable <- kable(formatoinst,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Tabla de formato de instrucciones",
               col.names = c("Tipo", "Operandos", "Ejemplo"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c"))

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "4cm") %>%
    column_spec(3, width = "7cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(formatoinst)),
             extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "10em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "32em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

### Modos de direccionamiento
Los modos de direccionamiento definidos son:

  - Registro a registro (`Rx`,`Ry`): operandos son registros del procesador y `Rx` indica registro destino y `Ry` indica registro fuente.

  - Directo (`[M]`): un operando es un registro y el otro operando es el contenido de una dirección de memoria `[M]`.

  - Indirecto por registro (`[BL]`): la dirección del operando se encuentra en el registro `[BL]`.

  - Inmediato (`d`): un operando es un valor contenido en la instrucción. 

Estos modos de direccionamiento permiten al simulador representar una variedad de operaciones que abarcan desde la manipulación directa de registros hasta el acceso a memoria, proporcionando una base sólida para la comprensión del flujo de datos en una arquitectura computacional. La Tabla \@ref(tab:modosdireccionamiento) resume los modos de direccionamiento implementados en el simulador, junto con ejemplos de uso y su propósito pedagógico.

```{r modosdireccionamiento, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

modosdireccionamiento <- data.frame(
  Tipo = c("", "",  "Transferencia y procesamiento", "Control"),
  Operación = c("A: Entre registros", "B: Cargar a registro", "C: Almacenar en memoria", "D: control de flujo"),
  Parámetros = c(
    "Operandos son registros Rx, Ry",
    if (knitr::is_latex_output()) {
      "Operando destino es registro Rx y el operando fuente puede ser:\\begin{itemize} \\item dirección [M] (1)\\item dirección registro [BL] (2)\\item valor en la instrucción d  (3)\\end{itemize}" # nolint: line_length_linter.
    } else {
      "Operando destino es registro `Rx` y el operando fuente puede ser:<ul><li>dirección `[M]`</li><li>dirección registro `[BL]`</li><li>valor en la instrucción `d`</li></ul>" # nolint: line_length_linter.
    },
     if (knitr::is_latex_output()) {
      "Operando destino puede ser: \\begin{itemize} \\item dirección [M]\\item dirección registro [BL] \\end{itemize} y operando fuente puede ser:\\begin{itemize} \\item Registro: Ry\\item valor en la instrucción d \\end{itemize}" # nolint: line_length_linter.
    } else {
      "Operando destino puede ser: <ul><li>dirección `[M]`</li><li>dirección registro `[BL]`)</li></ul> y operando fuente puede ser:<ul><li>Registro: `Ry`</li><li>valor en la instrucción `d`</li></ul>" # nolint: line_length_linter.
    },
    "Si tiene operando es una dirección de memoria M (*)"
  ),
  stringsAsFactors = FALSE
)

tabla <- kable(modosdireccionamiento,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Tabla de modos de direccionamiento",
               col.names = c("Tipo", "Operación", "Parámetros"),
               booktabs = TRUE,
               escape = FALSE)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "5cm") %>%
    column_spec(3, width = "8cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(3, extra_latex_after = "\\midrule") %>%
    footnote(
      general = c(
        "Las instrucciones de transferencia y procesamiento tienen los mismos modos de direccionamiento A, B y C.",
        "Rx y Ry puede ser un registro de proposito general: AL, BL, CL y DL."
      ),
      general_title = "Nota: ",
      number = c("La notación [M] indica el contenido de la dirección de memoria.", "La notación [BL] indica el contenido de la dirección del registro BL.", "La notación d indica dato inmediato."),
      number_title = "Notas numéricas: ",
      symbol = c("La notación M indica dirección de memoria."),
      symbol_title = "Símbolos: ",
      threeparttable = TRUE
    )
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "15em", bold = TRUE) %>%
    column_spec(2, width = "25em") %>%
    column_spec(3, width = "35em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2") %>%
    row_spec(3, extra_css = "border-top: 2px solid #000;") %>%
    footnote(
      general = "Las instrucciones de transferencia y procesamiento tienen los mismos modos de direccionamiento A, B y C.",
      general_title = "Nota: ",
      threeparttable = TRUE
    )
}
```

Ejemplo de los modos de direccionamiento:

```{r  codemoddir, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
x db 2 
y db 3

; ejemplo modos direccionamiento
;----------------------
; carga en registro
;----------------------
; Directo
mov al, x

; Por registro
mov dl, al

; Inmediato
mov bl, 16

; Indirecto
mov cl, [bl] ; celda 16 = y

;----------------------
; Almacenar en memoria
;----------------------
; Diecto
mov x, cl

; Indirecto
mov [bl], al

; Inmediato
mov x, 5

; Inmediato
mov [bl], 4

hlt\\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
x db 2 
y db 3

; ejemplo modos direccionamiento
;----------------------
; carga en registro
;----------------------
; Directo
mov al, x

; Por registro
mov dl, al

; Inmediato
mov bl, 16

; Indirecto
mov cl, [bl] ; celda 16 = y

;----------------------
; Almacenar en memoria
;----------------------
; Diecto
mov x, cl

; Indirecto
mov [bl], al

; Inmediato
mov x, 5

; Inmediato
mov [bl], 4

hlt
```")
}
```
	     

### Codificación de instrucciones
El formato de las instrucciones se basa en la codificación binaria, donde cada instrucción se representa mediante un código de operación (opcode) seguido de los operandos. Las instrucciones del simulador VonSim8 se dividen en dos categorías principales: las instrucciones de transferencia y procesamiento de datos, y las instrucciones de control de flujo. Cada instrucción se codifica en un formato binario específico, que incluye un código de operación (opcode) y, en algunos casos, operandos adicionales. La Tabla \@ref(tab:instcodif) presenta una lista de las instrucciones implementadas en el simulador, junto con su acción correspondiente y su codificación binaria.

```{r instaccion, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

instaccion <- data.frame(
  Tipo = c(
    "A: Entre registros",
    "", "", "",
    "B: Cargar a registro",
    "", "", "", "", "", "", "", "", "", "", "",
    "C: Almacenar en memoria",
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
    "D: control de flujo",
    "", "", ""
  ),
  Ejemplo = c(
    "MOV Rx, Ry", "ADD Rx, Ry", "SUB Rx, Ry", "CMP Rx, Ry",
    "MOV Rx, [M]", "MOV Rx, [BL]", "MOV Rx, d", "ADD Rx, [M]", "ADD Rx, [BL]", "ADD Rx, d",
    "SUB Rx, [M]", "SUB Rx, [BL]", "SUB Rx, d", "CMP Rx, [M]", "CMP Rx, [BL]", "CMP Rx, d",
    "MOV [M], Ry", "MOV [BL], Ry", "MOV [M], d", "MOV [BL], d",
    "ADD [M], Ry", "ADD [BL], Ry", "ADD [M], d", "ADD [BL], d",
    "SUB [M], Ry", "SUB [BL], Ry", "SUB [M], d", "SUB [BL], d",
    "CMP [M], Ry", "CMP [BL], Ry", "CMP [M], d", "CMP [BL], d",
    "JMP M", "JZ M", "JC M", "HLT"
  ),
  Acción = c(
    "Rx ← Ry", "Rx ← Rx + Ry", "Rx ← Rx - Ry", "Rx - Ry * ",
    "Rx ← Mem[Dirección]", "Rx ← Mem[BL]", "Rx ← dato", "Rx ← Rx + Mem[Dirección]", "Rx ← Rx + Mem[BL]", "Rx ← Rx + dato",
    "Rx ← Rx - Mem[Dirección]", "Rx ← Rx - Mem[BL]", "Rx ← Rx - dato", "Rx - Mem[Dirección] (*)", "Rx - Mem[BL] (*)", "Rx - dato (*)",
    "Mem[Dirección] ← Rx", "Mem[BL] ← Rx", "Mem[Dirección] ← dato", "Mem[BL] ← dato",
    "Mem[Dirección] ← Mem[Dirección] + Rx", "Mem[BL] ← Mem[BL] + Rx", "Mem[Dirección] ← Mem[Dirección] + dato", "Mem[BL] ← Mem[BL] + dato",
    "Mem[Dirección] ← Mem[Dirección] - Rx", "Mem[BL] ← Mem[BL] - Rx", "Mem[Dirección] ← Mem[Dirección] - dato", "Mem[BL] ← Mem[BL] - dato",
    "Mem[Dirección] - Rx", "Mem[BL] - Rx", "Mem[Dirección] - dato", "Mem[BL] - dato", 
    "IP ← Dirección", "Si Z = 1 entonces IP ← Dirección", "Si C = 1 entonces IP ← Dirección", "Detiene el procesador"
  ),
  stringsAsFactors = FALSE
)

if (knitr::is_latex_output()) {
  kable(instaccion, format = "latex", booktabs = TRUE, align = "l", col.names = c("Tipo", "Ejemplo", "Acción"),
        caption = "Tabla de instrucciones y acciones") %>%
    kable_styling(latex_options = c("hold_position", "scale_down")) %>%
    column_spec(1, width = "4cm") %>%
    column_spec(2, width = "3cm") %>%
    column_spec(3, width = "8cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    footnote(
      general = "La instrucción CMP no almacena el resultado de la operación en el operando destino.",
      general_title = "Nota *: ",
      threeparttable = TRUE
    )

} else {
  kable(instaccion, format = "html", table.attr = "class='table table-striped'", align = "l", col.names = c("Tipo", "Ejemplo", "Acción"),
        caption = "Tabla de instrucciones y acciones") %>%
    kable_styling(full_width = FALSE, position = "center") %>%
    column_spec(1, width = "20em") %>%
    column_spec(2, width = "30em") %>%
    column_spec(3, width = "30em") %>%
    footnote(
      general = "La instrucción CMP no almacena el resultado de la operación en el operando destino.",
      general_title = "Nota *: ",
      threeparttable = TRUE
    )
}
```

```{r instcodif, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

instcodif <- data.frame(
  CodOp = c(
    "0", "1", "1", "1", "2", "2", "2", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "C", "C", "C", "D"
  ),
  Instrucción = c(
    "`MOV Rx, Ry`", "`MOV Rx, [M]`", "`MOV Rx, [BL]`", "`MOV Rx, D`",
    "`MOV [M], Ry`", "`MOV [BL], Ry`", "`MOV [M], D`", "`MOV [BL], D`",
    "`ADD Rx, Ry`", "`ADD Rx, --`", "`ADD [M], --`", "`SUB Rx, Ry`", "`SUB Rx, --`", "`SUB [M], --`",
    "`CMP Rx, Ry`", "`CMP Rx, --`", "`CMP [M], --`", "`JMP M`", "`JZ M`", "`JC M`", "`Jxx M`", "`HLT`"
  ),
  Byte = c(
    "1", "2", "1", "2", "2", "2", "3", "2", "1", "Carga en registro", "Almacenar en memoria", "1", "Carga en registro", "Almacenar en memoria",
    "1", "registro - memoria", "memoria - registro", "1", "1", "1", "1", "1"
  ),
  Codificación = c(
    "`0000 RxRy`", "`0001 Rx00 MMMMMMMM`", "`0001 Rx01`", "`0001 Rx10 MMMMMMMM`",
    "`0010 00Ry MMMMMMMM`", "`0010 01Ry`", "`0010 1100 MMMMMMMM dddddddd`", "`0010 1101 MMMMMMMM`",
    "`0011 RxRy`", "`0100 ---- --------`", "`0101 ---- -------- --------`", "`0110 RxRy`", "`0111 ---- --------`",
    "`1000 ---- -------- --------`", "`1001 RxRy`", "`1010 ---- --------`", "`1011 ---- -------- --------`",
    "`1100 0000 MMMMMMMM`", "`1100 0001 MMMMMMMM`", "`1100 0011 MMMMMMMM`", "`1100 ffff MMMMMMMM`", "`1101 0000`"
  ),
  stringsAsFactors = FALSE
)

# Para monoespaciado en PDF reemplaza los backticks por \texttt{}
if (knitr::is_latex_output()) {
  instcodif$Instrucción <- gsub("`([^`]*)`", "\\\\texttt{\\1}", instcodif$Instrucción)
  instcodif$Codificación <- gsub("`([^`]*)`", "\\\\texttt{\\1}", instcodif$Codificación)
}

tabla_kable <- kable(instcodif,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Tabla de codificación de instrucciones",
               col.names = c("CodOp", "Instrucción", "Byte", "Codificación"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "l", "l", "l"))

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "2cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "5.5cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(instcodif)), extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "10em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "32em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

Considerando:

  - `____`: Código de operación de la instrucción, número de 4 bits.

  - `Rx` o `Ry`: Índices de registros, número entre `0` y `3`, cada índice es de 2 bits.

  - `00`: Junto con el código de operación indica si la operación es tipo B o C.

  - `M`: Dirección de memoria, número de 8 bits.

  - `ffff`: representan el comportamiento de la instrucción, número de 4 bits.

  - `d`: Dato inmediato, número de 8 bits.

  - `MMMMMMMM`: Dirección de memoria, número de 8 bits.

  - `dddddddd`: Dato inmediato, número de 8 bits.

En la instrucción de salto condicional `Jxx Dirección`, la indicación `xx` representa todas las combinaciones posibles de los _flags_ donde `NZ` indica la negacion del  _flags_ `Z`:

| Instrucción               | Acción                                      |
| :------------------------ | :------------------------------------------ | 
| [`JZ Dirección`]          | Salta a _Dirección_ si `Z=1`                 | 
| [`JNZ Dirección`]         | Salta a _Dirección_ si `Z=0`                 |
| [`JC Dirección`]          | Salta a _Dirección_ si `C=1`                 |
| [`JNC Dirección`]         | Salta a _Dirección_ si `C=0`                 |
| [`JS Dirección`]          | Salta a _Dirección_ si `S=1`                 |
| [`JNS Dirección`]         | Salta a _Dirección_ si `S=0`                 |
| [`JO Dirección`]          | Salta a _Dirección_ si `O=1`                 |
| [`JNO Dirección`]         | Salta a _Dirección_ si `O=0`                 |

```{r tablaregistros, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

tablaregistros <- data.frame(
  Registro = c("AL", "BL", "CL", "DL"),
  Binario = c("00", "01", "10", "11"),
  Decimal = c(0, 1, 2, 3)
)

if (knitr::is_latex_output()) {
  kable(tablaregistros, format = "latex", booktabs = TRUE, align = "l",
        col.names = c("Registros R", "Binario", "Decimal"),
        caption = "Tabla de registros del simulador") %>%
    kable_styling(latex_options = c("hold_position", "scale_down")) %>%
    column_spec(1, width = "4cm") %>%
    column_spec(2, width = "5cm") %>%
    column_spec(3, width = "5cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    footnote(
      general = "Los registros AL, BL, CL y DL corresponden a registros de propósito general de 8 bits.",
      general_title = "Nota: ",
      threeparttable = TRUE
    )
} else {
  kable(tablaregistros, format = "html", table.attr = "class='table table-striped'", align = "l",
        col.names = c("Registros R", "Binario", "Decimal"),
        caption = "Tabla de registros del simulador") %>%
    kable_styling(full_width = FALSE, position = "center") %>%
    column_spec(1, width = "20em") %>%
    column_spec(2, width = "25em") %>%
    column_spec(3, width = "25em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2") %>%
    footnote(
      general = "Los registros AL, BL, CL y DL corresponden a registros de propósito general de 8 bits.",
      general_title = "Nota: ",
      threeparttable = TRUE
    )
}
```

El formato ampliado para las instrucciones incluye los siguientes casos tabla \@ref(tab:formatoampliado):

```{r formatoampliado, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear un dataframe con los datos
formatoampliado <- data.frame(
  Tipo = c("Transferencia y procesamiento", "", "", "", "", "Control"),
  Operación = c("A: entre registros", "B: Cargar a registro", "", "", "C: Almacenar en memoria", "D: control de flujo"), # nolint: line_length_linter.
  Codificación = c("____XXYY", "____XX00 MMMMMMMM", "____XX01", "____XX00 dddddddd", "____00YY MMMMMMMM dddddddd", "____ffff MMMMMMMM"), # nolint: line_length_linter, line_length_linter.
  Parámetros = c(
    "XX = Registro destino, YY = Registro fuente",
    "XX00 = Registro destino y M = Dirección de memoria",
    "XX01 = Registro destino y direccion en registro [BL]",
    "XX10 = Registro destino y d = Dato inmediato",
    "YY = Registro fuente, `M` = Dirección de memoria,  `d` = Dato Inmediato",
    "ffff = funcionalidad, M = Dirección de memoria"
  ),
  stringsAsFactors = FALSE
)

# Mostrar la tabla en formato adecuado según el tipo de salida
if (knitr::is_latex_output()) {
  kable(formatoampliado, format = "latex", booktabs = TRUE, align = "l", col.names = c("Tipo", "Operación", "Codificación", "Parámetros"), # nolint: line_length_linter.
        caption = "Tabla de codificación de instrucciones ampliado") %>%
    kable_styling(latex_options = c("hold_position", "scale_down")) %>%
    column_spec(1, width = "4cm") %>%
    column_spec(2, width = "5cm") %>%
    column_spec(3, width = "5cm") %>%
    column_spec(4, width = "6cm") %>%
    row_spec(4, extra_latex_after = "\\midrule") %>%
    footnote(
      general = "d = dato inmediato, no puede ser destino de la instrucción.", # nolint: line_length_linter.
      general_title = "Nota: ",
      threeparttable = TRUE
    )
} else {
  kable(formatoampliado, format = "html", table.attr = "class='table table-striped'", align = "l", col.names = c("Tipo", "Operación", "Codificación", "Parámetros"), # nolint: line_length_linter.
        caption = "Tabla de codificación de instrucciones ampliado") %>%
    kable_styling(full_width = FALSE, position = "center") %>%
    column_spec(1, width = "20em") %>%
    column_spec(2, width = "25em") %>%
    column_spec(3, width = "25em") %>%
    column_spec(4, width = "30em") %>%
    row_spec(4, extra_css = "border-top: 2px solid #000;") %>%
    footnote(
      general = "d = dato inmediato, no puede ser destino de la instrucción.", # nolint: line_length_linter.
      general_title = "Nota: ",
      threeparttable = TRUE
    )
}
```

## Repertorio de instrucciones

El repertorio **x86** es reducido (8 bits)

| Categoría                  | Instrucción            | Código operación | Acción                                                                 |
|---------------------------|------------------------|------------------|------------------------------------------------------------------------|
| **Transferencia de datos**| `MOV`                  | {0, 1, 2}        | Copiar entre registros, cargar a registro, almacenar en memoria        |

| **Procesamiento de datos**| `ADD`                  | {3, 4, 5}        | Operación aritmética: `operando1 ← operando1 + operando2`             |
|                           | `SUB`                  | {6, 7, 8}        | Operación aritmética: `operando1 ← operando1 - operando2`             |
|                           | `CMP`                  | {9, 10, 11}      | Comparación: `operando1 - operando2` (no actualiza el destino)        |

| **Control de flujo**      | `JMP / Jxx / CALL / INT`         | {12}             | Salto incondicional `JMP`, condicionales `Jxx`, llamada `CALL`,`INT`: llamar rutina de interrupción |

| **Gestion de flujo**      | `RET / IRET / CLI/  STI / HLT`| {13}           | retorno `RET`, `IRET`: retornar de interrupción<br>`NOP`: no opera<br>`HLT`: detiene el CPU  |

| **Manejo de pila y E/S**  | `PUSH / POP / OUT / IN` | {14}           | `PUSH`: poner en la pila<br>`POP`: retirar de la pila<br>`OUT`: enviar a puerto `IN`: recibir desde puerto |

| **Miscelánea**            | `AND / OR / XOR / NOT / INC / DEC`  | {15}           | Operaciones lógicas                               |


## Ciclo de la instrucción
En este apartado se detalla el proceso llevado a cabo por la Unidad de Control (UC) para ejecutar cada instrucción, destacando los aspectos clave:

- Secuencia de pasos.
- Registros involucrados en cada etapa del proceso.
- Uso de los buses de datos, direcciones y control.
- Señales de control generadas.

El **ciclo de la instrucción** se define como la secuencia de microoperaciones necesarias para ejecutar una instrucción en el sistema. Estas microoperaciones se expresan mediante un lenguaje de transferencia entre registros, representado de la forma:

`destino` $\leftarrow$ `origen` 

La Figura \@ref(fig:flujoCicloInstruccion) ilustra el flujo básico del ciclo de instrucción implementado en el simulador, permitiendo visualizar los pasos secuenciales de búsqueda, decodificación y ejecución.

```{r flujoCicloInstruccion, echo=FALSE, fig.cap="Flujo del ciclo de instrucción en VonSim8", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/cicloinstruccion2.png")
```

### Etapa de Captación: 
En esta etapa, común a todas las instrucciones, consiste en la lectura de la instrucción desde la memoria.

1. **`MAR` $\leftarrow$ `IP`**:
La Unidad de Control (UC) transfiere el contenido del registro puntero de instrucciones (`IP`) al registro de direcciones de memoria (`MAR`). Este paso prepara el sistema para acceder a la posición de memoria donde se encuentra la próxima instrucción.
2. **`MBR` $\leftarrow$ `read(Memoria[MAR])` ; `IP` $\leftarrow$ `IP` + 1**:
La UC activa la señal de lectura para obtener el contenido de la memoria en la dirección especificada por el (`MAR`). El dato leído se transfiere al registro de datos de memoria (`MBR`) mediante el bus de datos. Simultáneamente, el registro (`IP`) se incrementa en uno, apuntando así a la siguiente instrucción en memoria u operando de la instrucción vigente.
3. **`IR` $\leftarrow$ `MBR`**:
Finalmente, el contenido del registro de datos de memoria (`MBR`) se copia en el registro de instrucciones (`IR`). Con este paso, la instrucción ha sido captada y está lista para ser decodificada y ejecutada. 

### Etapa de Ejecución:
En esta etapa, las operaciones específicas dependen del tipo de instrucción. A continuación, se describen algunos casos representativos:

Instruccion de transferencia de datos MOV
#### Destino registro
* MOV `Rx`, `Ry` (Entre registros)
  4. **`Rx` $\leftarrow$ `Ry`**: El valor almacenado en Ry se copia en el registro Rx.

* MOV `Rx`, `[Dirección]` (Directo)
  4. **`MAR` $\leftarrow$ `IP`**: El contenido de IP se transfiere al registro MAR.
  5. **`MBR` $\leftarrow$ `read(Memoria[MAR])`; `IP` $\leftarrow$ `IP` + 1**: Se lee el dato de la memoria en la dirección indicada por MAR y se almacena en MBR; luego, IP se incrementa en uno.  
  6. **`MAR` $\leftarrow$ `MBR`**: El valor de MBR se transfiere a MAR.
  7. **`MBR` $\leftarrow$ `read(Memoria[MAR])`**: Se lee el dato de la memoria en la nueva dirección de MAR y se almacena en MBR.
  8. **`Rx`  $\leftarrow$ `MBR`**: Finalmente, el contenido de MBR se copia en el registro Rx.

* MOV `Rx`, `Dato` (Inmediato)
  4. 5. Se obtiene el operando de la instrucción.
  6. **`Rx`  $\leftarrow$ `MBR`**: El contenido de MBR se transfiere al registro Rx.

* MOV `Rx`, `[BL]` (Indirecto) 
  4. 5. Se obtiene el operando de la instrucción.
  6. **`MAR` $\leftarrow$ `BL`**: El contenido de BL se transfiere al registro MAR.
  7. **`MBR` $\leftarrow$ `read(Memoria[MAR])`**: Se lee el dato de la memoria en la dirección indicada por MAR y se almacena en MBR.
  8. **`Rx`  $\leftarrow$ `MBR`**: Finalmente, el contenido de MBR se copia en el registro Rx.

  #### Destino Memoria
* MOV `[Dirección]`, `Ry` (Directo)     
  4. 5. Se obtiene el operando de la instrucción.
  6. **`MAR` $\leftarrow$ `MBR`**: El valor de MBR se transfiere al registro MAR.
  7. **`MBR` $\leftarrow$ `Ry`**: El contenido de Ry se copia en MBR.
  8. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**: Se escribe el valor de MBR en la posición de memoria indicada por MAR.

* MOV `[BL]`, `Ry` (Indirecto)     
  6. **`MAR` $\leftarrow$ `BL`**: El contenido de BL se transfiere al registro MAR.
  7. **`MBR` $\leftarrow$ `Ry`**: El contenido de Ry se copia en MBR.
  8. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**: Se escribe el valor de MBR en la posición de memoria indicada por MAR.

* MOV `[Dirección]`, `Dato` (Inmediato)     
  4. 5. Se obtiene el operando de la instrucción.
  6. **`ri` $\leftarrow$ `MBR`**: El valor de MBR se transfiere a un registro intermedio (ri).  
  7. 8. Se obtiene el operando de la instrucción. 
  9. **`MAR` $\leftarrow$ `ri`**: El contenido de ri se transfiere al registro MAR.
  10. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**: Se escribe el valor de MBR en la posición de memoria indicada por MAR.

* MOV `[BL]`, `Dato` (Inmediato)     
  4. 5. Se obtiene el operando de la instrucción.
  6. **`MAR` $\leftarrow$ `BL`**: El contenido de BL se transfiere al registro MAR.
  7. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**: Se escribe el valor de MBR en la posición de memoria indicada por MAR.

Las instrucciones que utilizan la Unidad Aritmético-Lógica (ALU) actualizan las banderas del registro de estado `RS`.
#### Destino registro
* ADD `Rx`, `Ry` (Entre registros)
  4. **`Rx` $\leftarrow$ `Rx` + `Ry`; update(Flags)**

* ADD `Rx`, `[Dirección]` (Directo)
  4. 5. Se obtiene el operando de la instrucción.
  6. **`MAR` $\leftarrow$ `MBR`**
  7. **`MBR` $\leftarrow$ `read(Memoria[MAR])`**
  8. **`Rx`  $\leftarrow$ `Rx` + `MBR`; update(Flags)**

* ADD `Rx`, `Dato` (Inmediato)
  4. 5. Se obtiene el operando de la instrucción.
  6. **`Rx`  $\leftarrow$ `Rx` + `MBR`; update(Flags)**

* ADD `Rx`, `[BL]` (Indirecto) 
  4. 5. Se obtiene el operando de la instrucción.
  6. **`MAR` $\leftarrow$ `BL`**
  7. **`MBR` $\leftarrow$ `read(Memoria[MAR])`**
  8. **`Rx`  $\leftarrow$ `Rx` + `MBR`; update(Flags)**

#### Destino Memoria
* ADD `[Dirección]`, `Ry` (Directo)     
  4. 5. Se obtiene el operando de la instrucción.
  6. **`MAR` $\leftarrow$ `MBR`**
  7. **`MBR` $\leftarrow$ `Ry`**
  8. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**

* ADD `[BL]`, `Ry` (Indirecto)     
  6. **`MAR` $\leftarrow$ `BL`**
  7. **`MBR` $\leftarrow$ `Ry`**
  8. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**

* ADD `[Dirección]`, `Dato` (Inmediato)     
  4. 5. Se obtiene el operando de la instrucción.
  6. **`ri` $\leftarrow$ `MBR`**
  7. 8. Se obtiene el operando de la instrucción. 
  9. **`MAR` $\leftarrow$ `ri`**
  10. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**

* ADD `[BL]`, `Dato` (Inmediato)     
  4. 5. Se obtiene el operando de la instrucción.
  6. **`MAR` $\leftarrow$ `BL`**
  7. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**

Las instrucciones SUB y CMP tienen los mismos modos de direccionamiento que ADD, pero con una diferencia importante: la instrucción CMP no almacena el resultado de la operación en el operando destino.

* SUB `Rx`, `Ry` (Entre registros)
  4. **`Rx` $\leftarrow$ `Rx` - `Ry`; update(Flags)**

* CMP `Rx`, `Ry` (Entre registros)
  4. **`Rx` - `Ry`; update(Flags)**

Instrucciones de Control de Flujo

Salto incondicional y condicionales:
* JMP  `Dirección` (Salto incondicional)
  4. 5. Se obtiene el operando de la instrucción.
  6. **`IP` $\leftarrow$ `MBR`**: El contenido del `MBR` se transfiere al registro `IP`, estableciendo la nueva dirección de ejecución.

* JZ  `Dirección` (Salto condicional si Z=1)
  4. 5. Se obtiene el operando de la instrucción.
  6. `Si Z` == 1: **`IP` $\leftarrow$ `MBR`**:  Si la bandera de cero (`Z`) está activa, el contenido del `MBR` se transfiere al registro `IP`.

* JC  `Dirección` (Salto condicional si C=1)
  4. 5. Se obtiene el operando de la instrucción.
  6. `Si C` == 1: **`IP` $\leftarrow$ `MBR`**:  Si la bandera de acarreo (`C`) está activa, el contenido del `MBR` se transfiere al registro `IP`.

* Jxx  `Dirección` (Salto condicional)
  4. 5. Se obtiene el operando de la instrucción. 
  6. `Si xx` == 1: **`IP` $\leftarrow$ `MBR`**:  Si la condición especificada por `xx` se cumple, el contenido del `MBR` se transfiere al registro `IP`.

Rutinas:  
* CALL  `Dirección` 
  4. 5. Se obtiene el operando de la instrucción.
  6: `ri` $\leftarrow$ `MBR`; `SP` $\leftarrow$ `SP` - 1
  7: `MAR` $\leftarrow$ `SP`;
  8: `MBR` $\leftarrow$ `IP`
  9: `write(Memoria[MAR])` $\leftarrow$ `MBR`
  10: `IP` $\leftarrow$ `ri`

* RET
  4: `MAR` $\leftarrow$ `SP`
  5: `MBR` $\leftarrow$ `read(Memoria[MAR])`
  6: `IP` $\leftarrow$ `MBR`
  7: `SP` $\leftarrow$ `SP` + 1

Interrupciones:
* INT  `Dirección` 
  4 y 5: Obtener segundo byte de memoria
  6: `ri` $\leftarrow$ `MBR`; `SP` $\leftarrow$ `SP` - 1
  7: `MAR` $\leftarrow$ `SP`
  8: `MBR` $\leftarrow$ `Ry`
  9: `write(Memoria[MAR])` $\leftarrow$ `MBR`
  10: `IP` $\leftarrow$ `ri`
  
* IRET
  4: `MAR` $\leftarrow$ `SP`
  5: `MBR` $\leftarrow$ `read(Memoria[MAR])`
  6: `IP` $\leftarrow$ `MBR`;`SP` $\leftarrow$ `SP` + 1

* HLT
  4. 5. Se obtiene el operando de la instrucción.
  6. Detiene CPU.


## Modulo de Entrada/Salida e interrupciones
En esta etapa se incorporaron las instrucciones de manejo de pila y de interrupciones, ampliando la funcionalidad del simulador para cubrir un conjunto más completo de operaciones propias de la arquitectura x86.
A continuación, se detalla el conjunto completo de instrucciones, incluyendo su clasificación, nemónicos y las acciones que representan.

```{r isacompleta, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

isacompleta <- data.frame(
  `Código operación` = c("MOV", "ADD", "JMP", "PUSH, POP, OUT, IN", "INT , IRET", "NOP , HLT"),
  Instrucciones = c("Transferencia de datos", "Aritmética", "Control de flujo", "Pila y E/S", "Interrupciones", "Control"),
  nemónico = c(
    "MOV destino, origen",
    "ADD destino, origen",
    "JMP destino",
    "PUSH, POP, OUT, IN",
    "INT , IRET",
    "NOP , HLT"
  ),
  Acción = c(
    "1- Copiar entre registros 2- Cargar a registro 3- Almacenar en memoria",
    "1- Sumar  2- Restar 3- Comparar",
    "Salto incondicional JMP. Saltos condicionales Jxx. Llamadas a rutinas CALL y retorno RET",
    "Poner en la pila PUSH. Retirar de la pila POP. Enviar un byte al puerto del dispositivo de E/S. Recibir un byte del dispositivo de E/S",
    "Llamar a una rutina de tratamiento de interrupción INT. Retornar de una rutina de tratamiento de interrupción IRET",
    "No opera NOP. Detiene el CPU HLT"
  )
)

tabla_kable <- kable(isacompleta,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Tabla de Instrucciones y Códigos de Operación de la Arquitectura x86",
               col.names = c("Código operación", "Instrucciones", "Nemónico", "Acción"),
               booktabs = TRUE,
               escape = FALSE,
               align = c("c", "c", "c", "c"))

if (knitr::is_latex_output()) {
  tabla_kable %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "5.5cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(isacompleta)),
             extra_latex_after = "\\addlinespace[10pt]")
} else {
  tabla_kable %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "10em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "32em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

## Aspectos tecnológicos de implementación
Se utiliza un enfoque modular para la implementación del simulador, facilitando su mantenimiento y ampliación futura. La arquitectura del simulador se basa en una estructura de capas, donde cada capa se encarga de una parte específica del proceso de simulación.

## Simulación visual e interactiva
Esta sección detalla la implementación de las características visuales e interactivas del simulador, diseñadas para facilitar la comprensión del flujo de datos y las microoperaciones dentro de la arquitectura x86.

### Representación gráfica de componentes
- **Diseño de la interfaz visual**: incluye elementos como registros, buses y memoria, presentados de manera clara y organizada.
- **Resaltado dinámico**: los componentes relevantes se destacan visualmente durante la ejecución, proporcionando un seguimiento en tiempo real del flujo de datos.

### Ejecución paso a paso
- **Flujo interactivo**: permite avanzar por cada etapa del ciclo de instrucción, desde la captura hasta la finalización.
- **Opciones de visualización**: se pueden observar los micropasos que conforman cada etapa de la ejecución, fomentando una comprensión detallada del proceso.

## Gestión de interrupciones y periféricos
Se describe la simulación de interrupciones y operaciones de entrada/salida, proporcionando una implementación básica para la interacción con periféricos.

### Manejo del vector de interrupciones
- **Vector predefinido**: se incluye un conjunto de interrupciones estándar.
- **Simulación de interrupciones**: ejemplos como las interacciones con teclado y pantalla están modeladas para su análisis práctico.

### Instrucciones IN y OUT
- **Operaciones de entrada/salida**: se implementan y simulan las instrucciones básicas para la interacción con periféricos.

### Segunda etapa
En esta etapa, se amplían los modos de direccionamiento e instrucciones:

## Integración de métricas de rendimiento
El simulador incorpora métricas clave para analizar el impacto del rendimiento en la arquitectura de computadoras.

### Métricas calculadas
- **Indicadores**: tiempo de ciclo, tiempo de CPU y ciclos por instrucción (CPI).
- **Visualización**: las métricas se presentan en tiempo real durante la simulación, facilitando su análisis.

### Análisis de casos de estudio
- Se incluyen ejemplos que ilustran cómo interpretar las métricas para optimizar el rendimiento.

## Proceso de validación
El proceso de validación garantiza que el simulador cumple con los requisitos pedagógicos y funcionales.

### Validación funcional
- **Pruebas de módulos**: cada componente se verificó de manera individual.
- **Ejecución completa**: programas de prueba comprobaron la correcta implementación de las instrucciones.

### Evaluación pedagógica
- **Retroalimentación**: opiniones de estudiantes y docentes guiaron los ajustes realizados.
- **Objetivos educativos**: el simulador prioriza la claridad conceptual sin sacrificar la precisión técnica.

## Portabilidad y Mantenibilidad
- **Portabilidad**: la herramienta se implementa como una aplicación web, compatible con cualquier navegador moderno.
- **Mantenibilidad**: el código modular y bien documentado facilita futuras actualizaciones y mejoras.

<!--chapter:end:05-desarrollo.Rmd-->

# Apéndices {-}

## Anexo A: Protocolo de Entrevista Semiestructurada  {#anexoA}

**Objetivo:**  
Relevar necesidades, experiencias y percepciones de docentes especializados en la enseñanza de Arquitectura de Computadoras, con el fin de fundamentar los requisitos funcionales y pedagógicos de una herramienta de simulación orientada a la arquitectura x86.

**Tipo de entrevista:** Semiestructurada  
**Duración estimada:** 45–60 minutos  
**Participantes:** Docentes universitarios con experiencia en la enseñanza de asignaturas vinculadas a Arquitectura de Computadoras  
**Modo de registro:** Grabación de audio (previo consentimiento informado) y notas del entrevistador

---

### Introducción (a cargo del entrevistador)

- Breve presentación personal y del objetivo de la entrevista.
- Explicación sobre la confidencialidad de los datos.
- Solicitud de consentimiento para grabar la entrevista.
- Aclaración sobre la posibilidad de no responder a alguna pregunta o interrumpir la entrevista en cualquier momento.

---

### Datos generales del entrevistado

- **Nombre y Apellido:** (opcional si se desea anonimato)
- **Universidad o institución en la que trabaja:**
- **Asignatura(s) que dicta relacionadas con arquitectura de computadoras:**
- **Años de experiencia docente en el área:**
- **Nivel en el que dicta la asignatura:** (Grado, Posgrado, Técnico, Otro)

---

### Preguntas principales

#### A. Enseñanza y dificultades

- ¿Cuáles considera que son los principales desafíos que enfrentan los estudiantes al aprender los conceptos de arquitectura de computadoras?
- ¿Qué contenidos o temas observa que generan mayores dificultades de comprensión?
- ¿Cómo aborda actualmente la enseñanza del lenguaje ensamblador y el ciclo de instrucción?

#### B. Experiencia con herramientas de simulación

- ¿Utiliza o ha utilizado herramientas de simulación en sus clases? ¿Cuáles?
- ¿Qué ventajas ha encontrado en el uso de estas herramientas?
- ¿Qué limitaciones o dificultades ha identificado en las herramientas actualmente disponibles?

#### C. Requisitos deseables en una herramienta

- En su opinión, ¿qué funcionalidades debería tener una herramienta de simulación para ser útil en el proceso de enseñanza?
- ¿Considera importante que la herramienta incluya visualizaciones gráficas del ciclo de instrucción o del flujo de datos entre componentes?
- ¿Cree que el soporte para interrupciones y periféricos (por ejemplo, teclado o pantalla) aporta valor al aprendizaje?
- ¿Considera que la posibilidad de activar progresivamente instrucciones del repertorio x86 según el avance del curso puede beneficiar el proceso de enseñanza-aprendizaje?
- ¿Qué importancia le asigna a la incorporación de métricas de rendimiento (como ciclos por instrucción, tiempo de CPU, etc.) en una herramienta educativa?

#### D. Interfaz y accesibilidad

- ¿Qué aspectos de la interfaz considera prioritarios en una herramienta pensada para estudiantes?
- ¿Debería contemplarse la accesibilidad para personas con discapacidad? ¿De qué forma?

---

### Cierre

- ¿Desea agregar algo más que no hayamos preguntado?
- Agradecimiento por el tiempo y colaboración.

---

**Nota:** El análisis posterior de las entrevistas será realizado de manera confidencial y con fines exclusivamente académicos.

<!--chapter:end:06-apendice.Rmd-->

# Bibliografía {#Biblio}

<!--chapter:end:06-biblio.Rmd-->

