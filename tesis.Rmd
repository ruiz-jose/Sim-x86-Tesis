---
title: 'Herramienta de simulación para dar soporte a la enseñanza de arquitectura de computadoras'
subtitle: "Tesis para optar al grado de Maestría en Sistemas de Información"
author: "Ruiz Jose Maria"
date: "2024" # o para fecha actual: "`r Sys.Date()`"
institution: "Universidad de Nacional de Entre Rios"
degree: "Maestría en Sistemas de Información"
advisor: "Director: Colombani Marcelo Alberto"
bibliography: [tesis.bib]
#biblio-style: apalike
biblio-style: ieeetr
link-citations: yes
site: bookdown::bookdown_site
output: bookdown::gitbook
github-repo: "ruiz-jose/Sim-x86-Tesis"
documentclass: book
fontsize: 14pt
lof: True
lot: True
---


# Resumen {-}

Existe un consenso creciente en el uso de herramientas de simulación en la enseñanza para procesos dinámicos complejos, como las operaciones intrínsecas de la computadora, que permiten representar de forma visual e interactiva la organización y arquitectura interna de la computadora, facilitando así la comprensión de su funcionamiento por parte de los alumnos y el desarrollo de los temas por parte del docente. En este contexto, los simuladores juegan una pieza clave en el campo de la Arquitectura de Computadoras, permitiendo conectar fundamentos teóricos con la experiencia práctica, simpliﬁcando abstracciones y haciendo más rica la labor docente.
La arquitectura x86 es ampliamente utilizada en computadoras de escritorio y servidores. Este documento pretende realizar una comparación de los simuladores x86 que más se adecuan en el dictado de la asignatura Arquitectura de Computadoras de la carrera Licenciatura en Sistemas, establecer los criterios de evaluación y evaluar los simuladores seleccionados de acuerdo con estos criterios.

La presente investigación surge en el marco del proyecto de investigación I/D novel PID-UNER 7065: “Enseñanza/aprendizaje de asignatura Arquitectura de Computadoras con herramientas de simulación de sistemas de cómputos”. El Proyecto es llevado a cabo en la Facultad de Ciencias de la Administración de la Universidad Nacional de Entre Ríos, se vincula directamente con la asignatura Arquitectura en Computadoras que se dicta en segundo año de la carrera Licenciatura en Sistemas perteneciente a la  Facultad de Ciencias de la Administración de la Universidad Nacional de Entre Ríos.

Palabras clave: x86, simulador, aprendizaje, enseñanza, arquitectura de computadoras.



# Agradecimientos {-}

Agradecimientos aquí.

<!--chapter:end:index.Rmd-->

# Introducción {#intro}
En nuestra vida cotidiana, utilizamos dispositivos como computadoras de escritorio, teléfonos y relojes inteligentes, todos ellos basados en arquitecturas específicas. Comprender su funcionamiento e interacciones nos permite diseñar y desarrollar aplicaciones más eficientes.

Es esencial que los estudiantes de Arquitectura de Computadoras comprendan tanto la estructura como el funcionamiento interno de una computadora, y adquieran experiencia práctica con ellas. Para lograrlo, es fundamental disponer de un laboratorio bien equipado con el hardware adecuado y suficiente tiempo para que los estudiantes se familiaricen con las herramientas prácticas. En este contexto, se han desarrollado numerosos simuladores que facilitan la comprensión de la estructura y el funcionamiento de las computadoras, proporcionando valiosas experiencias de aprendizaje.

Esta tesis, inscrita en la Maestría en Sistemas de Información de la Facultad de Ciencias de la Administración, está directamente vinculada con el proyecto de investigación I/D novel PID-UNER 7065, titulado “Enseñanza/aprendizaje de Arquitectura de Computadoras con herramientas de simulación de sistemas de cómputo”, desarrollado en la Facultad de Ciencias de la Administración de la Universidad Nacional de Entre Ríos [@colombani_pid_2022].

La asignatura Arquitectura de Computadoras forma parte del plan de estudios de la carrera de Licenciatura en Sistemas, Universidad Nacional de Entre Ríos. Su objetivo es que los estudiantes comprendan la estructura y funcionamiento de las computadoras, y la ejecución lógica de un programa a nivel de instrucciones de máquina.

El primer paso para comprender las computadoras es entender que son máquinas que toman datos del exterior, los procesan y almacenan los resultados en la memoria o los envían a dispositivos de entrada y salida.

El procesamiento se realiza a través del procesador o CPU, y es en este componente donde los estudiantes encuentran mayor complejidad y dificultades para comprender su funcionamiento.

A pesar de que es posible explicar las partes del procesador, su funcionamiento, la interacción de sus componentes y enseñar lenguaje ensamblador mediante prácticas, los estudiantes suelen tener dificultades para lograr una comprensión completa del funcionamiento.

Sin embargo, la utilización de simuladores permite afianzar los conocimientos de los temas vistos en las clases teóricas, a fin de evitar que los estudiantes desvíen su atención hacia el aprendizaje del simulador propiamente dicho, es necesario que estos sean de manejo simple, intuitivo y visualmente atractivo, simplificando su aprendizaje de su uso.

La simulación es un término de uso diario en muchos contextos: medicina, militar, entretenimiento, educación, etc., debido a que permite ayudar a comprender cómo funciona un sistema, responder preguntas como "qué pasaría si", con el fin de brindar hipótesis sobre cómo o por qué ocurren ciertos fenómenos.

Para continuar, se define simulación como el proceso de imitar el funcionamiento de un sistema a medida que avanza en el tiempo. Entonces para llevar a cabo una simulación, es necesario desarrollar previamente un modelo conceptual que representa las características o comportamientos del sistema, mientras que la simulación representa la evolución del modelo a medida que avanza en el tiempo [@banks_discrete-event_2010][@law_simulation_2015][@robinson_simulation_2014].

Con los avances en el mundo digital, la simulación se ha convertido en una metodología de solución de problemas indispensable para ingenieros, docentes, diseñadores y gerentes. La complejidad intrínseca de los sistemas informáticos los hace difícil comprender y costosos de desarrollar sin utilizar simulación [@law_simulation_2015].

Muchas veces en el ámbito educativo, resulta difícil transmitir fundamentos teóricos de la organización y arquitectura interna de las computadoras debido a la complejidad de los procesos involucrados. Si sólo incorporamos los medios de enseñanza tradicionales, como ser una pizarra, un libro de texto o diapositivas, los mismos tienen una capacidad limitada para representar estos fundamentos. En consecuencia, es imprescindible un alto nivel de abstracción por parte del estudiante para desarrollar un modelo mental adecuado para capturar la organización y arquitectura interna de las computadoras [@lion_simuladores_2005][@contreras_uso_2010][@garcia-garcia_pbbcache_2020].

Es evidente la necesidad de utilizar nuevas tecnologías como recursos didácticos y medios de transferencia de conocimiento, ya que ayudan a los estudiantes a relacionar conceptos abstractos con realidades concretas. Estas tecnologías permiten situar al estudiante en un contexto que imita aspectos de la realidad, facilitando la detección de problemáticas similares a las que podrían ocurrir en situaciones reales. Este enfoque promueve un mejor entendimiento a través del trabajo exploratorio, la inferencia, el aprendizaje por descubrimiento y el desarrollo de habilidades [@nova_tool_2013][@mustafa_evaluating_2010].

Un simulador de arquitectura es una herramienta que imita el hardware de un sistema, representando sus aspectos arquitectónicos y funciones. Permiten realizar cambios, pruebas y ejecutar programas sin riesgo de dañar componentes ni depender de equipos físicos disponibles [@radivojevic_design_2011].

Algunas herramientas ofrecen una representación en forma visual e interactiva de la organización y arquitectura interna de la computadora, facilitando así la comprensión de su funcionamiento. En este sentido, los simuladores juegan una pieza clave en el campo de la Arquitectura de Computadores, permitiendo conectar fundamentos teóricos con la experiencia práctica, simpliﬁcando abstracciones y facilitando la labor docente [@nikolic_survey_2009][@hasan_survey_2012][@hennessy_computer_2012][@stallings_computer_2013].

El repertorio de instrucciones de la arquitectura x86, ampliamente utilizado en computadoras de escritorio y servidores, comenzó con el procesador Intel 8086 en 1978 como una arquitectura de 16 bits. Evolucionó a una arquitectura de 32 bits con el procesador Intel 80386 en 1985 (i386 o x86-32) y posteriormente a 64 bits con las extensiones de AMD (AMD64) y su adopción por Intel (Intel 64) [@intel_64_2016][@amd_developer_2019].

Un procesador x86-64 mantiene la compatibilidad con los modos x86 existentes de 16 y 32 bits, y permite ejecutar aplicaciones de 16 y 32 bits, como así también de 64 bits. Esta compatibilidad hacia atrás protege las principales inversiones en aplicaciones y sistemas operativos desarrollados para la arquitectura x86 [@intel_64_2016][@amd_developer_2019][@abel_ibm_2000].

Por ello, la enseñanza de la arquitectura x86 es de gran relevancia en la asignatura Arquitecturas de Computadoras debido a los diferentes temas que aborda.

Para brindar esta experiencia, es necesario un laboratorio equipado con el hardware adecuado y tiempo suficiente para que los estudiantes se familiaricen con las herramientas. Por este motivo, se han desarrollado muchos simuladores que facilitan la comprensión del funcionamiento y la estructura del computador, ofreciendo valiosas experiencias de aprendizaje [@skrien_cpu_2001]. 

## Justificación
Los estudiantes y docentes de la asignatura de Arquitectura de Computadoras enfrentan múltiples desafíos a la hora de abordar los complejos conceptos teóricos inherentes a la arquitectura x86. Para los estudiantes, en particular, la introducción a la arquitectura de una computadora puede resultar abrumadora debido a la abstracción y el nivel de detalle técnico requerido. Por su parte, los docentes se ven limitados en la capacidad de ilustrar estos conceptos de manera gradual y progresiva debido a la falta de herramientas didácticas específicas para esta arquitectura. Ante estos desafíos, los simuladores juegan un papel crucial como herramientas de apoyo, al permitir la exploración y experimentación con los conceptos de forma visual e interactiva.

La necesidad de desarrollar un simulador específico para la arquitectura x86 se fundamenta en las limitaciones de los simuladores actuales, los cuales no permiten una adecuada personalización al plan de estudios de la asignatura de Arquitectura de Computadoras en la Universidad Nacional de Entre Ríos. Aunque existen simuladores que apoyan la enseñanza de la arquitectura x86 en otros contextos [@radivojevic_design_2011][@nikolic_survey_2009], estos tienden a incluir una gran cantidad de contenidos preestablecidos. Si bien dichos contenidos son relevantes, presentar toda la especificación de la arquitectura x86 desde el inicio puede resultar abrumador y dificultar la comprensión de los estudiantes que recién se inician en este campo.

Esta tesis propone un enfoque distinto: desarrollar un simulador específico para la enseñanza de los contenidos de la currícula de Arquitectura de Computadoras. Este simulador ofrecerá una visión general de la estructura y funcionamiento de la computadora, abordando componentes clave como la CPU, la memoria, el módulo de E/S y los buses. Además, mostrará los micropasos necesarios para ejecutar el ciclo básico de una instrucción, ofrecerá un repertorio limitado de instrucciones que se irán habilitando conforme avanza el curso, y permitirá la generación y ejecución de programas en lenguaje ensamblador, tanto de manera paso a paso como en su conjunto. También incluirá la gestión de interrupciones básicas para la interacción con el teclado y la pantalla, y permitirá la comunicación con periféricos y la evaluación del rendimiento de los programas.

Contar con un simulador adaptado específicamente a los contenidos de esta asignatura no solo facilita el proceso de aprendizaje, al presentar los conceptos de manera progresiva y alineada con la currícula, sino que también permite una experiencia de aprendizaje contextualizada. Esto fomenta un aprendizaje significativo, en el cual los estudiantes pueden conectar teoría y práctica de manera efectiva a través de una herramienta diseñada para abordar de forma gradual y específica los conceptos fundamentales del curso.

Para garantizar que el simulador sea robusto, modular, flexible y fácil de modificar o ampliar, se explorará la utilización de técnicas formales de modelado y simulación, como las redes de Petri y DEVS (Discrete Event System Specification). Estas técnicas permiten una separación conceptual entre las capas de modelado y simulación, lo cual facilita tanto la comprensión del software como su adaptación. Además, estas metodologías permiten que las simulaciones escalen de forma transparente, posibilitando su ejecución en entornos de cómputo paralelo o distribuido sin necesidad de modificar el modelo, lo que representa una ventaja significativa en términos de escalabilidad [@peterson_petri_1981][@zeigler_theory_2000][@zeigler_theory_2018].

## Objetivos

El objetivo principal de esta tesis es construir una herramienta de simulación de la arquitectura x86 para apoyar la enseñanza de arquitectura de computadoras, enfocándose específicamente en los contenidos de la currícula de Arquitectura de Computadoras. Para lograr este objetivo, se plantean los siguientes objetivos específicos:

1. Estudiar y evaluar diferentes herramientas actuales de simulación destinadas a dar apoyo a la enseñanza de la arquitectura x86.
2. Construir una herramienta de apoyo para impartir los contenidos de la asignatura Arquitectura de Computadoras, para ello debe cumplir:
    - Una visión global de la estructura y funcionamiento de la computadora.
    - Generación y ejecución de programas en ensamblador.
    - Repertorio de instrucciones x86 reducido y habilitado progresivamente.
    - Simulación visual e interactiva de micropasos de instrucciones.
    - Gestión de interrupciones y comunicación con periféricos.
    - Medidas de rendimiento de ejecución de programas.

## Metodología de desarrollo
La metodología de desarrollo de este simulador específico para la arquitectura x86 sigue una serie de etapas diseñadas para asegurar una transición lógica y efectiva entre el análisis, el diseño y la implementación de la herramienta, de manera que se ajuste al plan de estudios de la asignatura Arquitectura de Computadoras en la Universidad Nacional de Entre Ríos.

1. Análisis de requerimientos: En esta etapa inicial, se identifican y definen los objetivos específicos del simulador, así como los requerimientos técnicos y pedagógicos necesarios para su alineación con la currícula. Este análisis establece una base sólida y clara para todas las fases subsecuentes del proyecto, asegurando que el simulador cumpla con las necesidades educativas y técnicas del curso.

2. Revisión y recopilación de información: Se investiga y recopila información relevante sobre los simuladores actuales de arquitectura x86. Este paso incluye un análisis de las características, ventajas y limitaciones de los simuladores existentes, proporcionando una comprensión más profunda del contexto educativo y permitiendo identificar áreas de mejora en relación con el objetivo del proyecto.

3. Estudio comparativo: A partir de la información recopilada, se realiza un estudio comparativo detallado de las características de los simuladores disponibles en el mercado. Esta etapa busca evaluar cuáles de sus funcionalidades pueden adaptarse o modificarse y cuáles deberían excluirse, de acuerdo con los objetivos del simulador y las necesidades específicas del plan de estudios. Este análisis comparativo será clave para orientar las decisiones de diseño.

4. Diseño y planificación del simulador: Con base en los hallazgos previos, se define la arquitectura, las funcionalidades y los módulos específicos del simulador. El diseño se enfoca en facilitar el aprendizaje progresivo de los estudiantes, implementando un repertorio de instrucciones que se habiliten a medida que avanzan en el curso. En esta etapa, se utilizan técnicas formales de modelado, como redes de Petri y DEVS (Discrete Event System Specification), para establecer una estructura modular, robusta y flexible que facilite tanto la comprensión como la modificación futura de la herramienta.

5. Construcción y desarrollo: En esta fase, se lleva a cabo la implementación del simulador de acuerdo con el diseño previamente definido. Cada funcionalidad se implementa y se verifica de forma secuencial, garantizando que cumpla con los requerimientos técnicos y pedagógicos establecidos. También se realizan pruebas parciales para asegurar la precisión y funcionalidad de cada módulo, lo que permite identificar y corregir errores tempranamente.

6. **Evaluación y ajuste**: Finalmente, se somete el simulador a una serie de pruebas con estudiantes o expertos en la materia para evaluar su efectividad en el aprendizaje de los conceptos de arquitectura de computadoras. Los resultados obtenidos en esta fase permiten realizar ajustes y optimizaciones necesarias, mejorando la herramienta y asegurando que cumpla con su propósito educativo de manera efectiva.

## Organización del documento
El resto de este documento se estructura de la siguiente manera:

- En el Capítulo (\@ref(arquitectura)), se presenta una descripción detallada de la arquitectura x86, definiendo sus características y el conjunto de instrucciones que la componen. Esta base teórica es fundamental para comprender los aspectos que se simularán en el proyecto.

- El Capítulo (\@ref(simulacion)) explora el papel de la simulación desde una perspectiva didáctica, enfatizando su valor como herramienta de apoyo en la enseñanza de Arquitectura de Computadoras. Aquí se revisan los beneficios de los simuladores en la enseñanza y los desafíos que ayudan a resolver en la formación de los estudiantes.

- En el Capítulo (\@ref(comparativa)), se realiza un análisis comparativo de los simuladores actuales, evaluándolos según criterios previamente establecidos. Este análisis permite identificar las limitaciones y fortalezas de cada simulador y establecer el contexto para la propuesta de esta tesis.

- Finalmente, en el Capítulo (\@ref(desarrollo)), se describe el desarrollo de un simulador específico que se ajusta a los objetivos de enseñanza y aprendizaje de la arquitectura x86 en el contexto de la currícula. Este simulador está diseñado como una herramienta práctica y accesible para facilitar la comprensión de conceptos complejos en la asignatura.

<!--chapter:end:01-intro.Rmd-->

# Arquitectura de computadoras {#arquitectura}
Este capítulo presenta los conceptos fundamentales de la arquitectura de computadoras, abordando las filosofías de diseño CISC y RISC, la evolución de la arquitectura x86 y una introducción al lenguaje ensamblador, temas que sientan las bases para comprender el funcionamiento interno de los sistemas informáticos.

## Introducción a la arquitectura de computadoras
La arquitectura de computadoras se centra en el diseño y la especificación de los componentes visibles para el programador en un sistema informático, como el conjunto de instrucciones, la organización de la memoria y los mecanismos de entrada/salida. Su objetivo principal es optimizar el rendimiento y la eficiencia del sistema. Esta disciplina se extiende desde la interacción entre el hardware y el software hasta la integración de sistemas completos, siendo fundamental para el avance de tecnologías modernas y sostenibles [@hennessy_computer_2012; @stallings_computer_2013].

Comprender la arquitectura de una computadora implica tener un conocimiento profundo de atributos claves como el repertorio de instrucciones (por ejemplo, arquitecturas x86 o ARM), la capacidad de procesamiento (32 o 64 bits), los mecanismos de entrada/salida, las técnicas de direccionamiento de memoria (directo o segmentado) y la gestión de la jerarquía de memoria [@null_essentials_2014]. Además, aspectos como el paralelismo y la eficiencia energética son esenciales para mejorar el rendimiento de los sistemas, así como para optimizar el desarrollo de software y sistemas operativos modernos [@hennessy_computer_2012; @patterson_computer_2014].

Es fundamental distinguir entre la arquitectura de computadoras, que abarca los componentes visibles al programador, y la organización de computadoras, que se enfoca en la implementación física de dicha arquitectura, incluye cómo están dispuestos y coordinados los elementos del hardware, como la memoria, las señales de control y las unidades de procesamiento, para cumplir con los objetivos de rendimiento y funcionalidad [@tanenbaum_structured_2013; @murdocca_principles_2000].

El estudio de la arquitectura de computadoras no solo permite comprender el 
funcionamiento interno de los sistemas informáticos, sino que también facilita 
su adaptación y optimización para satisfacer las demandas de nuevas tendencias 
tecnológicas, como la computación en la nube, la inteligencia artificial y el 
Internet de las cosas. La arquitectura bien diseñada es el cimiento que permite 
a estas tecnologías alcanzar su máximo potencial, impulsando de manera 
significativa la innovación. 
[@hennessy_computer_2012; @stallings_computer_2013]

Una arquitectura bien diseñada es el cimiento sobre el cual se desarrollan tecnologías modernas, permitiendo que alcancen su máximo potencial e impulsen significativamente la innovación.

Tener un conocimiento profundo de la arquitectura y la organización de los sistemas informáticos es vital para cualquier profesional en el campo de la informática. No solo habilita la creación de sistemas más eficientes y escalables, sino que también proporciona una base sólida para explorar áreas emergentes como la seguridad informática y los sistemas embebidos, sectores de creciente relevancia en la industria [@patterson_computer_2014]. El dominio de la arquitectura de computadoras abre un abanico de oportunidades profesionales en áreas emergentes como la seguridad informática y los sistemas embebidos, sectores de creciente relevancia en la industria.

En resumen, el estudio de la arquitectura de computadoras es crucial no solo para entender cómo funcionan internamente los sistemas informáticos y resolver problemas de rendimiento, sino también para diseñar soluciones innovadoras en áreas clave como la inteligencia artificial, la ciberseguridad y los sistemas embebidos. Este conocimiento es esencial para abordar los retos tecnológicos del futuro y acceder a un mercado laboral que valora la capacidad de crear y optimizar sistemas cada vez más poderosos y eficientes [@stallings_computer_2013].

## Arquitecturas Von Neumann y Harvard
Para entender las arquitecturas modernas, es esencial conocer dos modelos históricos que han sentado las bases del diseño actual de sistemas informáticos: Von Neumann y Harvard. Estos paradigmas no solo forman el cimiento de muchas arquitecturas contemporáneas, sino que también ayudan a comprender sus diferencias, ventajas y limitaciones.

### Arquitectura Von Neumann
La arquitectura Von Neumann, propuesta por John von Neumann en 1945, se caracteriza por utilizar un único espacio de memoria para almacenar tanto los datos como las instrucciones, y un único bus para transferir ambos tipos de información. Esta simplicidad ha favorecido su adopción generalizada, pero también trae consigo una limitación importante: el "cuello de botella de Von Neumann". Este fenómeno ocurre cuando el bus único se convierte en un factor restrictivo para la velocidad de procesamiento, especialmente en sistemas que requieren un acceso simultáneo a datos e instrucciones. Aunque esta arquitectura sigue siendo la base de muchas computadoras actuales, se han implementado optimizaciones y mejoras para mitigar sus limitaciones en los sistemas modernos [@hennessy_computer_2012; @stallings_computer_2013].

```{r vonneumann, echo=FALSE, fig.cap="Arquitectura Von Neumann", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/vonneumann.png")
```

### Arquitectura Harvard
En contraste, la arquitectura Harvard separa físicamente las memorias de datos y de instrucciones, permitiendo que el procesador acceda a ambas de forma simultánea. Este diseño elimina el cuello de botella de Von Neumann, logrando un rendimiento más eficiente, lo que la convierte en una opción preferida para sistemas que requieren un alto desempeño, como los sistemas embebidos y los procesadores de señal digital (DSP). La arquitectura Harvard es especialmente adecuada para aplicaciones donde el acceso rápido y eficiente a los datos es crucial [@tanenbaum_structured_2013].

```{r harvard, echo=FALSE, fig.cap="Arquitectura Harvard", fig.align = 'center', out.width = "85%"}
knitr::include_graphics(path = "images/harvard.png")
```

### Comparación y aplicaciones modernas
Aunque la simplicidad y flexibilidad de la arquitectura Von Neumann continúan siendo pilares fundamentales para una amplia gama de sistemas, la arquitectura Harvard ha ganado popularidad en escenarios donde la eficiencia y la velocidad son prioritarias, como en dispositivos móviles y sistemas de tiempo real. Hoy en día, arquitecturas modernas como **x86**, **ARM** y **RISC-V** implementan una combinación de ambos modelos para maximizar tanto el rendimiento como la eficiencia energética [@null_essentials_2014].

Esta integración híbrida permite a los diseñadores aprovechar las ventajas de cada enfoque, adaptando los sistemas a las necesidades específicas de las aplicaciones. La dicotomía entre ambas arquitecturas sigue siendo clave en la evolución de los sistemas modernos, donde el rendimiento y la eficiencia son factores críticos para el desarrollo de nuevas tecnologías.

## Tipos de arquitecturas
El análisis de diversas arquitecturas de computadoras es esencial para comprender sus respectivas ventajas y limitaciones en diferentes contextos de aplicación. Esta evaluación comparativa permite a los diseñadores y desarrolladores de sistemas seleccionar la arquitectura más adecuada para sus necesidades, considerando factores clave como la eficiencia energética, la complejidad del hardware y las aplicaciones específicas en las que se utilizará cada una.

### Arquitectura x86
La arquitectura x86, desarrollada inicialmente por Intel, ha dominado el mercado de computadoras de escritorio y servidores durante décadas gracias a su alto rendimiento y amplia compatibilidad con software legado. Su conjunto de instrucciones complejo (ISA) proporciona flexibilidad para una variedad de aplicaciones, aunque a costa de un mayor desafío en el diseño del hardware. Este equilibrio entre compatibilidad y rendimiento hace que x86 sea una opción preferida para entornos donde la capacidad de procesamiento es prioritaria, como en servidores y estaciones de trabajo [@hennessy_computer_2012].

### Arquitectura ARM
Reconocida por su alta eficiencia energética, la arquitectura ARM es la columna vertebral de dispositivos móviles y sistemas embebidos. Basada en el paradigma de conjunto de instrucciones reducidas (RISC), ARM simplifica el diseño del hardware y optimiza el consumo energético, características que la convierten en la elección ideal para aplicaciones como smartphones y tablets. Aunque su rendimiento bruto es inferior al de x86, su balance entre eficiencia y capacidad de procesamiento es crucial para mercados donde la autonomía es esencial [@patterson_computer_2014].

### Arquitectura MIPS
MIPS, otra arquitectura basada en RISC, ha destacado históricamente en sistemas embebidos y entornos educativos debido a su simplicidad y eficacia. Aunque su relevancia ha disminuido frente a opciones como ARM, MIPS sigue siendo valiosa en nichos específicos que requieren un diseño eficiente y de bajo costo. Su conjunto de instrucciones, aunque menos versátil que el de x86, logra un equilibrio adecuado para aplicaciones de mediana complejidad [@hennessy_computer_2012].

### Arquitectura RISC-V
RISC-V ha revolucionado el panorama de la arquitectura de computadoras con su enfoque abierto y libre. Su ISA flexible permite a los desarrolladores personalizar sistemas según necesidades específicas, haciéndola especialmente atractiva para investigación, educación y aplicaciones embebidas. Basada en principios RISC, RISC-V combina eficiencia energética con un diseño de hardware simplificado, y su creciente ecosistema la posiciona como una fuerte competidora frente a arquitecturas establecidas como ARM [@waterman_risc-v_2014].

### Comparativa de arquitecturas
Las características distintivas de cada arquitectura condicionan su idoneidad para diversas aplicaciones. Por ejemplo, mientras x86 sobresale en entornos de alto rendimiento, ARM domina en dispositivos móviles gracias a su eficiencia energética. MIPS y RISC-V, por su parte, se especializan en nichos como sistemas embebidos y proyectos personalizados. La selección adecuada de una arquitectura impacta significativamente en el éxito de un proyecto, desde el diseño hasta su implementación final [@patterson_computer_2014].

```{r comparq, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

comparq <- data.frame(
  Característica = c(
    "Eficiencia Energética",
    "Complejidad ISA",
    "Rendimiento",
    "Compatibilidad",
    "Áreas de Aplicación"
  ), # nolint: line_length_linter.
  x86 = c("Moderada", "Alta", "Alto", "Alta (hacia atrás)",
          "Escritorio, servidores"),
  ARM = c("Alta", "Baja", "Moderado", "Moderada", "Dispositivos móviles"),
  MIPS = c("Moderada", "Moderada", "Moderado",
           "Moderada", "Sistemas embebidos"),
  `RISC-V` = c("Alta", "Baja", "Variable", "Alta", "Investigación, embebidos")
)

# Crear la tabla con formato dinámico
tabla <- kable(comparq,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Comparación de Arquitecturas",
               col.names = c("Característica", "x86", "ARM", "MIPS", "RISC-V"), # nolint: line_length_linter.
               booktabs = TRUE,
               escape = FALSE)

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:5, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(comparq)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.

} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "20em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:5, width = "15em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

## Repertorio de instrucciones
El repertorio de instrucciones, conocido como ISA (Instruction Set Architecture), define el conjunto de operaciones que un procesador puede ejecutar y cómo se codifican dichas operaciones. Este conjunto incluye instrucciones aritméticas, lógicas, de control y manipulación de datos, además de los modos de direccionamiento y los formatos de las instrucciones. El diseño del ISA tiene un impacto directo en el rendimiento, la eficiencia energética y la flexibilidad del procesador, lo que lo convierte en un componente clave en la arquitectura de computadoras [@hennessy_computer_2012; @null_essentials_2014; @stallings_computer_2013].

### Características clave del ISA
Entre las características fundamentales a considerar en el diseño de un repertorio de instrucciones se encuentran las siguientes [@hennessy_computer_2012]:

  - **Tipos de operandos**: representan los datos que las instrucciones pueden manipular, como enteros, números en punto flotante, caracteres y direcciones de memoria. Un ISA eficiente debe soportar una amplia variedad de operandos para maximizar su versatilidad.
  - **Tipos de operaciones**: incluyen las operaciones que el procesador puede realizar, como aritméticas (suma, resta), lógicas (AND, OR), de control (saltos, llamadas a subrutinas) y de manipulación de datos (almacenamiento, carga). Un repertorio bien diseñado debe equilibrar funcionalidad y simplicidad.
  - **Modos de direccionamiento**: determinan cómo se especifican los operandos en las instrucciones. Modos como inmediato, directo, indirecto y relativo ofrecen diferentes niveles de flexibilidad y eficiencia.
  - **Formato de las instrucciones**: define la estructura de una instrucción, incluyendo su longitud, el número de operandos y los modos de direccionamiento. Este aspecto influye tanto en la complejidad del procesador como en su rendimiento.

```{r repInstCaracteristicas, echo=FALSE, fig.cap="Características repertorio de instrucciones", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/repInstCaracteristicas.jpg")
```

### Modos de direccionamiento
Los modos de direccionamiento son esenciales para determinar cómo el procesador accede a los datos necesarios para ejecutar una instrucción. Los modos más comunes incluyen [@stallings_computer_2013; @hennessy_computer_2012]:

  a) **Inmediato**: el operando está directamente incluido en la instrucción, permitiendo acceso rápido a valores constantes. Es eficiente para operaciones simples, aunque limitado a operandos pequeños.
  b) **Directo**: la instrucción contiene la dirección de memoria del operando. Es fácil de usar, pero está restringido por el rango de direcciones accesibles.
  c) **Indirecto**: la instrucción apunta a una dirección que contiene la ubicación real del operando, lo que amplía el rango de direcciones a costa de un acceso adicional a memoria.
  d) **Registro**: el operando se encuentra en un registro del procesador, proporcionando acceso extremadamente rápido, pero limitado por la cantidad de registros disponibles.
  e) **Registro Indirecto**: similar al modo indirecto, pero la dirección se almacena en un registro, combinando rapidez y flexibilidad.
  f) **Con Desplazamiento**: combina una dirección base con un valor de desplazamiento, ideal para estructuras como arrays y matrices.
  g) **Pila**: el operando está en la parte superior de la pila, útil para gestionar subrutinas y el paso de parámetros.

Estos modos se ilustran en la figura \@ref(fig:ModDir) según [@stallings_computer_2013]:
```{r ModDir, echo=FALSE, fig.cap="Modos de direccionamiento ", fig.align = 'center', out.width="60%"}
knitr::include_graphics(path = "images/modosdireccionamiento.png")
```

  - A = contenido de un campo de dirección en la instrucción
  - R = contenido de un campo de dirección en la instrucción que referencia a un registro
  - EA = dirección real (efectiva) de la posición que contiene el operando que se referencia

La tabla \@ref(tab:tabmoddir) detalla el cálculo de la dirección para cada modo de direccionamiento.

```{r tabmoddir, echo=FALSE, message=FALSE, warning=FALSE, table.pos='htbp'}
library(knitr)
library(kableExtra)
library(magrittr)

# Crear los datos de la tabla
tabmoddir <- data.frame(
  `Modo` = c("Inmediato", "Directo", "Indirecto", "Registro",
             "Indirecto con registro", "Con desplazamiento", "Pila"),
  `Algoritmo` = c("Operando \u2190 A", "EA \u2190 A", "EA \u2190 (A)",
                  "EA \u2190 R", "EA \u2190 (R)", "EA \u2190 A + (R)",
                  "EA \u2190 cabecera de la pila"),
  `Ventaja` = c("No referencia a memoria",
                "Es sencillo", "Espacio de direcciones grande",
                "No referencia a memoria",
                "Espacio de direcciones grande",
                "Flexibilidad",
                "No referencia a memoria"),
  `Desventaja` = c(
    "Operando de magnitud limitada",
    "Espacio de direcciones limitado",
    "Referencias múltiples a memoria",
    "Número limitado de registros",
    "Referencia extra a memoria",
    "Complejidad",
    "Aplicabilidad limitada"
  )
)

# Crear la tabla con formato dinámico
tabla_moddir <- kable(tabmoddir,
                      format = ifelse(knitr::is_latex_output(), "latex", "html"), # nolint
                      caption = "Modos de direccionamiento básicos",
                      col.names = c("Modo", "Algoritmo", "Ventaja", "Desventaja"), # nolint: line_length_linter.
                      booktabs = TRUE,
                      escape = FALSE)

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  tabla_moddir %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(tabmoddir)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.

} else {
  tabla_moddir %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "20em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

### Formato de las instrucciones
El formato de las instrucciones define su estructura, incluyendo longitud, cantidad de operandos y campos adicionales como el opcode. Este formato afecta la rapidez de decodificación y la eficiencia general del procesador [@hennessy_computer_2012; @tanenbaum_structured_2013]:

- **Longitud de la instrucción**: puede ser fija o variable. La longitud fija simplifica el diseño del hardware, mientras que la variable optimiza el uso de memoria, aunque incrementa la complejidad de decodificación.
- **Cantidad de operandos**: las instrucciones pueden trabajar con diferentes números de operandos (de 0 a 3 o más). Más operandos ofrecen mayor versatilidad, pero aumentan la complejidad y longitud de las instrucciones.
- **Campos de instrucción**: incluyen el opcode y campos adicionales como operandos, modos de direccionamiento y flags de condición. Estos campos determinan cuántas y qué tipo de operaciones puede ejecutar el procesador en un ciclo de reloj.

La Figura \@ref(fig:forminst) ilustra un esquema típico de formato de instrucciones:

```{r forminst, echo=FALSE, fig.cap="Formato de instrucciones ", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/formatoInst.jpg")
```

## Filosofías CISC y RISC
El diseño del repertorio de instrucciones es un componente esencial en la arquitectura de procesadores.  Dos de las filosofías más influyentes en este campo son **CISC (Complex Instruction Set Computing)** y **RISC (Reduced Instruction Set Computing)**. Mientras que **CISC** prioriza la reducción del número de instrucciones necesarias para realizar tareas complejas mediante operaciones multifuncionales, **RISC** simplifica el conjunto de instrucciones con el objetivo de maximizar la velocidad y la eficiencia energética. En esta sección se analizan ambos enfoques y sus implicaciones en el diseño de procesadores [@hennessy_computer_2012; @patterson_computer_2014].

### CISC
Las arquitecturas **CISC**, como la **x86**, se caracterizan por su enfoque en reducir el número de instrucciones requeridas para completar operaciones complejas. Esto se logra mediante la inclusión de instrucciones que combinan múltiples operaciones en un solo ciclo. Como resultado, los programadores necesitan escribir menos líneas de código para alcanzar un objetivo específico.

Sin embargo, este diseño implica ciertas desventajas. La **decodificación** y **ejecución** de instrucciones CISC requiere un hardware considerablemente más complejo, y las instrucciones de longitud variable, típicas de estas arquitecturas, pueden aumentar el tiempo de decodificación. Esto genera cuellos de botella en el pipeline y limita el rendimiento.

Por ejemplo, los procesadores **x86** que ha evolucionado hacia un enfoque híbrido. Utiliza microcódigo para descomponer las instrucciones complejas en operaciones más simples, parecidas a las de un procesador RISC. Aunque esta estrategia mejora la eficiencia de ejecución en algunos casos, el diseño sigue siendo más costoso en términos de consumo energético y complejidad [@patterson_computer_2014].

### RISC {#RISC}
Por su parte, las arquitecturas **RISC**, como **ARM** y **MIPS**, adoptan un conjunto reducido de instrucciones de longitud fija. Esta simplificación facilita la decodificación y permite que muchas instrucciones se ejecuten en un solo ciclo de reloj. Además, esta filosofía favorece la implementación de técnicas avanzadas como el pipelining y la predicción de ramas, optimizando así el rendimiento.

A nivel de hardware, RISC prioriza la eficiencia energética, una característica crucial en dispositivos móviles y sistemas embebidos. Por ello, procesadores como los basados en ARM han dominado estos mercados. La simplicidad y el bajo CPI (ciclos por instrucción) han sido factores determinantes en su adopción [@hennessy_computer_2012].

### Comparativa entre CISC y RISC
Las diferencias entre CISC y RISC son evidentes tanto a nivel de diseño como de implementación. En las arquitecturas RISC, las instrucciones tienen una longitud fija, lo que simplifica la decodificación, reduce la latencia y mejora la predictibilidad del rendimiento. Además, este formato mejora la eficiencia del uso de la memoria caché, al ocupar menos espacio y facilitar accesos más rápidos.

En cambio, las arquitecturas CISC, como x86, emplean instrucciones de longitud variable, lo que les permite ofrecer una mayor flexibilidad y un repertorio más amplio de operaciones. Sin embargo, esta flexibilidad conlleva un mayor tiempo de decodificación y una complejidad adicional en la implementación del pipeline. Esto puede causar problemas como interrupciones en el flujo debido a errores de predicción de ramas, aunque se mitiguen mediante técnicas avanzadas como la predicción dinámica de saltos y el prefetching [@tanenbaum_structured_2013].

Por ejemplo, en RISC, los modos de direccionamiento son simples y permiten un acceso más rápido a los operandos, reduciendo la latencia en el pipeline [@stallings_computer_2013]. En CISC, los modos de direccionamiento más complejos proporcionan flexibilidad a costa de una mayor latencia, lo que afecta el rendimiento general del sistema.

#### Ejemplos de instrucciones
Para ilustrar la diferencia entre ambas filosofías, se presenta el siguiente ejemplo: cargar dos valores de memoria, sumarlos y almacenar el resultado en una dirección de memoria.

RISC:

```{r  code0, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
  ; Carga el valor inmediato 10 en el registro R0
  LOAD R1, [mem1]    # Cargar el valor de mem1 en el registro R1
  LOAD R2, [mem2]    # Cargar el valor de mem2 en el registro R2
  ADD  R3, R1, R2    # Sumar los valores en los registros R1 y R2, guardar en R3
  STORE R3, [mem1]   # Guardar el resultado en mem1
  \\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
  LOAD R1, [mem1]    # Cargar el valor de mem1 en el registro R1
  LOAD R2, [mem2]    # Cargar el valor de mem2 en el registro R2
  ADD  R3, R1, R2    # Sumar los valores en los registros R1 y R2, guardar en R3
  STORE R3, [mem1]   # Guardar el resultado en mem1
  ```")
}
```

CISC:

```{r  code1, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
  MOV EAX, [mem1]    # Cargar el valor de mem1 en el registro EAX
  ADD EAX, [mem2]    # Sumar el valor de mem2 con EAX
  MOV [mem1], EAX    # Guardar el resultado de la suma de vuelta en mem1
  \\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
  MOV EAX, [mem1]    # Cargar el valor de mem1 en el registro EAX
  ADD EAX, [mem2]    # Sumar el valor de mem2 con EAX
  MOV [mem1], EAX    # Guardar el resultado de la suma de vuelta en mem1
  ```")
}
```
La tabla \@ref(tab:ciscrisc) resume las principales diferencias entre estas filosofías.

```{r ciscrisc, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

ciscrisc <- data.frame(
  Aspecto = c("Objetivo principal",
              "Tipo de instrucciones",
              "Decodificación y ejecución",
              "Longitud de instrucciones",
              "Eficiencia energética",
              "Modos de direccionamiento"),
  CISC = c("Minimizar el número de instrucciones para operaciones complejas",
           "Instrucciones complejas, longitud variable",
           "Requiere hardware más complejo, posibles cuellos de botella en el pipeline", # nolint: line_length_linter.
           "Longitud variable, puede aumentar el tiempo de decodificación",
           "Menor eficiencia energética en comparación con RISC",
           "Flexibilidad a costa de mayor latencia"),
  RISC = c("Simplificar el conjunto de instrucciones para optimizar velocidad y eficiencia energética", # nolint: line_length_linter.
           "Instrucciones simples, longitud fija",
           "Decodificación más sencilla, facilita el uso de técnicas avanzadas como pipelining", # nolint: line_length_linter.
           "Longitud fija, simplifica la decodificación y mejora la predictibilidad del rendimiento", # nolint: line_length_linter.
           "Mayor eficiencia energética, especialmente en dispositivos móviles",
           "Acceso más rápido a los operandos, menor latencia")
)

# Crear la tabla con formato dinámico
tabla <- kable(ciscrisc,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Comparativa entre CISC y RISC",
               col.names = c("Aspecto", "CISC", "RISC"),
               booktabs = TRUE,
               escape = FALSE)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "5cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(ciscrisc)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "20em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

#### Convergencia de filosofías
A pesar de sus diferencias, las arquitecturas modernas tienden a integrar características de ambas filosofías. Por ejemplo, los procesadores x86 adoptan técnicas propias de RISC para mejorar la eficiencia energética y el rendimiento. Esta convergencia refleja cómo los avances en diseño de procesadores buscan combinar lo mejor de cada enfoque, maximizando la flexibilidad y la eficiencia para adaptarse a las necesidades actuales y futuras del mercado.

## Arquitectura x86
La arquitectura x86, ampliamente reconocida por su influencia y uso extendido en computadoras de escritorio y servidores, tuvo sus inicios en 1978 con el procesador Intel 8086, que introdujo una arquitectura de 16 bits. Desde entonces, ha experimentado una evolución continua, marcando hitos significativos en la historia de la computación. En 1985, el Intel 80386 introdujo la arquitectura de 32 bits, habilitando capacidades como la memoria virtual. Posteriormente, en 2003, AMD amplió el estándar con la arquitectura AMD64, llevando x86 a 64 bits, lo que permitió acceder a mayores espacios de memoria y mejorar el rendimiento en aplicaciones intensivas. Estas innovaciones fueron adoptadas por Intel, consolidando la arquitectura x86 como una de las más versátiles y potentes del mercado [@stallings_computer_2013; @intel_64_2016; @amd_developer_2019; @abel_ibm_2000].

### Evolución de la arquitectura x86
Uno de los pilares del éxito de la arquitectura x86 ha sido su retrocompatibilidad, permitiendo la ejecución de aplicaciones de 16, 32 y 64 bits en un mismo sistema. Esta capacidad no solo ha asegurado la continuidad del ecosistema x86, sino que también ha protegido las inversiones en software y sistemas operativos, lo que resulta fundamental en el ámbito empresarial y académico.

A continuación, se presenta la tabla \@ref(tab:hitosx86) que resume los hitos clave en la evolución de los procesadores x86:

```{r hitosx86, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

hitosx86 <- data.frame(
  Procesador = c("Intel 8086", "Intel 80386", "AMD64"),
  `Año de Lanzamiento` = c(1978, 1985, 2003),
  `Número de Bits` = c(16, 32, 64),
  `Nuevas Características` = c(
    "Arquitectura inicial",
    "Memoria virtual",
    "Extensiones de 64 bits"
  )
)

# Crear la tabla con formato dinámico
tabla <- kable(hitosx86,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Hitos procesadores x86",
               col.names = c("Procesador", "Año de Lanzamiento", "Número de Bits", "Extensiones de 64 bits"), # nolint
               booktabs = TRUE,
               escape = FALSE)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(hitosx86)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "18em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

La tabla \@ref(tab:evolucionx86) muesta comó la evolución de x86 ha estado marcada por avances tecnológicos que han impulsado la informática hacia nuevas fronteras:

```{r evolucionx86, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

evolucionx86 <- data.frame(
  Año = c(1978, 1982, 1985, 1989, 1993, 1995, 2003, 2006),
Procesador = c("Intel 8086", "Intel 80286", "Intel 80386", "Intel 80486", "Intel Pentium", "Intel Pentium Pro", "AMD64", "Intel Core"), # nolint
`Innovación_Principal`  = c("Introducción de la arquitectura x86, 16 bits",
                            "Modos de operación adicionales",
                            "Arquitectura de 32 bits, memoria virtual",
                            "Unidad de punto flotante integrada, mejor caché",
                            "Ejecución superescalar, predicción de saltos",
                            "Ejecución fuera de orden, caché L2 integrada",
                            "Extensiones a 64 bits, mayor acceso a memoria",
                            "Optimización de rendimiento y eficiencia energética") # nolint: line_length_linter.
)

# Crear la tabla con formato dinámico
tabla <- kable(evolucionx86,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Línea de Tiempo de la Evolución de la Arquitectura x86", # nolint
               col.names = c("Año", "Procesador", "Innovación"),
               booktabs = TRUE,
               escape = FALSE)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "5cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(evolucionx86)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:3, width = "20em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

###  Repertorio de instrucciones x86
La arquitectura x86 destaca por su complejidad y flexibilidad, reflejada en un repertorio de instrucciones extenso y de longitud variable. Esto contrasta con arquitecturas RISC, donde predominan instrucciones de longitud fija y decodificación sencilla [@hennessy_computer_2012]. Aunque esta flexibilidad permite adaptaciones a diversas aplicaciones, también implica mayores desafíos en términos de implementación y eficiencia operativa.

#### Estructura de una instrucción x86
Una instrucción típica de x86 puede incluir los siguientes componentes [@stallings_computer_2013]:

  - **Prefijos**: modifican la operación principal de la instrucción. Por ejemplo, el prefijo `0x66` cambia el tamaño del operando.
  - **Código de operación (Opcode)**: indica la operación a realizar. Por ejemplo, `0x89` corresponde `MOV`.
  - **Modificadores de dirección (ModR/M y SIB)**: definen registros y direccionamiento. El byte **SIB** (Scale, Index, Base) es especialmente útil para operaciones complejas, como el acceso a matrices.
  - **Desplazamiento e inmediato**: Agregan flexibilidad en el manejo de datos, aunque aumentan la complejidad.

```{r FormatoInst, echo=FALSE, fig.cap="Formato de instrucciones del Pentium x86", fig.align = 'center', out.width = "100%"}
knitr::include_graphics(path = "images/formatoinstruccionx86.png")
```

Un ejemplo típico de instrucción es:

```{r  code2, results='asis', echo=FALSE}
if (knitr::is_latex_output()) {
  cat("
  \\begin{lstlisting}
  ; Carga el valor inmediato 10 en el registro R0
  MOV AX, [BX+SI+16]
  \\end{lstlisting}
  ")
} else {
  cat("
  ```assembly
    MOV AX, [BX+SI+16]
  ```")
}
```

Esta instrucción utiliza varios componentes, que el procesador debe decodificar antes de ejecutarla. Aunque esta flexibilidad es una ventaja en términos de funcionalidad, requiere técnicas avanzadas, como predicción de saltos y paralelización, para mantener la eficiencia en procesadores modernos [@patterson_computer_2014].

## Lenguaje ensamblador
Un procesador puede interpretar y ejecutar instrucciones exclusivamente en **lenguaje máquina**, que consiste en secuencias de números binarios almacenadas en memoria. Estas instrucciones son leídas y ejecutadas directamente por el procesador. Si un programador intentara escribir código en lenguaje máquina, debería especificar manualmente cada secuencia de ceros y unos para realizar operaciones, respetando estrictamente las estructuras de memoria y los modos de direccionamiento del procesador. Este proceso no solo es tedioso, sino también altamente propenso a errores, especialmente al realizar modificaciones, ya que implicaría descifrar y reescribir las secuencias binarias [@irvine2011assembly].

Para simplificar este desafío, se desarrolló el **lenguaje ensamblador**, un lenguaje de programación de bajo nivel que permite a los programadores utilizar instrucciones más legibles mediante mnemónicos simbólicos. A diferencia del lenguaje máquina, que opera con secuencias binarias, el ensamblador emplea símbolos que representan directamente las instrucciones ejecutadas por el procesador. Cada arquitectura de procesador tiene su propio lenguaje ensamblador, generalmente diseñado por el fabricante del hardware y optimizado para la arquitectura específica [@stallings_computer_2013].

### Ensamblador
El ensamblador es un programa que traduce las instrucciones simbólicas escritas en lenguaje ensamblador a lenguaje máquina, es decir, las convierte en las secuencias binarias que el procesador puede interpretar y ejecutar. Este proceso de traducción es prácticamente directo, ya que existe una correspondencia uno a uno entre las instrucciones en ensamblador y las instrucciones en lenguaje máquina [@stallings_computer_2013]. En contraste, los lenguajes de programación de alto nivel, como C o Python, suelen generar múltiples instrucciones máquina por cada línea de código fuente, lo que los distancia más de la arquitectura subyacente.

#### Ensambladores x86
En el caso de la arquitectura x86, los programadores pueden elegir entre diversos ensambladores, como TASM (Turbo Assembler) [@tasm], MASM (Microsoft Macro Assembler) [@masm] y NASM (Netwide Assembler) [@nasm]. Aunque cada ensamblador tiene características y sintaxis particulares, todos comparten el objetivo fundamental de convertir las instrucciones ensamblador en código binario ejecutable por los procesadores x86 [@hyde2010art].

A continuación, se presenta una comparativa de las principales características de estos ensambladores:

```{r ensambladores, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear un data frame con la información de los ensambladores
ensambladores <- data.frame(
  Característica = c("Desarrollador", "Año de lanzamiento", "Sistema operativo",
                     "Sintaxis", "Soporte de macros", "Compatibilidad",
                     "Capacidades adicionales", "Licencia", "Uso actual"),
  TASM = c("Borland", "1985", "MS-DOS, Windows",
           "Sintaxis similar a Intel con extensiones",
           "Macros y directivas avanzadas",
           "Compatibilidad con x86 antiguo",
           "Integración con herramientas Borland",
           "Comercial",
           "Menos común, usado en entornos heredados"),
  MASM = c("Microsoft", "1981", "MS-DOS, Windows",
           "Sintaxis de Intel con soporte avanzado",
           "Macros y directivas extensivas",
           "Compatibilidad con x86 antiguo",
           "Integración con Visual Studio",
           "Comercial",
           "Ampliamente usado en desarrollo Windows"),
  NASM = c("Simon Tatham et al.", "1996", "Multiplataforma (Windows, Linux, macOS)", # nolint: line_length_linter.
           "Sintaxis de Intel, modular y extensible",
           "Macros avanzadas y preprocesamiento",
           "Compatibilidad con x86, x86-64 y otros",
           "Soporte para múltiples formatos (binario, ELF, etc.)",
           "Código abierto",
           "Popular en sistemas y software libre"),
  stringsAsFactors = FALSE
)


# Crear la tabla con formato dinámico
tabla <- kable(ensambladores,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Hitos procesadores x86",
               col.names = c("Característica", "TASM", "MASM", "NASM"), # nolint
               booktabs = TRUE,
               escape = FALSE)

if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "4cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "4cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(ensambladores)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed", "responsive"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "18em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "18em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

<!--chapter:end:02-arquitectura.Rmd-->

# Simulación {#simulacion}
En este capítulo se analiza el papel de la simulación desde una perspectiva didáctica, destacando su relevancia como herramienta de apoyo en la enseñanza de Arquitectura de Computadoras. Se abordan los beneficios que ofrecen los simuladores en el proceso educativo y los desafíos que ayudan a superar en la formación de los estudiantes.

## Introducción a la simulación
La simulación es una herramienta esencial en una amplia variedad de campos, como la medicina, el ámbito militar, el entretenimiento y la educación. Su principal valor radica en su capacidad para modelar sistemas complejos, generar hipótesis, realizar análisis predictivos y explorar escenarios de manera segura y eficiente.

Banks define la simulación como el proceso de replicar el comportamiento de un sistema a lo largo del tiempo mediante un modelo conceptual que representa sus características y dinámicas principales [@banks_discrete-event_2010]. Estos modelos evolucionan simulando las interacciones entre sus componentes, lo que permite estudiar su respuesta ante diferentes variables y escenarios [@robinson_simulation_2014].

La posibilidad de analizar sistemas complejos sin intervenir directamente en ellos convierte a la simulación en una herramienta indispensable en el contexto actual, marcado por el avance de la tecnología y la creciente complejidad de los sistemas. Además, la simulación permite optimizar diseños, prever comportamientos y reducir los costos de desarrollo antes de implementar soluciones reales [@law_simulation_2015; @zeigler_theory_2000].

### Aplicaciones de la simulación en la industria
En sectores como la industria automotriz, la simulación es fundamental para el diseño y prueba de sistemas de seguridad, como airbags y frenos. Gracias a modelos virtuales, se realizan pruebas de colisión y análisis de rendimiento sin necesidad de recurrir a costosas pruebas físicas. Asimismo, la simulación permite optimizar diseños de motores, analizar el flujo aerodinámico y prever el comportamiento de materiales en condiciones extremas, contribuyendo a mejorar tanto la eficiencia como la seguridad de los vehículos [@stork_towards_2008].

En la aviación, los simuladores de vuelo son esenciales para entrenar pilotos, replicando condiciones reales de vuelo sin riesgos. Durante el diseño de aeronaves, estas herramientas permiten evaluar la aerodinámica y el rendimiento en diversos entornos, reduciendo significativamente el tiempo y los costos de desarrollo mientras incrementan la seguridad [@jentsch_simulation_2017].

Estos ejemplos destacan cómo la simulación no solo optimiza procesos industriales, sino que también asegura una mayor eficacia y seguridad en el diseño de productos complejos.

## Simulación en la educación
En el ámbito educativo, la simulación ha emergido como una herramienta poderosa para facilitar la enseñanza de conceptos complejos y fomentar el aprendizaje activo. A través de simuladores, los estudiantes pueden interactuar con sistemas virtuales y experimentar escenarios realistas, lo que mejora la comprensión de ideas abstractas y favorece la aplicación práctica de conocimientos teóricos [@lion_simuladores_2005].

A diferencia de los métodos tradicionales, como el uso de libros de texto o diapositivas, las herramientas de simulación integran tecnologías que vinculan conceptos teóricos con situaciones reales. Esto promueve una pedagogía interactiva, basada en la resolución de problemas y el aprendizaje por descubrimiento, estimulando la exploración y el razonamiento inferencial [@contreras_uso_2010].

En definitiva, la simulación enriquece la experiencia de aprendizaje al proporcionar una plataforma dinámica y participativa que facilita tanto la experimentación como la asimilación profunda de los contenidos.

### El rol de la simulación en la enseñanza de Arquitectura de Computadoras
En la carrera de Licenciatura en Sistemas, la asignatura Arquitectura de Computadoras persigue varios objetivos esenciales:
- Comprender la estructura y funcionamiento de las computadoras.
- Conocer las diferentes arquitecturas de sistemas microprocesadores.
- Evaluar medidas de rendimiento y comparar arquitecturas.
- Analizar el impacto de la tecnología de las computadoras en contextos sociales y económicos.

Enseñar los fundamentos teóricos de la organización y arquitectura interna de las computadoras puede ser un reto debido a la complejidad de los procesos involucrados. Los estudiantes necesitan desarrollar altos niveles de abstracción para construir modelos mentales que les permitan entender conceptos como la ejecución de instrucciones, la gestión de memoria o la interacción entre componentes del sistema.

Los simuladores desempeñan un papel crucial en este contexto al ofrecer representaciones visuales e interactivas de procesos complejos. Estas herramientas permiten a los alumnos experimentar con configuraciones y parámetros, observar su impacto en el rendimiento del sistema y explorar escenarios hipotéticos sin necesidad de hardware físico.

Además, la simulación actúa como un puente entre la teoría y la práctica, facilitando que los docentes refuercen conceptos abstractos con experiencias concretas. En conjunto, estas ventajas hacen de la simulación una metodología pedagógica invaluable, promoviendo la experimentación y el aprendizaje activo en la enseñanza de Arquitectura de Computadoras [@skrien_cpu_2001; @garcia-garcia_pbbcache_2020; @nova_tool_2013].

## El Formalismo DEVS (Discrete Event System Specification)
El formalismo DEVS es una metodología modular y jerárquica que permite modelar y analizar sistemas representables como sistemas de eventos discretos, continuos o híbridos. Desarrollado por Bernard P. Zeigler en la década de 1970, este enfoque amplía el concepto de las máquinas de Moore al incorporar una estructura capaz de modelar sistemas complejos mediante eventos cronometrados y transiciones de estados [@zeigler_theory_2000].

### Estructura del formalismo DEVS
DEVS describe el comportamiento de un sistema real utilizando eventos de entrada y salida, así como transiciones entre estados definidos. Un sistema en este formalismo se compone de dos tipos principales de modelos:

- **Modelos atómicos**: representan las unidades fundamentales de comportamiento.
- **Modelos acoplados**: integran modelos atómicos y/o otros modelos acoplados, permitiendo la construcción jerárquica de sistemas más complejos.

Esta organización modular facilita el análisis y la gestión de sistemas, permitiendo probar subsistemas de manera aislada antes de integrarlos en un modelo completo.

### Aplicaciones del formalismo DEVS
El formalismo DEVS encuentra aplicación en diversos ámbitos:

- **Redes de comunicación**: permite simular el enrutamiento de paquetes de datos, gestionar la congestión y optimizar protocolos de transmisión.
- **Manufactura**: modela el flujo de materiales, el control de calidad y los procesos en líneas de producción, identificando cuellos de botella y áreas para mejora.
- **Sistemas de transporte**: simula el comportamiento de flujos de tráfico o redes de transporte público para mejorar la eficiencia y reducir costos operativos.

Estas aplicaciones destacan su versatilidad para optimizar sistemas complejos en escenarios del mundo real.

### DEVS en la enseñanza de la Arquitectura de Computadoras
La implementación de entornos de simulación basados en DEVS en la enseñanza de arquitectura de computadoras aporta múltiples ventajas que enriquecen el proceso de aprendizaje:

- **Representación visual**: ofrece diagramas y representaciones dinámicas que ayudan a los estudiantes a visualizar y comprender procesos internos, como la ejecución de instrucciones y la gestión de recursos.
- **Interactividad**: permite modificar configuraciones y parámetros, fomentando la experimentación y mostrando el impacto directo de estas variables en el rendimiento del sistema.
- **Exploración de escenarios**: posibilita simular escenarios hipotéticos y evaluar el comportamiento de sistemas complejos sin la necesidad de hardware físico.

Estas características transforman la experiencia de aprendizaje, al vincular teoría con práctica y promover un enfoque activo en la comprensión de conceptos clave de arquitectura de computadoras. Al adoptar DEVS como parte del entorno educativo, se potencia la capacidad de los estudiantes para abordar problemas complejos y explorar soluciones innovadoras [@calvo_valdes_simulador_2010].

En conclusión, el formalismo DEVS no solo es una herramienta valiosa para el modelado y análisis de sistemas, sino que también representa un recurso poderoso para facilitar la enseñanza de conceptos complejos, como los que se encuentran en la arquitectura de computadoras.

<!--chapter:end:03-simulacion.Rmd-->

# Comparativa de simuladores {#comparativa}
En este capítulo se presentan el análisis y la comparación de diversos simuladores x86 con el propósito de evaluar su posible integración en la asignatura Arquitectura de Computadoras de la Licenciatura en Sistemas.

La selección y evaluación de estos simuladores se fundamenta en criterios específicos diseñados para medir su efectividad en un entorno educativo. El objetivo principal es identificar las herramientas que mejor respalden el proceso de enseñanza y aprendizaje. Los criterios considerados incluyen aspectos como usabilidad, funcionalidad del editor de código, calidad de la documentación, características de la ejecución de simulación, nivel de especificación de la arquitectura x86, propiedades del producto y alineación con los contenidos curriculares.

Los resultados de esta investigación fueron publicados en el XVII Congreso de Tecnología en Educación y Educación en Tecnología (2022), en el trabajo titulado Herramientas de software para dar soporte en la enseñanza y aprendizaje de la arquitectura x86 [@colombani_herramientas_2022].

## Estudios similares
Existen antecedentes de estudios comparativos que evalúan simuladores aplicados a la enseñanza en cursos de arquitectura de computadoras:
  - “A survey and evaluation of simulators suitable for teaching courses in computer architecture and organization”, 2009  [@nikolic_survey_2009]: este estudio analiza simuladores considerando dos categorías principales. La primera, relacionada con las características de simulación, incluye criterios como granularidad, usabilidad, disponibilidad, presentación visual y flujo de simulación. La segunda categoría evalúa la cobertura de los contenidos establecidos en los planes de estudio.
  - “Survey and evaluation of simulators suitable for teaching for computer architecture and organization Supporting undergraduate students at Sir Syed University of Engineering & Technology”, 2012 [@hasan_survey_2012]: este trabajo evalúa aspectos como la usabilidad, disponibilidad, fundamentos de arquitectura informática, jerarquía de sistemas de memoria, comunicación e interfaz, y diseño de sistemas de procesadores.

En contraste, este trabajo propone un enfoque diferenciado al centrar la evaluación en simuladores x86 bajo criterios diseñados específicamente para abordar tanto las características de simulación como los contenidos particulares de la asignatura Arquitectura de Computadoras de la Licenciatura en Sistemas de la Universidad Nacional de Entre Ríos.

## Simuladores bajo análisis
Un simulador de arquitectura es una herramienta de software que emula el hardware de un sistema de cómputo, permitiendo representar aspectos arquitectónicos y funcionales del mismo. Estos simuladores ofrecen un entorno controlado para realizar pruebas, modificaciones y ejecución de programas sin riesgo de dañar componentes físicos o enfrentar limitaciones de hardware [@radivojevic_design_2011].

Algunos simuladores destacan por proporcionar una representación visual e interactiva de la organización y arquitectura interna de una computadora, facilitando la comprensión de su funcionamiento. Ejemplos de estos simuladores incluyen Assembly Debugger (x86), Simple 8-bit Assembler Simulator, Microprocessor Simulator, Simulador de ensamblador de 16 bits y Emu8086. Estas herramientas juegan un papel fundamental en el aprendizaje de la arquitectura de computadoras, al conectar conceptos teóricos con experiencias prácticas y simplificar abstracciones complejas, además de servir como soporte en la labor docente [@nikolic_survey_2009][@hasan_survey_2012][@hennessy_computer_2012][@stallings_computer_2013][@behrooz_computer_2005].

## Criterios de evaluación
Los criterios de evaluación se definieron cuidadosamente para garantizar un análisis integral de los simuladores. A continuación, se presentan estos criterios junto con sus respectivos indicadores y escalas:

- **Usabilidad**: evalúa la facilidad de uso del simulador.
  - **Indicadores**: 
    - Facilidad de aprendizaje (tiempo necesario para familiarizarse con la herramienta).
    - Interfaz de usuario (claridad y organización).
    - Documentación y ayuda (accesibilidad y calidad de tutoriales y guías).
  - **Escala**: Difícil - Media - Fácil.

- **Editor**: analiza las funcionalidades para escribir y depurar código ensamblador.
  - **Indicadores**: 
    - Capacidad de edición (resaltado de sintaxis, puntos de interrupción, etc.).
    - Manejo de errores de sintaxis.
    - Opciones de almacenamiento (guardar y cargar programas).
  - **Escala**: Baja - Media - Alta.

- **Documentación**: valora la disponibilidad y calidad de los recursos de aprendizaje proporcionados.
  - **Indicadores**: 
    - Manual de usuario.
    - Tutoriales de aprendizaje.
    - Exhaustividad en la descripción del repertorio de instrucciones.
  - **Escala**: Mínima - Media - Completa.

- **Ejecución de simulación**: mide la facilidad para controlar y observar la ejecución de programas.
  - **Indicadores**: 
    - Control de simulación (pausa, reanudación, retroceso).
    - Visualización del flujo de ejecución.
    - Configurabilidad (ajuste de parámetros como la velocidad del reloj).
  - **Escala**: Baja - Media - Alta.

- **Nivel de especificación de la Organización y Arquitectura del sistema simulado**: determina la precisión en la representación de la arquitectura x86.
  - **Indicadores**: 
    - Fidelidad en la representación de la arquitectura.
    - Completitud del conjunto de instrucciones implementadas.
    - Inclusión y funcionalidad de memoria y módulos de E/S.
  - **Escala**: Mínima - Media - Completa.

- **Características del producto software**: evalúa las propiedades generales del simulador.
  - **Indicadores**: 
    - Tipo de licencia (open source o privativa).
    - Frecuencia de actualizaciones.
    - Plataforma (aplicación web o de escritorio)
  - **Escala**: Mala - Buena - Muy buena.

- **Cobertura de los contenidos preestablecidos en la currícula**: mide el grado en que el simulador abarca los contenidos de la asignatura.
  - **Indicadores**: 
    - Alineación con los tópicos del currículum.
    - Profundidad en el tratamiento de los temas.
  - **Escala**: Baja - Media - Alta.

## Selección de simuladores
A partir de una exhaustiva exploración en internet sobre herramientas de simulación de la arquitectura x86 utilizadas para la enseñanza, se identificaron los siguientes simuladores: Assembly debugger (x86), Simple 8-bit Assembler Simulator, Microprocessor Simulator, Simulador de ensamblador de 16 bits, Emu8086, VonSim, Orga1 y Qsim.

La selección se basó en una evaluación preliminar que consideró el tiempo necesario para su análisis y el grado de cumplimiento de los criterios definidos, priorizando aquellos simuladores que ofrecieran un balance adecuado entre funcionalidad, usabilidad, documentación y alineación con los contenidos curriculares de la asignatura Arquitectura de Computadoras. De esta preselección, se eligieron tres herramientas que, a priori, cumplían con la mayor cantidad de criterios evaluativos: **Emu8086**, **VonSim** y **Simple 8-bit Assembler Simulator**.

## Participantes en la evaluación
El proceso de evaluación fue realizado por un equipo conformado por tres docentes de la asignatura Arquitectura de Computadoras —Marcelo A. Colombani, José M. Ruiz y Amalia G. Delduca—, quienes aportaron su experiencia en el uso de simuladores y su aplicabilidad pedagógica. Además, se contó con la colaboración de un asesor externo, Marcelo A. Falappa, quien ofreció una visión independiente y validó tanto el proceso de evaluación como los resultados obtenidos.

## Análisis comparativo
A continuación, se presenta un análisis detallado de los simuladores seleccionados, basado en los criterios previamente establecidos:

### Simple 8-bit Assembler Simulator
- **Usabilidad**: Nivel medio. Todos los componentes se muestran en una sola pantalla, lo que puede resultar abrumador para usuarios principiantes.
- **Editor**: Nivel bajo. Incluye notificaciones de errores de sintaxis al ensamblar, pero carece de resaltado de sintaxis, puntos de interrupción (breakpoints) y opciones para guardar o cargar programas.
- **Documentación**: Nivel mínimo. Consta solo de un manual de instrucciones implementadas.
- **Ejecución de simulación**: Nivel medio. Permite ajustar la velocidad del reloj de la CPU y proporciona controles básicos de simulación.
- **Nivel de especificación**: Nivel mínimo. Simplifica la arquitectura x86 a un CPU de 8 bits con 256 bytes de memoria y sin soporte para operaciones de entrada/salida (IN/OUT).
- **Desarrollo del producto**: Nivel bueno. Licencia MIT, última actualización en 2015, desarrollado como una plataforma web.
- **Cobertura de contenidos**: Nivel bajo. No incluye memoria independiente para módulos de entrada y salida, rutinas de interrupciones ni representación visual del ciclo de instrucción.

### VonSim
- **Usabilidad**: Nivel medio. Utiliza solapas para presentar los componentes, lo que puede ser confuso para usuarios iniciales.
- **Editor**: Nivel medio. Proporciona notificaciones de errores de sintaxis, resaltado de código y puntos de interrupción mediante software.
- **Documentación**: Nivel medio. Incluye un manual de uso y un tutorial interactivo.
- **Ejecución de simulación**: Nivel medio. Permite ajustar la velocidad del reloj de la CPU y ofrece controles básicos de simulación.
- **Nivel de especificación**: Nivel medio. Representa una simplificación del procesador 8088 con arquitectura de 16 bits y memoria direccionable de 16 KiB.
- **Desarrollo del producto**: Nivel muy bueno. Licencia GNU Affero General Public License v3.0, última versión en 2020, con amplia evidencia de uso académico.
- **Cobertura de contenidos**: Nivel medio. Implementa dispositivos internos y externos, pero carece de visualización del ciclo de instrucción y métricas de rendimiento.

### Emu8086
- **Usabilidad**: Nivel fácil. Inicialmente muestra el editor y permite activar los componentes del simulador a medida que se cargan programas.
- **Editor**: Nivel alto. Incluye notificaciones de errores de sintaxis, resaltado de código, puntos de interrupción y opciones para guardar/cargar programas.
- **Documentación**: Nivel completo. Ofrece un manual de instrucciones con ejemplos, un tutorial de aprendizaje y una guía de uso detallada.
- **Ejecución de simulación**: Nivel alto. Proporciona control avanzado de la simulación, como retroceder una instrucción ("step back").
- **Nivel de especificación**: Nivel completo. Detalla la arquitectura del procesador 8086, con memoria direccionable de 1 MiB y soporte para interrupciones de software y hardware.
- **Desarrollo del producto**: Nivel bueno. Licencia privativa, última actualización en 2023, desarrollado para plataformas de escritorio.
- **Cobertura de contenidos**: Nivel alto. Emula el booteo de una IBM PC desde un disco flexible (floppy disk) y soporta todos los modos de direccionamiento.

```{r tabla-comparativa-criterios, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

tabla_comparativa <- data.frame(
  `Criterio de Evaluación` = c("Usabilidad", "Editor", "Documentación", "Ejecución de simulación", 
                             "Nivel de especificación x86", "Características del producto", 
                             "Cobertura de contenidos"),
  `Simple 8 bit Assembler Simulator` = c("Medio", "Bajo", "Mínima", "Medio", "Mínima", "Buena", "Baja"),
  VonSim = c("Medio", "Medio", "Media", "Medio", "Media", "Muy buena", "Media"),
  Emu8086 = c("Fácil", "Alto", "Completa", "Alta", "Completa", "Buena", "Alta")
)

kable(tabla_comparativa , format = "markdown", caption = "Comparativa según criterios de evaluación preestablecidos")
```

##   Resultados
La asignatura promueve el uso de simuladores para apoyar la enseñanza y el aprendizaje, permitiendo aplicar los contenidos desarrollados en máquinas reales. Emu8086 es la herramienta más adecuada para esta finalidad, ya que facilita la implementación de programas en hardware real. Sin embargo, su dependencia de MS-DOS complica su ejecución en sistemas operativos actuales, requiriendo el uso de emuladores de MS-DOS, lo que añade complejidad al proceso de enseñanza y aprendizaje.

Desde 2018, la asignatura utiliza la versión 4.08 de Emu8086. La herramienta tiene un periodo de evaluación gratuito de 14 días, después del cual se debe adquirir una licencia. Esto es un inconveniente, ya que se busca que los estudiantes puedan acceder a las herramientas de forma libre y gratuita.

Utilizar lenguaje NASM (Netwide Assembler) garantiza soporte tanto para Linux como Windows a través de herramientas libres como GCC (GNU Compiler Collection), generando programas para la arquitectura x86 de 16, 32 y 64 bits.

Emu8086 destaca por su interfaz dinámica, que muestra componentes como la pila, flags, teclado y pantalla solo cuando son necesarios, a diferencia de otros simuladores que presentan todos sus componentes desde el inicio.

En el criterio de evaluación dos, Emu8086 se destaca por su editor, que incluye puntos de ruptura para detener la ejecución del programa en un punto específico y retroceder a la intrucción anterior. Además, permite guardar y recuperar programas directamente desde el editor.

En el criterio de evaluación tres, Emu8086 se destaca por ofrecer tres tipos de documentación: un repertorio de instrucciones con ejemplos para cada tipo de instrucción, un manual que explica las partes de la herramienta y un tutorial para aprender a programar en ensamblador.

En el criterio de evaluación cuatro, Emu8086 se destaca por ofrecer una mayor cantidad de controladores para gestionar el flujo de ejecución, como la capacidad de retroceder la ejecución de una instrucción y recargar el programa actual.

En el criterio de evaluación cinco el emu8086 se destaca del resto debido a que ofrece una mayor especificidad de la arquitectura x86, además implementa interrupciones del sistema operativo MS-DOS, a través del cual se pueden ejecutar los programas en una máquina real.

En el criterio de evaluación seis VonSim se destaca del resto debido a que es licencia libre y posee una comunidad que respalda el proyecto.

En cuanto al último criterio, ninguna de las herramientas evaluadas cubre todos los contenidos que se pretende desarrollar con la ayuda de una herramienta, quedando excluido pasos del ciclo de instrucción y medidas de rendimientos (tiempo de CPU y CPI: ciclo por instrucción).

En resumen:
  - Emu8086 se destaca por su alta usabilidad, documentación completa, y precisión en la simulación de la arquitectura para la enseñanza de la arquitectura x86. Sin embargo, su licencia privativa y dependencia de MS-DOS representan desafíos importantes.
  - VonSim ofrece una buena solución con licencia libre y una interfaz más amigable, pero su nivel de especificación y cobertura de contenidos es medio, lo cual podría limitar su efectividad en el curso. 
  - Simple 8-bit Assembler Simulator tiene limitaciones significativas en usabilidad, documentación, y especificación, lo que lo hace menos adecuado para una enseñanza completa de la arquitectura x86.

Del análisis realizado, se concluye que, aunque todos los simuladores evaluados presentan ventajas y desventajas, ninguno de los simuladores analizados parece adecuado para la asignatura sugiere que los simuladores actuales no cumplen completamente con los requisitos de complejidad y cobertura necesarios para la enseñanza exhaustiva de la arquitectura x86. Se recomienda usar Emu8086 mientras se desarrolla un simulador que combine sus mejores características con una licencia libre, con soporte para sistemas operativos modernos y una mayor cobertura de contenidos curriculares para la asignatura.

### Publicación
Este análisis comparativo fue publicado en el XVII Congreso de Tecnología en Educación y Educación en Tecnología (2022), bajo el título "Herramientas de software para dar soporte en la enseñanza y aprendizaje de la arquitectura x86"[@colombani_herramientas_2022].

Además, durante este proceso se estableció contacto con un desarrollador de VonSim, logrando implementar mejoras significativas, como animaciones de ejecución y documentación en línea, disponibles en su última versión publicada en agosto de 2023.

<!--chapter:end:04-comparativa.Rmd-->

# Diseño y Construcción del Simulador {#desarrollo}
En este capítulo se describe el diseño y desarrollo de una herramienta de simulación específica para la arquitectura x86, orientada a facilitar la enseñanza de los principios de arquitectura de computadoras. Se detalla la justificación del diseño, los pasos seguidos para su construcción y los métodos utilizados para validar su funcionalidad.

En el capítulo anterior se analizaron y evaluaron las herramientas de simulación existentes para la arquitectura x86. Esta revisión exhaustiva permitió identificar las limitaciones de las soluciones actuales y fundamentar la necesidad de desarrollar una herramienta específica, cuyos resultados fueron publicados posteriormente.

Para cumplir con este objetivo, el diseño de la herramienta sigue una serie de requisitos establecidos que guían su desarrollo, validación y alineación con los objetivos pedagógicos. 

## Requisitos de la herramienta
La herramienta de simulación está diseñada para cumplir los siguientes requisitos:

1. **Representación global de la estructura y funcionamiento de la computadora:**
   - Mostrar de manera visual la estructura completa de la computadora (CPU, bus, memoria y E/S) durante la ejecución de programas, resaltando relevantes.

2. **Soporte para la generación y ejecución de programas en ensamblador:**
   - Facilitar la ejecución de programas en ensamblador paso a paso como completa, promoviendo la comprensión detallada de cada instrucción.

3. **Repertorio de instrucciones reducido y habilitación progresiva:**
   - Seleccionar un subconjunto esencial de instrucciones x86, que se habiliten progresivamente según avance la asignatura, adaptándose al ritmo de aprendizaje de los estudiantes.

4. **Simulación visual e interactiva de micropasos de instrucciones:**
    - Representar el flujo de datos con el lenguaje de transferencia entre registros (RTL), destacando visualmente cada componente involucrado en la ejecución de un programa.
    
5. **Gestión básica de interrupciones y periféricos:**
    - Incorporar un vector de interrupción predefinido para interactuar con dispositivos como teclado y monitor. También incluir instrucciones IN y OUT, junto con un módulo simplificado de entrada/salida.

6. **Métricas de rendimiento:**
    - Proporcionar indicadores clave como tiempo de ciclo, tiempo de CPU y ciclos por instrucción (CPI) para analizar la ejecución de programas.

## Diseño conceptual
En esta sección se detalla el proceso de planificación del simulador, enfocándose en cómo los requisitos definidos orientan su construcción y garantizan la alineación con los objetivos pedagógicos establecidos.

### Modelo arquitectónico
La arquitectura propuesta corresponde a una versión simplificada de **8 bits** de la arquitectura **x86**, diseñada con un repertorio de instrucciones reducido y un conjunto de componentes esenciales. Este diseño simplificado busca facilitar que los estudiantes comprendan conceptos clave como el formato de instrucciones, los modos de direccionamiento y el ciclo de búsqueda y ejecución.

#### Principales bloques funcionales
El simulador se compone de los siguientes bloques funcionales:

```{r bloquesfuncionales, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

bloquesfuncionales <- data.frame(
  Bloque = c("Unidad Central de Procesamiento (CPU)",
             "Memoria",
             "Sistema de Entrada/Salida (E/S)",
             "Bus de datos, direcciones y control"),
  Descripción = c("Simulación de registros, Unidad de Control (UC) y Unidad Aritmética y Lógica (ALU).", # nolint
                  "Estructura de memoria y simulación de operaciones de lectura y escritura.", # nolint
                  "Interacción con periféricos y manejo de interrupciones.",
                  "Modelado de la comunicación entre componentes.")
)

# Crear la tabla con formato dinámico
tabla <- kable(bloquesfuncionales,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Bloques funcionales principales",
               col.names = c("Bloque Funcional", "Descripción"),
               booktabs = TRUE,
               escape = FALSE)

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "9cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(bloquesfuncionales)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "25em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "40em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

#### Características del CPU
El diseño del CPU simplificado se describe en la siguiente tabla \@ref(tab:arq):

```{r arq, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear el data frame con los datos del cuadro
arq <- data.frame(
  `Componente` = c("Arquitectura",
                   "Registros",
                   "",
                   "",
                   "Memoria",
                   "Buses",
                   "Instrucciones"),
  `Características` = c("Von Neumann, memoria compartida para datos e instrucciones.", # nolint
                        "4 registros de propósito general (`AL`, `BL`, `DL` y `DL`) de 8 bits cada uno.", # nolint
                        if (knitr::is_latex_output()) {
                          "4 registros de propósito específico:\\begin{itemize} \\item `IP` (Instruction Pointer) \\item `IR` (Instruction Register) \\item `SP` (Stack Pointer) \\item `RS` (registro de estado) \\end{itemize}" # nolint: line_length_linter.
                        } else {
                          "4 registros de propósito específico:<ul><li>`IP` (Instruction Pointer)</li><li>`IR` (Instruction Register)</li><li>`SP` (Stack Pointer)</li><li>`RS` (registro de estado)</li></ul>" # nolint: line_length_linter.
                        },
                        "2 registros intermedios (`MAR`: buffer de direcciones y `MBR`: buffer de datos) para comunicación entre CPU y memoria.", # nolint
                        "Memoria de 256 posiciones, con una capacidad de un byte por posición.", # nolint
                        "Bus de datos y direcciones de 8 bits.",
                        "Longitud variable de instrucciones (1, 2 y 3 Bytes). Modos de direccionamiento: registro a registro, directo, indirecto e inmediato."), # nolint: line_length_linter.
  stringsAsFactors = FALSE
)

# Crear la tabla con formato dinámico
tabla <- kable(arq,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Componentes del CPU x86",
               col.names = c("Componente", "Características"),
               booktabs = TRUE,
               escape = FALSE)

# Mostrar la tabla en formato adecuado según el tipo de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "9cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(arq)),
             extra_latex_after = "\\addlinespace[10pt]")  # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "25em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2, width = "40em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2")
}
```

## Implementación del repertorio de instrucciones

### Selección del repertorio inicial
El repertorio se diseñó como una simplificación de la arquitectura x86, orientada a mejorar la enseñanza y el aprendizaje. En una primera etapa, se introducen únicamente las instrucciones esenciales para abordar los contenidos iniciales de la asignatura:

```{r setreducido, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear los datos
setreducido <- data.frame(
  Instrucciones = c(
    "Transferencia de datos",
    "Pocesamiento de datos",
    "",
    "",
    "Control de flujo",
    "",
    ""
  ),
  `Código operación` = c(
    "{0, 1, 2}",
    "{3, 4, 5}",
    "{6, 7, 8}",
    "{9, 10, 11}",
    "{12}",
    "",
    ""
  ),
  `Nemónico` = c(
    "MOV ",
    "ADD",
    "SUB",
    "CMP",
    "JMP",
    "JZ ",
    "JC "
  ),
  Acción = c(if (knitr::is_latex_output()) {
    "\\begin{itemize} \\item 0 - Operación entre registros \\item 1 - Operación carga a registro \\item 2 - Operación almacena en memoria \\end{itemize}" # nolint: line_length_linter.
  } else {
    "<ul><li>0 - Operación entre registros</li><li>1 - Operación carga a registro</li><li>2 - Operación almacena en memoria</li></ul>" # nolint: line_length_linter.
  },
  "3-4-5 Sumar",
  "6-7-8 Restar",
  "9-10-11 Comparar",
  "12-a Salto incondicional ",
  "12-b Salto condicional si Z=1",
  "12-c Salto condicional si C=1"
  )
)

# Crear la tabla con formato dinámico
tabla <- kable(setreducido,
               format = ifelse(knitr::is_latex_output(), "latex", "html"),
               caption = "Tabla de instrucciones y códigos de operación",
               col.names = c("Instrucciones", "Código operación", "nemónico", "Acción"), # nolint: line_length_linter.
               booktabs = TRUE,
               escape = FALSE)


# Mostrar la tabla en formato adecuado según el tipo de salida
if (knitr::is_latex_output()) {
  tabla %>%
    kable_styling(
      latex_options = c("scale_down", "hold_position"),
      font_size = 10
    ) %>%
    column_spec(1, width = "6cm", bold = TRUE, border_right = TRUE) %>% # nolint: line_length_linter.
    column_spec(2, width = "6cm") %>%
    column_spec(3, width = "4cm") %>%
    column_spec(4, width = "6cm") %>%
    row_spec(0, bold = TRUE, align = "c", background = "#D3D3D3") %>%
    row_spec(seq_len(nrow(setreducido)), extra_latex_after = "\\addlinespace[8pt]") # Espacio adicional entre filas # nolint: line_length_linter.
} else {
  tabla %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = FALSE,
      position = "center"
    ) %>%
    column_spec(1, width = "25em", bold = TRUE) %>% # nolint: line_length_linter.
    column_spec(2, width = "25em") %>%
    column_spec(3, width = "15em") %>%
    column_spec(4, width = "25em") %>%
    row_spec(0, bold = TRUE, color = "white", background = "#0073C2") %>%
    footnote(
      general = "Las instrucciones de transferencia y de procesamiento de datos tienen los tres tipos de combinaciones en los operandos.", # nolint: line_length_linter.
      general_title = "Nota: ",
      threeparttable = TRUE
    )
}
```

### Justificación de la simplificación
La arquitectura x86 destaca por su complejidad debido a su extenso repertorio de instrucciones y características avanzadas. Por ello, el simulador se desarrolla bajo un enfoque pedagógico que considera:

- **Reducir la carga cognitiva**: la simplificación del repertorio y de los componentes permite a los estudiantes enfocarse en principios fundamentales.
- **Aprendizaje progresivo**: se adopta un enfoque escalonado, empezando con un modelo simplificado y avanzando hacia representaciones más completas de x86.
- **Claridad pedagógica**: las prácticas son manejables en términos de tiempo y esfuerzo, promoviendo un aprendizaje práctico sin frustraciones.

### Beneficios de la simplificación
El diseño del simulador contribuye a:

- **Comprensión fundamental**: los estudiantes pueden enfocarse en el ciclo de instrucciones, interacción de componentes y flujo básico de datos.
- **Análisis crítico**: comparar el modelo simplificado con x86 real fomenta un aprendizaje reflexivo y profundo.
- **Experimentación práctica**: proporciona un entorno accesible para explorar conceptos y corregir errores.

### Formato de instrucciones
El formato definido para las instrucciones incluye los siguientes casos tabla \@ref(tab:codtraducido):

```{r codtraducido, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)
library(magrittr)

# Crear un dataframe con los datos
codtraducido <- data.frame(
  Tipo = c("", "Transferencia y procesamiento", "", "Control"),
  Operación = c("A: entre registros", "B: Cargar a registro", "C: Almacenar en memoria", "D: control de flujo"), # nolint: line_length_linter.
  Codificación = c("____XXYY", "____XX00 MMMMMMMM", "____00YY MMMMMMMM", "____ffff MMMMMMMM"), # nolint: line_length_linter.
  Parámetros = c(
    "XX = Registro destino\nYY = Registro fuente",
    "XX = Registro destino\nM = Dirección de memoria",
    "YY = Registro fuente\nM = Dirección de memoria",
    "ffff = funcionalidad\nM = Dirección de memoria"
  ),
  stringsAsFactors = FALSE
)

# Mostrar la tabla en formato adecuado según el tipo de salida
if (knitr::is_latex_output()) {
  kable(codtraducido, format = "latex", booktabs = TRUE, align = "l", col.names = c("Tipo", "Operación", "Codificación", "Parámetros"), # nolint: line_length_linter.
        caption = "Tabla de codificación de instrucciones") %>%
    kable_styling(latex_options = c("hold_position", "scale_down")) %>%
    column_spec(1, width = "3cm") %>%
    column_spec(2, width = "5cm") %>%
    column_spec(3, width = "5cm") %>%
    column_spec(4, width = "6cm") %>%
    row_spec(3, extra_latex_after = "\\midrule")
} else {
  kable(codtraducido, format = "html", table.attr = "class='table table-striped'", align = "l", col.names = c("Tipo", "Operación", "Codificación", "Parámetros"), # nolint: line_length_linter.
        caption = "Tabla de codificación de instrucciones") %>%
    kable_styling(full_width = FALSE, position = "center") %>%
    column_spec(1, width = "20em") %>%
    column_spec(2, width = "25em") %>%
    column_spec(3, width = "25em", extra_css = "font-size: 6pt;") %>%
    column_spec(4, width = "30em")
}
```

Considerando:

  - `____`: Código de operación de la instrucción, número de 4 bits.

  - `XX` o `YY`: Índices de registros, número entre `0` y `3`, cada índice es de 2 bits.

  - `M`: Dirección de memoria, número de 8 bits.

  - `ffff`: representan el comportamiento de la instrucción, número de 4 bits.

### Modos de direccionamiento
Los modos de direccionamiento definidos en esta etapa son:

- Registro a registro (`Rx`,`Ry`): operandos son registros del procesador.
- Directo (`[M]`): operando es el contenido de una dirección de memoria.

#### Banco de registros
```{r tabla_registros, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear un dataframe con los datos
tabla_registros <- data.frame(
  Registro = c("AL", "BL", "CL", "DL"),
  Binario = c("00", "01", "10", "11"),
  Decimal = c(0, 1, 2, 3)
)

# Imprimir la tabla en formato markdown
kable(tabla_registros, format = "markdown", col.names = c("Registros (R)", "Binario", "Decimal")) # nolint: line_length_linter.
```

En esta primera etapa se implementan las siguientes instrucciones con estos modos de direccionamiento y formato de instrucciones:

```{r tablainst, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)

# Crear un dataframe con los datos
tablainst <- data.frame(
  `#` = c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "A", "B", "C", "C", "C"),
  Instrucción = c("MOV Rx, Ry", "MOV Rx, [M]", "MOV [M], Ry", "ADD Rx, Ry", "ADD Rx, [M]", "ADD [M], Ry", "SUB Rx, Ry", "SUB Rx, [M]", "SUB [M], Ry", "CMP Rx, Ry", "CMP Rx, [M]", "CMP [M], Ry", "JMP M", "JC M", "JZ M"), # nolint
  Acción = c(
    "Rx ← Ry",
    "Rx ← Mem[Dirección]",
    "Mem[Dirección] ← Rx",
    "Rx ← Rx + Ry",
    "Rx ← Rx + Mem[Dirección]",
    "Mem[Dirección] ← Mem[Dirección] + Ry",
    "Rx ← Rx - Ry",
    "Rx ← Rx - Mem[Dirección]",
    "Mem[Dirección] ← Mem[Dirección] - Ry",
    "Modifica flags de Rx - Ry",
    "Modifica flags de Rx - Mem[Dirección]",
    "Modifica flags de Mem[Dirección] - Ry",
    "IP ← Dirección",
    "Si flag C=1 entonces IP ← Dirección",
    "Si flag Z=1 entonces IP ← Dirección"
  ),
  Codificación = c(
    "0000 XXYY",
    "0001 00YY MMMMMMMM",
    "0010 XX00 MMMMMMMM",
    "0011 XXYY",
    "0100 00YY MMMMMMMM",
    "0101 XX00 MMMMMMMM",
    "0110 XXYY",
    "0111 00YY MMMMMMMM",
    "1000 XX00 MMMMMMMM",
    "1001 XXYY",
    "1010 00YY MMMMMMMM",
    "1011 XX00 MMMMMMMM",
    "1100 0000 MMMMMMMM",
    "1100 0001 MMMMMMMM",
    "1100 0011 MMMMMMMM"
  )
)

# Imprimir la tabla en formato adecuado según el tipo de salida
if (knitr::is_latex_output()) {
  kable(tablainst, format = "latex", booktabs = TRUE, col.names = c("#", "Instrucción", "Acción", "Codificación"), caption = "Tabla de Instrucciones y Codificación") %>% # nolint: line_length_linter.
    kable_styling(latex_options = c("hold_position", "scale_down")) %>%
    column_spec(1, width = "1cm") %>%
    column_spec(2, width = "3cm") %>%
    column_spec(3, width = "5cm") %>%
    column_spec(4, width = "5cm")
} else {
  kable(tablainst, format = "markdown", col.names = c("#", "Instrucción", "Acción", "Codificación")) # nolint: line_length_linter.
}
```

### Ciclo de la instrucción: Etapas de captación y ejecución
En este apartado se detalla el proceso llevado a cabo por la Unidad de Control (UC) para ejecutar cada instrucción, destacando los aspectos clave:

- Secuencia de pasos.
- Registros involucrados en cada etapa del proceso.
- Uso de los buses de datos, direcciones y control.
- Señales de control generadas.

El **ciclo de la instrucción** se define como la secuencia de microoperaciones necesarias para ejecutar una instrucción en el sistema. Estas microoperaciones se expresan mediante un lenguaje de transferencia entre registros, representado de la forma:

`destino` $\leftarrow$ `origen` 

#### Etapa de Captación: 
En esta etapa, común a todas las instrucciones, consiste en la lectura de la instrucción desde la memoria.

  1. **`MAR` $\leftarrow$ `IP`**:
  el contenido del registro puntero de instrucciones `IP` se transfiere al registro de direcciones de memoria `MAR`. La UC genera la señal necesaria para seleccionar el valor del `IP` y copiarlo en el `MAR`.
  2. **`MDR` $\leftarrow$ `read(Memoria[MAR])` ; `IP` $\leftarrow$ `IP` + 1**:
  la UC activa la señal de lectura (read) hacia la memoria, utilizando el valor del `MAR` como dirección. El dato leído se transfiere al registro de datos de memoria `MBR` a través del bus de datos. Simultáneamente, el `IP` se incrementa en 1 para apuntar al siguiente byte.
  3. **`IR` $\leftarrow$ `MBR`**:
  el contenido del `MBR` se transfiere al registro de instrucciones `IR`, completando la etapa de captación. 

#### Etapa de Ejecución:
En esta etapa, las operaciones específicas dependen del tipo de instrucción. A continuación, se describen algunos casos representativos:

* MOV `Rx`, `Ry` (Copia entre registros)
  1. **`Rx` $\leftarrow$ `Ry`**:
  el contenido del registro `Ry` se copia en el registro `Rx`.

* MOV `Rx`, `[Dirección]` (Carga a registro)
  1. **`MAR` $\leftarrow$ `IP`**:
  el valor del `IP` se transfiere a `MAR`.
  2. **`MBR` $\leftarrow$ `read(Memoria[MAR])`; `IP` $\leftarrow$ `IP` + 1**:
  se lee (read) de memoria el contenido de la dirección indicada por `MAR` y se almacena en `MBR`.Simultáneamente, el `IP` se incrementa.
  3. **`MAR` $\leftarrow$ `MBR`**:
  el contenido de `MBR` se transfiere a `MAR`.
  4. **`MBR` $\leftarrow$ `read(Memoria[MAR])`**:
  se lee de memoria el contenido de la dirección indicada por `MAR` y se almacena en `MBR`.
  5. **`Rx`  $\leftarrow$ `MBR`**:
  el contenido del `MBR` se copia al registro `Rx`.

* MOV `[Dirección]`, `Ry` (Almacenar en memoria)     
  1. 2. 3. igual que MOV `Rx`, `[Dirección]`.
  4. **`MBR` $\leftarrow$ `Ry`**:
  el contenido de `Ry` se transfiere a `MBR`.
  5. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**:
  el contenido de `MBR` se escribe (write) en memoria en la dirección apuntada por el `MAR`.

* ADD  `Rx`, `[Dirección]` (Sumar a registro)
  1. 2. 3. 4. igual que MOV `Rx`, `[Dirección]`.
  5. **`Rx`  $\leftarrow$ `Rx` + `MBR`**:
  la Unidad Aritmético-Lógica (ALU) realiza la suma entre `Rx` y `MBR`, almacenando el resultado en `Rx`. El Registro de Estado `RS` se actualiza con los indicadores correspondientes.

* SUB `[Dirección]`, `Ry` (Restar a memoria)
  1. 2. 3. 4. igual que MOV `Rx`, `[Dirección]`.
  5. **`MBR` $\leftarrow$ `Ry` - `MBR`**: 
  la ALU resta el contenido de `MBR` al de `Ry`, almacenando el resultado en `MBR`. El `RS` se actualiza.
  6. **`write(Memoria[MAR])` $\leftarrow$ `MBR`**:
  el contenido de `MBR` se escribe en memoria en la dirección apuntada por el `MAR`.

* CMP `Rx`,  `[Dirección]` (Comparar a registro)
  1. 2. 3. 4. igual que MOV `Rx`, `[Dirección]`.
  5. **`Rx` - `MBR`**: 
  la ALU realiza la resta entre el contenido de `Rx` y `MBR`. Aunque el resultado no se almacena, el `RS` se actualiza con los indicadores de comparación.

* JMP  `Dirección` (Salto incondicional)
  1. 2. igual que MOV `Rx`, `[Dirección]`.
  3. **`IP` $\leftarrow$ `MBR`**:
  El contenido del `MBR` se transfiere al registro `IP`, estableciendo la nueva dirección de ejecución.

* JC  `Dirección` (Salto condicional si C=1)
  1. 2. Igual que MOV `Rx`, `[Dirección]`.
  3. `Si C` == 1: **`IP` $\leftarrow$ `MBR`**:
  si la bandera de acarreo (`C`) está activa, el contenido del `MBR` se transfiere al registro `IP`.

* JZ  `Dirección` (Salto condicional si Z=1)
  1. 2. igual que MOV `Rx`, `[Dirección]`.
  3. `Si Z` == 1: **`IP` $\leftarrow$ `MBR`**:
  si la bandera de cero (`Z`) está activa, el contenido del `MBR` se transfiere al registro `IP`.

### Modos de direccionamiento adicionales
Se incoporan los siguientes modos de direccionamiento:

- Indirecto por registro (`[BL]`): la dirección del operando se encuentra en el registro `BL` del procesador.
- Inmediato (`d`): operando es un valor contenido en la instrucción. 

### Formato ampliado
Las instrucciones ahora se codifican con 1, 2 o 3 bytes dependiendo del modo:

Las instrucciones de cargar a registro (B):

```{r dirampliado, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Definir los datos de la tabla
dirampliado <- data.frame(
  `Función` = c("00", "01", "10", "11"),
  `Byte` = c("2", "1", "2", "2"),
  `Interpretación` = c(
    "Directo `M` = Dirección de memoria",
    "Indirecto utiliza como operando implícito el registro `BL` y no requiere operando `M`", # nolint: line_length_linter.
    "Inmediato `d` = Dato inmediato",
    "Indirecto la dirección se calcula operando implícito `BL` + Dato inmediato"
  )
)

kable(dirampliado, format = "markdown", col.names = c("Función", "Byte", "Interpretación")) # nolint: line_length_linter.
```


Las instrucciones de almacenar en memoria (C):

```{r dirampliado2, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Definir los datos de la tabla
dirampliado2 <- data.frame(
  `Función` = c("00YY", "01YY", "01YY", "1100", "1101", "1110"),
  `Byte` = c("2", "1", "2", "3", "2", "3"),
  `Interpretación` = c(
    "directo `D` = Dirección de memoria, `YY` = Registro fuente",
    "indirecto `BL`, `YY` = Registro fuente",
    "Indirecto la dirección se calcula operando implícito `BL` + Dato Inmediato", # nolint: line_length_linter.
    "Inmediato a memoria",
    "Inmediato a memoria mediante indirecto `BL`",
    "Inmediato a memoria mediante indirecto `BL`+ Dato Inmediato"
  )
)

kable(dirampliado2, format = "markdown", col.names = c("Función", "Byte", "Interpretación")) # nolint: line_length_linter.
```

El formato ampliado para las instrucciones incluye los siguientes casos tabla \@ref(tab:formatoampliado):

```{r formatoampliado, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear un dataframe con los datos
formatoampliado <- data.frame(
  Tipo = c("Transferencia y procesamiento", "", "", "", "", "Control"),
  Operación = c("A: entre registros", "B: Cargar a registro", "", "", "C: Almacenar en memoria", "D: control de flujo"), # nolint: line_length_linter.
  Codificación = c("____XXYY", "____XX00 MMMMMMMM", "____XX01", "____XX00 dddddddd", "____00YY MMMMMMMM dddddddd", "____ffff MMMMMMMM"), # nolint: line_length_linter, line_length_linter.
  Parámetros = c(
    "XX = Registro destino, YY = Registro fuente",
    "XX00 = Registro destino y M = Dirección de memoria",
    "XX01 = Registro destino y direccion en registro [BL]",
    "XX10 = Registro destino y d = Dato inmediato",
    "YY = Registro fuente, `M` = Dirección de memoria,  `d` = Dato Inmediato",
    "ffff = funcionalidad, M = Dirección de memoria"
  ),
  stringsAsFactors = FALSE
)

# Mostrar la tabla en formato adecuado según el tipo de salida
if (knitr::is_latex_output()) {
  kable(formatoampliado, format = "latex", booktabs = TRUE, align = "l", col.names = c("Tipo", "Operación", "Codificación", "Parámetros"), # nolint: line_length_linter.
        caption = "Tabla de codificación de instrucciones ampliado") %>%
    kable_styling(latex_options = c("hold_position", "scale_down")) %>%
    column_spec(1, width = "4cm") %>%
    column_spec(2, width = "5cm") %>%
    column_spec(3, width = "5cm") %>%
    column_spec(4, width = "6cm") %>%
    row_spec(4, extra_latex_after = "\\midrule") %>%
    footnote(
      general = "d = dato inmediato, no puede ser destino de la instrucción.", # nolint: line_length_linter.
      general_title = "Nota: ",
      threeparttable = TRUE
    )
} else {
  kable(formatoampliado, format = "html", table.attr = "class='table table-striped'", align = "l", col.names = c("Tipo", "Operación", "Codificación", "Parámetros"), # nolint: line_length_linter.
        caption = "Tabla de codificación de instrucciones ampliado") %>%
    kable_styling(full_width = FALSE, position = "center") %>%
    column_spec(1, width = "20em") %>%
    column_spec(2, width = "25em") %>%
    column_spec(3, width = "25em") %>%
    column_spec(4, width = "30em") %>%
    row_spec(4, extra_css = "border-top: 2px solid #000;") %>%
    footnote(
      general = "d = dato inmediato, no puede ser destino de la instrucción.", # nolint: line_length_linter.
      general_title = "Nota: ",
      threeparttable = TRUE
    )
}
```



```{r formatoampliado2, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Crear un dataframe con los datos
formatoampliado2 <- data.frame(
  CodOp = c(
    "0",
    "1",
    "1",
    "1",
    "1",
    "2",
    "2",
    "2",
    "2",
    "2",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "C",
    "C",
    "C"
  ),
  Instrucción = c(
    "`MOV Rx, Ry`",
    "`MOV Rx, [M]`",
    "`MOV Rx, [BL]`",
    "`MOV Rx, D`",
    "`MOV Rx, [BL + D]`",
    "`MOV [M], Ry`",
    "`MOV [BL], Ry`",
    "`MOV [BL + D], Ry`",
    "`MOV [M], D`",
    "`MOV [BL], D`",
    "`MOV [BL + D], D`",
    "`ADD Rx, Ry`",
    "`ADD Rx, --`",
    "`ADD [M], --`",
    "`SUB Rx, Ry`",
    "`SUB Rx, --`",
    "`SUB [M], --`",
    "`CMP Rx, Ry`",
    "`CMP Rx, --`",
    "`CMP [M], --`",
    "`JMP M`",
    "`JC M`",
    "`JZ M`",
    "`Jxx M`"
  ), # nolint: line_length_linter.
  Acción = c(
    "`Rx` <-- `Ry`",
    "`Rx` <-- `Mem[Dirección]`",
    "`Rx` <-- `Mem[BL]` ",
    "`Rx` <-- `Dato`",
    "`Rx` <-- `Mem[BL + Dato]` ",
    "`Mem[Dirección]` <-- `Rx`",
    "`Mem[BL]` <-- `Rx`",
    "`Mem[BL + Dato]` <-- `Rx`",
    "`Mem[Dirección]` <-- `Dato`",
    "`Mem[BL + Dato]` <-- `Dato`",
    "`Rx` <-- `Rx + Ry`",
    "Carga en registro",
    "Almacenar en memoria",
    "`Rx` <-- `Rx - Ry`",
    "Carga en registro",
    "Almacenar en memoria",
    "No almacena el resultado en Rx: `Rx - Ry`",
    "registro-memoria",
    "memoria-registro",
    "`IP` <-- `Dirección`",
    "Si `C` = 1 entonces `IP` <-- `Dirección`",
    "Si `Z` = 1 entonces `IP` <-- `Dirección`",
    "Se pueden implementar más flags y CALL"
  ), # nolint: line_length_linter, line_length_linter.
  Codificación = c(
    "`0000 XXYY`",
    "`0001 XX00 MMMMMMMM`",
    "`0001 XX01`",
    "`0001 XX10 MMMMMMMM`",
    "`0001 XX11 MMMMMMMM`",
    "`0010 00YY MMMMMMMM`",
    "`0010 01YY`",
    "`0010 10YY MMMMMMMM`",
    "`0010 1100 MMMMMMMM dddddddd`",
    "`0010 1101 MMMMMMMM`",
    "`0010 1110 MMMMMMMM`",
    "`0011 XXYY`",
    "`0100 ---- --------`",
    "`0101 ---- -------- --------`",
    "`0110 XXYY`",
    "`0111 ---- --------`",
    "`1000 ---- -------- --------`",
    "`1001 XXYY`",
    "`1010 ---- --------`",
    "`1011 ---- -------- --------`",
    "`1100 0000 MMMMMMMM`",
    "`1100 0001 MMMMMMMM`",
    "`1100 0011 MMMMMMMM`",
    "`1100 ffff MMMMMMMM`"
  ),
  stringsAsFactors = FALSE
)

# Mostrar la tabla en formato adecuado según el tipo de salida
if (knitr::is_latex_output()) {
  kable(formatoampliado2, format = "latex", booktabs = TRUE, align = "l", col.names = c("CodOp", "Instrucción", "Acción", "Codificación"), # nolint: line_length_linter.
        caption = "Tabla de codificación de instrucciones ampliado") %>%
    kable_styling(latex_options = c("hold_position", "scale_down")) %>%
    column_spec(1, width = "4cm") %>%
    column_spec(2, width = "5cm") %>%
    column_spec(3, width = "5cm") %>%
    column_spec(4, width = "6cm") %>%
    row_spec(4, extra_latex_after = "\\midrule") %>%
    footnote(
      general = "d = dato inmediato, no puede ser destino de la instrucción.", # nolint: line_length_linter.
      general_title = "Nota: ",
      threeparttable = TRUE
    )
} else {
  kable(formatoampliado2, format = "html", table.attr = "class='table table-striped'", align = "l", col.names = c("CodOp", "Instrucción", "Acción", "Codificación"), # nolint: line_length_linter.
        caption = "Tabla de codificación de instrucciones ampliado") %>%
    kable_styling(full_width = FALSE, position = "center") %>%
    column_spec(1, width = "20em") %>%
    column_spec(2, width = "25em") %>%
    column_spec(3, width = "25em") %>%
    column_spec(4, width = "30em") %>%
    row_spec(4, extra_css = "border-top: 2px solid #000;") %>%
    footnote(
      general = "d = dato inmediato, no puede ser destino de la instrucción.", # nolint: line_length_linter.
      general_title = "Nota: ",
      threeparttable = TRUE
    )
}
```

### Ciclo de la instrucción: modos adicionales

* MOV `Rx`, `[BL]` (Carga indirecto) 
  1. **`MAR` $\leftarrow$ `IP`**:
  El valor del `IP` se transfiere a `MAR`.
  2. **`MBR` $\leftarrow$ `read(Memoria[MAR])`; `IP` $\leftarrow$ `IP` + 1**:
  Se lee (read) de memoria el contenido de la dirección indicada por `MAR` y se almacena en `MBR`.Simultáneamente, el `IP` se incrementa.
  3. **`MAR` $\leftarrow$ `BL`**:
  El contenido de `BL` se transfiere a `MAR`.
  4. **`MBR` $\leftarrow$ `read(Memoria[MAR])`**:
  Se lee de memoria el contenido de la dirección indicada por `MAR` y se almacena en `MBR`.
  5. **`Rx`  $\leftarrow$ `MBR`**:
  El contenido del `MBR` se copia al registro `Rx`.

* MOV `Rx`, `Dato` (Carga valor inmediato)
  1. **`MAR` $\leftarrow$ `IP`**:
  El valor del `IP` se transfiere a `MAR`.
  2. **`MBR` $\leftarrow$ `read(Memoria[MAR])`; `IP` $\leftarrow$ `IP` + 1**:
  Se lee (read) de memoria el contenido de la dirección indicada por `MAR` y se almacena en `MBR`.Simultáneamente, el `IP` se incrementa.
  3. **`Rx`  $\leftarrow$ `MBR`**:
  El contenido del `MBR` se copia al registro `Rx`.

## Tercera etapa
En esta etapa se incorporaron las instrucciones de manejo de pila y de interrupciones, ampliando la funcionalidad del simulador para cubrir un conjunto más completo de operaciones propias de la arquitectura x86.
A continuación, se detalla el conjunto completo de instrucciones, incluyendo su clasificación, nemónicos y las acciones que representan.

```{r isacompleta, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)

# Datos de ejemplo
isacompleta <- data.frame(
  `Código operación` = c("MOV", "ADD", "JMP", "PUSH, POP, OUT, IN", "INT , IRET", "NOP , HLT"), # nolint: line_length_linter.
  Instrucciones = c("Transferencia de datos", "Aritmética", "Control de flujo", "Pila y E/S", "Interrupciones", "Control"), # nolint: line_length_linter.
  nemónico = c(
    "MOV destino, origen",
    "ADD destino, origen",
    "JMP destino",
    "PUSH, POP, OUT, IN",
    "INT , IRET",
    "NOP , HLT"
  ),
  Acción = c(
    "1- Copiar entre registros 2- Cargar a registro 3- Almacenar en memoria",
    "1- Sumar  2- Restar 3- Comparar",
    "Salto incondicional JMP. Saltos condicionales Jxx.Llamadas a rutinas CALL y retorno RET ", # nolint: line_length_linter. # nolint: line_length_linter.
    "Poner en la pila PUSH Retirar de la pila POP Enviar un byte al puerto del dispositivo de E/S Recibir un byte del dispositivo de E/S", # nolint: line_length_linter.
    "Llamar a una rutina de tratamiento de interrupción INT Retornar de una rutina de tratamiento de interrupción IRET", # nolint: line_length_linter. # nolint: line_length_linter.
    "No opera NOP Detiene el CPU HLT"
  )
)

# Convertir a HTML o LaTeX según el formato de salida
if (knitr::is_latex_output()) {
  kable(isacompleta, format = "latex", booktabs = TRUE, longtable = TRUE, align = "l", col.names = c("Código operación", "Instrucciones", "nemónico", "Acción"), # nolint: line_length_linter.
        caption = "Tabla de Instrucciones y Códigos de Operación de la Arquitectura x86") %>% # nolint
    kable_styling(latex_options = c("scale_down", "hold_position")) %>%
    column_spec(1, width = "8em", bold = TRUE, border_right = TRUE) %>%
    column_spec(2:4, width = "10em") %>%
    row_spec(0, bold = TRUE)
} else {
  kable(isacompleta, format = "markdown", align = "l", col.names = c("Código operación", "Instrucciones", "nemónico", "Acción"), # nolint: line_length_linter.
        caption = "Tabla de Instrucciones y Códigos de Operación de la Arquitectura x86") # nolint
}
```

## Simulación visual e interactiva
Esta sección detalla la implementación de las características visuales e interactivas del simulador, diseñadas para facilitar la comprensión del flujo de datos y las microoperaciones dentro de la arquitectura x86.

### Representación gráfica de componentes
- **Diseño de la interfaz visual**: incluye elementos como registros, buses y memoria, presentados de manera clara y organizada.
- **Resaltado dinámico**: los componentes relevantes se destacan visualmente durante la ejecución, proporcionando un seguimiento en tiempo real del flujo de datos.

### Ejecución paso a paso
- **Flujo interactivo**: permite avanzar por cada etapa del ciclo de instrucción, desde la captura hasta la finalización.
- **Opciones de visualización**: se pueden observar los micropasos que conforman cada etapa de la ejecución, fomentando una comprensión detallada del proceso.

## Gestión de interrupciones y periféricos
Se describe la simulación de interrupciones y operaciones de entrada/salida, proporcionando una implementación básica para la interacción con periféricos.

### Manejo del vector de interrupciones
- **Vector predefinido**: se incluye un conjunto de interrupciones estándar.
- **Simulación de interrupciones**: ejemplos como las interacciones con teclado y pantalla están modeladas para su análisis práctico.

### Instrucciones IN y OUT
- **Operaciones de entrada/salida**: se implementan y simulan las instrucciones básicas para la interacción con periféricos.

### Segunda etapa
En esta etapa, se amplían los modos de direccionamiento e instrucciones:

## Integración de métricas de rendimiento
El simulador incorpora métricas clave para analizar el impacto del rendimiento en la arquitectura de computadoras.

### Métricas calculadas
- **Indicadores**: tiempo de ciclo, tiempo de CPU y ciclos por instrucción (CPI).
- **Visualización**: las métricas se presentan en tiempo real durante la simulación, facilitando su análisis.

### Análisis de casos de estudio
- Se incluyen ejemplos que ilustran cómo interpretar las métricas para optimizar el rendimiento.

## Proceso de validación
El proceso de validación garantiza que el simulador cumple con los requisitos pedagógicos y funcionales.

### Validación funcional
- **Pruebas de módulos**: cada componente se verificó de manera individual.
- **Ejecución completa**: programas de prueba comprobaron la correcta implementación de las instrucciones.

### Evaluación pedagógica
- **Retroalimentación**: opiniones de estudiantes y docentes guiaron los ajustes realizados.
- **Objetivos educativos**: el simulador prioriza la claridad conceptual sin sacrificar la precisión técnica.

## Portabilidad y Mantenibilidad
- **Portabilidad**: la herramienta se implementa como una aplicación web, compatible con cualquier navegador moderno.
- **Mantenibilidad**: el código modular y bien documentado facilita futuras actualizaciones y mejoras.

<!--chapter:end:05-desarrollo.Rmd-->

# Bibliografía {-}

<!--chapter:end:06-biblio.Rmd-->

